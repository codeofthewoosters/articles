<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0085)http://www.ffconsultancy.com/products/fsharp_journal/subscribers/data_structures.html -->
<!--?xml version="1.0" encoding="iso-8859-1"?--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><HTML><HEAD><META 
content="IE=10.000" http-equiv="X-UA-Compatible">
   <TITLE>F# Journal: Using the built-in Data Structures</TITLE>   
<META http-equiv="Content-Type" content="text/html; charset=windows-1252"><LINK 
href="F%23%20Journal%20Using%20the%20built-in%20Data%20Structures_files/style.css" 
rel="stylesheet" type="text/css">   <LINK href="F%23%20Journal%20Using%20the%20built-in%20Data%20Structures_files/style(1).css" 
rel="stylesheet" type="text/css">   <LINK href="F%23%20Journal%20Using%20the%20built-in%20Data%20Structures_files/individual.css" 
rel="stylesheet" type="text/css"> 
<META name="GENERATOR" content="MSHTML 10.00.9200.16458"></HEAD>
<BODY>       <TITLE>F# Journal: Using the built-in Data Structures</TITLE>     
<LINK href="F%23%20Journal%20Using%20the%20built-in%20Data%20Structures_files/style.css" 
rel="stylesheet" type="text/css">     <LINK href="F%23%20Journal%20Using%20the%20built-in%20Data%20Structures_files/style(1).css" 
rel="stylesheet" type="text/css">     <LINK href="F%23%20Journal%20Using%20the%20built-in%20Data%20Structures_files/individual.css" 
rel="stylesheet" type="text/css">         
<TABLE id="logo">
  <TBODY>
  <TR>
    <TD width="100%"><IMG src="F%23%20Journal%20Using%20the%20built-in%20Data%20Structures_files/title.gif"> 
              </TD>
    <TD><IMG src="F%23%20Journal%20Using%20the%20built-in%20Data%20Structures_files/left.gif"> 
              </TD></TR></TBODY></TABLE>
<TABLE id="menu">
  <TBODY>
  <TR>
    <TD width="25%">
    <TD width="25%"><A 
      href="http://www.ffconsultancy.com/products/index.html">Home Page</A>      
         </TD>
    <TD width="25%"><A href="http://www.ffconsultancy.com/products/fsharp_journal/subscribers/index.html">The 
      F# Journal</A>         </TD>
    <TD width="25%"></TR></TBODY></TABLE>
<TABLE id="page">
  <TBODY>
  <TR>
    <TD>
      <H1>Using the built-in Data Structures</H1>
      <P>The .NET framework provides a wide variety of mutable data structures 
      and the F# standard library supplements these with several immutable data 
      structures that provide elegant functional interfaces. This article 
      describes many of the built-in data structures, how they are used and when 
      they are most applicable.</P>
      <H2>Lazy lists</H2>
      <P>An important benefit of functional programming is the ability to defer 
      the computation of an expression by wrapping it in an anonymous function. 
      This is referred to as laziness and has many benefits in the context of 
      abstract data structures representing sequences or streams:</P>
      <P>
      <UL>
        <LI>Infinite streams can be represented and computed on-demand, such as 
        the Fibonacci sequence or the prime numbers.</LI>
        <LI>A series of operations over a sequence is naturally "deforested" 
        into a single producer-consumer operation.</LI></UL>
      <P></P>
      <P>For example, the following uses the higher-order              
      <CODE>unfold</CODE> function to define a sequence where each element is 
      the previous element plus one, starting with the element one:           
      </P>
<PRE>&gt; let nats = LazyList.unfold (fun i -&gt; Some(i, i+1)) 1;;
val nats : LazyList&lt;int&gt;
&gt; nats;;
val it : LazyList&lt;int&gt; = seq [1; 2; 3; ...]</PRE>
      <P>The result is the infinite sequence of natural numbers.</P>
      <P>The infinite sequence of squares can be generated by mapping a function 
      to square an element over the lazy list of natural numbers:</P>
<PRE>&gt; LazyList.map (fun n -&gt; n*n) nats;;
val it : LazyList&lt;int&gt; = seq [1; 4; 9; ...]</PRE>
      <P>The infinite input list [i             <SUB>0</SUB> ; i             
      <SUB>1</SUB> ; i             <SUB>2</SUB> ; ...] is transformed into [i    
               <SUB>0</SUB> ×i             <SUB>0</SUB> ; i             
      <SUB>1</SUB> ×i             <SUB>1</SUB> ; i             <SUB>2</SUB> ×i   
                <SUB>2</SUB> ; ...].           </P>
      <P>Although lazy lists have an overhead compared to ordinary eager lists, 
      they are quite common in functional programming because they naturally 
      deforest computations and lead to producer-consumer scenarios.</P>
      <P>For example, if a lexer converts a character stream into a lazy list of 
      tokens and a parser converts a lazy list of tokens into an abstract syntax 
      tree then the lexer-parser combination will only translate input on 
      demand, making it easy to handle interactive input and avoiding the 
      explicit (eager) generation of the entire intermediate token stream.</P>
      <P>The concept of a lazy list underpins abstract sequences in F#.</P>
      <H2>Sequences</H2>
      <P>The .NET framework provides an              <CODE>IEnumerable</CODE> 
      interface that many containers implement. This allows lists, arrays, sets 
      and so forth to be treated uniformly as abstract sequences of components, 
      simplifying code that uses these data structures.           </P>
      <P>This concept is so useful in F# that              
      <CODE>IEnumerable</CODE> is referred to simply as              
      <CODE>Seq</CODE> and provides a variety of useful higher-order functions 
      that can act upon sequence containers of various types, as well as 
      constructors that allow abstract sequences to be created in order to 
      represent infinite streams or even the results of database queries. In 
      particular, some of the functions (such as              <CODE>map</CODE> 
      and              <CODE>filter</CODE> ) are lazy, giving              
      <CODE>Seq</CODE> many of the benefits of              
      <CODE>LazyList</CODE> .           </P>
      <P>Comprehensions can be used to construct sequences. For example, the 
      sequence of integers from 1 to 10 inclusive is given by:</P>
<PRE>&gt; {1 .. 10};;
val it : seq&lt;int&gt; = seq [1; 2; 3; 4; ...]</PRE>
      <P>Other data structures may be explicitly converted into sequences using 
      functions of the form              <CODE>List.to_seq</CODE> or             
       <CODE>Seq.of_list</CODE> :           </P>
<PRE>&gt; List.to_seq [1 .. 5];;
val it : seq&lt;int&gt; = seq [1; 2; 3; 4; ...]</PRE>
      <P>Like the              <CODE>LazyList.unfold</CODE> function, sequences 
      may be constructed via unfolding:           </P>
<PRE>&gt; Seq.unfold;;
val it : (('a -&gt; ('b * 'a) option) -&gt; 'a -&gt; seq&lt;'b&gt;) </PRE>
      <P>The sequence of natural numbers is:</P>
<PRE>&gt; Seq.unfold (fun i -&gt; Some(i, i+1)) 1;;
val it : seq&lt;int&gt; = seq [0; 1; 2; 3; ...]</PRE>
      <P>The infinite Fibonacci sequence may be unfolded by accumulating the 
      last two numbers:</P>
<PRE>&gt; Seq.unfold (fun (i, j) -&gt; Some(i+j, (i+j, i))) (0, 1);;
val it : seq&lt;int&gt; = seq [1; 1; 2; 3; ...]</PRE>
      <P>The infinite sequence of primes may be unfolded by accumulating a 
      function that recursively searches for the next prime before filtering out 
      multiples of the new prime, starting with two:</P>
<PRE>&gt; let rec f (i, not_prime) =
    if not_prime i then f (i+1, not_prime) else
      let not_prime j = j%i=0 || not_prime j
      Some(i, (i+1, not_prime));;
val f : int * (int -&gt; bool) -&gt; (int * (int * (int -&gt; bool))) option
&gt; Seq.unfold f (2, fun _ -&gt; false);;
val it : seq&lt;int&gt; = seq [3; 5; 7; 11; ...]</PRE>
      <P>As we have described, many of the containers provided by .NET and F# 
      implement the              <CODE>Seq</CODE> interface. In the absence of a 
      more specific pretty printer, an F# interactive session will print such 
      containers as a sequence using the syntax:           </P>
<PRE>val it : ... = seq [...]</PRE>
      <P>As seen in the previous example.</P>
      <H2>Mutable data structures</H2>
      <P>Let us begin by examining the more conventional, mutable data 
      structures that are integrated into the F# language. Due to their 
      mutability, these data structures have the conventional advantages and 
      disadvantages found in equivalent data structures from other languages. 
      Beyond the capabilities of equivalent data structures in languages like 
      Java, C# and C++, the mutable data structures implemented in the F# 
      standard library also provides a wealth of higher-order functions.</P>
      <H3>Arrays</H3>
      <P>The humble array is the simplest mutable data structure provided by F#. 
      As an augmented .NET array, F# arrays are completely interoperable with 
      arrays from other .NET languages.</P>
      <P>Arrays have the following benefits:</P>
      <P>
      <UL>
        <LI>Compact storage</LI>
        <LI>Fast (constant-time) lookup of any element by its integer 
      index</LI></UL>
      <P></P>
      <P>However, arrays are inextensible and do not offer any ingenious sorting 
      or searching capabilities.</P>
      <P>The simplest way to construct an array is to specify a literal composed 
      of the array elements:</P>
<PRE>&gt; [|1; 2; 3|];;
val it : int array = [|1; 2; 3|]</PRE>
      <P>As the              <CODE>Array</CODE> class implements indexing 
      (getters and setters for the              <CODE>Item</CODE> property, as 
      described in the F# Journal article on objects), arrays may be indexed 
      using the conventional F# notation              <CODE>a.[i]</CODE> :       
          </P>
<PRE>&gt; [|1; 2; 3|].[1];;
val it : int = 2</PRE>
      <P>Equivalently, an array may be indexed by calling the curried            
        <CODE>Array.get</CODE> function:           </P>
<PRE>&gt; Array.get;;
val it : ('a array -&gt; int -&gt; 'a)</PRE>
      <P>This can be useful when referring to an arrays contents in a functional 
      style.</P>
      <P>Arrays may also be constructed programmatically using the higher-order  
                  <CODE>Array.init</CODE> function:           </P>
<PRE>&gt; Array.init 5 (fun i -&gt; i*i);;
val it : int array = [|0; 1; 4; 9; 16|]</PRE>
      <P>Arrays may also be constructed programmatically using 
      comprehensions:</P>
<PRE>&gt; [|for i in 0 .. 4 -&gt;
      i*i|];;
val it : int array = [|0; 1; 4; 9; 16|]</PRE>
      <P>Arrays also provide the conventional higher-order functions that 
      replace most loops in imperative code. For example, applying the           
         <CODE>fold_left</CODE> function with the addition operator              
      <CODE>( + )</CODE> and zero as the base case to the array              
      <CODE>[|1; 2; 3|]</CODE> calculates ((0+1)+2)+3=6:           </P>
<PRE>&gt; Array.fold_left ( + ) 0 [|1; 2; 3|];;
val it : int = 6</PRE>
      <P>As we shall see in future journal articles, arrays remain a useful and 
      fundamental data structure in the F# language. However, there are many 
      more interesting data structures that offer useful benefits, particularly 
      with regard to sorting and searching.</P>
      <H3>Multidimensional arrays</H3>
      <P>F# also supports arrays with multiple integer indexes where the number 
      of indexes (the dimension) is defined at compile time.</P>
      <P>Like 1-dimensional arrays, multidimensional arrays may be constructed 
      programmatically using an              <CODE>init</CODE> function:         
        </P>
<PRE>&gt; Array2.init;;
val it : (int -&gt; int -&gt; (int -&gt; int -&gt; 'a) -&gt; 'a [,]
&gt; Array3.init;;
val it : (int -&gt; int -&gt; int -&gt; (int -&gt; int -&gt; int -&gt; 'a) -&gt; 'a [,,]</PRE>
      <P>For example, a two-dimensional array:</P>
<PRE>&gt; let a = Array2.init 3 4 (fun i j -&gt; i*j);;
val a : int [,] = [|[|0; 0; 0; 0|]; [|0; 1; 2; 3|]; [|0; 2; 4; 6|]|]</PRE>
      <P>Such arrays are indexed by comma-separated lists of indexes. For 
      example, the element in the second row and fourth column is given by:</P>
<PRE>&gt; a.[1, 3];;
val it : int = 3</PRE>
      <P>Multidimensional arrays are ideal for representing images, tensors and 
      so forth.</P>
      <H2>Hash tables (dictionaries)</H2>
      <P>This mutable data structure is common in modern programming languages. 
      A hash table can be thought of as a generalization of an array where the 
      index is no longer restricted to an              <CODE>int</CODE> in a 
      certain range. Hash tables map keys to values where the keys and values 
      may be of any type.           </P>
      <P>Hash tables are most easily constructed from association lists. An 
      association list is a value of the type              <CODE>('a * 'b) 
      list</CODE> where              <CODE>'a</CODE> is the type of the keys and 
                   <CODE>'b</CODE> is the type of the corresponding values.      
           </P>
      <P>For example, a hash table that maps the first five non-negative 
      integers to their squares may be constructed as:</P>
<PRE>&gt; let ht = Hashtbl.of_seq {for i in 0 .. 4 -&gt; i, i*i};;
val ht : HashMultiMap&lt;int, int&gt;</PRE>
      <P>The resulting hash table is rather like the array              
      <CODE>[|0; 1; 4; 9; 16|]</CODE> in that it may be indexed by integer:      
           </P>
<PRE>&gt; ht.[3];;
val it : int = 9</PRE>
      <P>However, the integers indexing this hash table do not need to lie in a 
      particular range. For example, we can insert a new key-value binding at 
      the end:</P>
<PRE>&gt; ht.[5] &lt;- 25;;</PRE>
      <P>and delete an existing binding:</P>
<PRE>&gt; Hashtbl.remove ht 0;;</PRE>
      <P>An association list may be recovered from a hash table by folding over 
      the elements, accumulating a list of the key-value pairs:</P>
<PRE>&gt; Hashtbl.fold (fun k v t -&gt; (k, v) :: t) ht [];;
val it : (int * int) list = [(1, 1); (2, 4); (3, 9); (4, 16); (5, 25)]</PRE>
      <P>The hash table implementation provided with the F# programming language 
      is slightly unusual in that it allows multiple bindings with the same key. 
      This is useful in the context of metaprogramming (writing compilers, 
      interpreters and translators for other programming languages) because an 
      F# hash table may be used to map variable names onto their values. When a 
      local variable in a new scope shadows a previous definition, this exploits 
      the multiple keys as the first bindings for any given variable name is its 
      most local definition. We shall revisit metaprogramming it later 
      articles.</P>
      <P>Out of interest, F# programmers can also use .NET collections, such as 
      the .NET              <CODE>Dictionary</CODE> that implements a more 
      conventional (and often slightly slower) hash table:           </P>
<PRE>&gt; open System.Collections.Generic;;
&gt; let dict = new Dictionary&lt;int, int&gt;();;
val dict : Dictionary&lt;int, int&gt;
&gt; Array.iter (fun (k, v) -&gt; dict.[k] &lt;- v) [|for i in 0 .. 4 -&gt; i, i*i|];;
&gt; dict.[3];;
val it : int = 9
&gt; dict.[5] &lt;- 25;;
&gt; dict.Remove(0);;
&gt; dict |&gt; Seq.map (fun b -&gt; b.Key, b.Value);;
val it : seq&lt;int * int&gt; = [(1, 1); (2, 4); (3, 9); (4, 16); ...]</PRE>
      <P>This excerpt demonstrates several interesting points:</P>
      <P>
      <UL>
        <LI>A uniform syntax is used to insert and retrieve key-value bindings, 
        thanks to the standard implementation of indexing offered by .NET.</LI>
        <LI>Key-value bindings are most easily extracted by treating the .NET    
                      <CODE>Dictionary</CODE> class as an abstract sequence 
        using the                  <CODE>Seq.map</CODE> function.               
        </LI>
        <LI>The bindings are stored as objects of the class                  
        <CODE>KeyValuePair&lt;int, int&gt;</CODE> so they must be extracted via 
        the                  <CODE>Key</CODE> and                  
        <CODE>Value</CODE> properties.               </LI>
        <LI>When writing in an object-oriented style to extract the components 
        of a binding, successful type inference requires that the container      
                    <CODE>dict</CODE> (and therefore its type) be presented 
        beforehand (in this case by rearranging the expression using the         
                 <CODE>|&gt;</CODE> operator) to ensure that the type of         
                 <CODE>b</CODE> has already been determined to be                
          <CODE>KeyValuePair&lt;int, int&gt;</CODE> by the time                  
        <CODE>b.Key</CODE> is type checked.               </LI></UL>
      <P></P>
      <P>F# also provides some mathematical data structures.</P>
      <H3>Vectors and Matrices</H3>
      <P>Vectors and matrices may be constructed from              
      <CODE>float</CODE> sequences such as lists:           </P>
<PRE>&gt; let u, v = vector [1.; 2.; 3.], vector [2.; 3.; 4.];;
val u : vector
val v : vector</PRE>
      <P>The conventional operators are already overloaded to apply to vectors 
      and matrices. For example, vector addition:</P>
<PRE>&gt; u+v;;
val it : Math.Vector&lt;float&gt; = vector [3.0; 5.0; 7.0]</PRE>
      <P>Specialized operations are also supplied, such as the vector dot 
      product:</P>
<PRE>&gt; Math.Vector.dot u v;;
val it : float = 20.0</PRE>
      <P>Matrix-vector transformations use the              <CODE>*</CODE> 
      operator:           </P>
<PRE>matrix [[0.; 2.]; [-3.; 0.]] * vector [1.; 1.]
val it : Math.Vector&lt;float&gt; = vector [2.0; -3.0]</PRE>
      <P>Now that we have described some of the more mundane data structures 
      offered by the F# language, we can move on to the more exotic topic of 
      immutable data structures.</P>
      <H2>Immutable data structures</H2>
      <P>As we saw in the              <A href="http://www.ffconsultancy.com/products/fsharp_journal/subscribers/essence.html">Essence 
      of Functional Programming article</A> , immutability is a core concept in 
      functional programming. Consequently, the F# programming language provide 
      a variety of useful immutable data structures and, more importantly, makes 
      it very easy to define new data structures such as the              
      <CODE>expr</CODE> type used in previous articles.           </P>
      <P>This section describes the three most important immutable data 
      structures provided with F#.</P>
      <H3>Lists</H3>
      <P>The singly linked list is the simplest immutable data structure and it 
      is ubiquitous in functional programming languages like F#, where it is 
      known simply as the list data structure.</P>
      <P>Lists may be constructed as literals:</P>
<PRE>&gt; [1; 2; 3];;
val it : int list = [1; 2; 3]</PRE>
      <P>or programmatically:</P>
<PRE>&gt; List.init 5 (fun i -&gt; i*i);;
val it : int list = [0; 1; 4; 9; 16]</PRE>
      <P>The utility of the list data structure lies in its ability to grow and 
      shrink from the front. More specifically, a new list can be created that 
      has a given head element and tail list and, conversely, a list can be 
      decomposed into its head element (the first element) and its tail list 
      (the list of the remaining elements). This is a direct result of the 
      recursive nature of the linked list data structure.</P>
      <P>In F#, the syntax              <CODE>h::t</CODE> is used to represent 
      the list created from the head element              <CODE>h</CODE> and the 
      tail list              <CODE>t</CODE> . The ability to new lists to share 
      existing tail lists is instrumental in functional programming and this 
      reuse of existing data structures (persistence) is a core concept that 
      relies upon referential transparency (immutable data structures never need 
      to be copied).           </P>
      <P>For example, given a list              <CODE>a</CODE> :           </P>
<PRE>&gt; let a = [2; 3];;
val a : int list</PRE>
      <P>we can create two new lists that both use              <CODE>a</CODE> 
      as their tails:           </P>
<PRE>&gt; let b, c = 0::a, 1::a;;
val b : int list
val c : int list
&gt; b;;
val it : int list = [0; 2; 3]
&gt; c;;
val it : int list = [1; 2; 3]</PRE>
      <P>The creation of these new lists is a constant time operation because it 
      does not need to copy the existing list. Moreover, it does not alter the 
      existing list, so the list              <CODE>a</CODE> retains its 
      original value and can be reused as often as necessary.           </P>
      <P>Lists may be deconstructed using the name syntax. If              
      <CODE>h::t</CODE> appears in a pattern match over a list then it matches 
      any non-empty list and binds              <CODE>h</CODE> to the first 
      element and              <CODE>t</CODE> to the list of the remaining 
      elements.           </P>
      <P>For example, the following functions tests for the empty list using 
      pattern matching:</P>
<PRE>&gt; let is_empty = function
    | [] -&gt; true
    | _::_ -&gt; false;;
val is_empty : 'a list -&gt; bool</PRE>
      <P>The ability to deconstruct and reconstruct lists allows many list 
      operations to be written clearly and simply as recursive functions using 
      pattern matching.</P>
      <P>The following              <CODE>remove_dups</CODE> function removes 
      sequential duplicates from a list:           </P>
<PRE>&gt; let rec remove_dups = function
    | h1::(h2::_ as t) when h1=h2 -&gt; remove_dups t
    | h::t -&gt; h::remove_dups t
    | [] -&gt; [];;
val remove_dups : 'a list -&gt; 'a list</PRE>
      <P>For example:</P>
<PRE>&gt; remove_dups [1; 1; 1; 2; 2; 3; 3; 3];;
val it : int list = [1; 2; 3]</PRE>
      <P>Although lists are the simplest data structure in F#, it is vitally 
      important to appreciate the power that immutability provides. When using 
      immutable data structures, you never need to worry about contents 
      changing, iterators becoming invalid, thread safety or sharing.</P>
      <P>The lessons learned from studying lists also apply to the other 
      immutable data structures provided by F#.</P>
      <H3>Sets</H3>
      <P>The set data structure provides a sorted container without duplicates 
      and offers efficient insertion, removal, membership testing and 
      set-theoretic operations (union, intersection and difference).</P>
      <P>The empty set is denoted              <CODE>Set.empty</CODE> and adding 
      an element to a set using the              <CODE>Set.add</CODE> function 
      creates a new set:           </P>
<PRE>&gt; Set.add 3 Set.empty;;
val it : Set&lt;int&gt; = seq [3]</PRE>
      <P>Note that the set data structure also implements the abstract sequence 
      interface.</P>
      <P>A set may be constructed from a list (or array or sequence):</P>
<PRE>Set.of_list [4; 2; 3; 2; 1]
// val it : Set&lt;int&gt; = seq [1; 2; 3; 4]</PRE>
      <P>Note that duplicate elements were removed and the elements are 
      sorted.</P>
      <P>The set-theoretic operations are implemented by the functions           
         <CODE>Set.union</CODE> ,              <CODE>Set.inter</CODE> and        
            <CODE>Set.diff</CODE> . For example, the union of the sets of 
      integers {1 .. 1,010,000} and {1,000,000 .. 2,000,000} is given by:        
         </P>
<PRE>&gt; let s1 = Set.of_array [|1. .. 1.01e6|];;
val s1 : set&lt;int&gt;
&gt; let s2 = Set.of_seq [|1e6 .. 2.e6|];;
val s2 : set&lt;int&gt;
&gt; Set.union s1 s2;;
val it : Set&lt;int&gt; = seq [0; 1; 2; 3; ...]</PRE>
      <P>In particular, note how the union is computed very quickly. This is 
      actually much more efficient than the set union implementations provided 
      with most imperative languages (such as C++). To avoid a later mutation of 
      the input value affected the result of a union, imperative languages 
      typically dictate that the union function must copy its input. In 
      contrast, the F# implementation simply refers to parts of its inputs when 
      constructing the result, making it much more efficient.</P>
      <P>We can time this union operation using a              <CODE>time</CODE> 
      combinator:           </P>
<PRE>&gt; let time f x = 
    let t = Sys.time()
    let f_x = f x
    printf "Took %gs\n" (Sys.time() - t)
    f_x;;
val time : ('a -&gt; 'b) -&gt; 'a -&gt; 'b
&gt; time (Set.union s1) s2
Took 0.015625s</PRE>
      <P>The equivalent C++ is not only much longer than              
      <CODE>Set.union s1 s2</CODE> , it is also much slower because it must copy 
      every element that appears in the result:           </P>
<PRE>#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;ctime&gt;</PRE>
<PRE>using namespace std;</PRE>
<PRE>int main() {
  set&lt;int&gt; s1, s2;
  for (int i=0; i&lt;1010000; ++i) s1.insert(i);
  for (int i=1000000; i&lt;2000000; ++i) s1.insert(i);
  clock_t start = clock();
  set&lt;int&gt; s3;
  insert_iterator&lt;set&lt;int&gt; &gt; it(s3, s3.begin());
  set_union(s1.begin(), s1.end(), s2.begin(), s2.end(), it);
  cout &lt;&lt; double(clock() - start) / CLOCKS_PER_SEC &lt;&lt; endl;
}</PRE>
      <P>This program takes 1.07s, so the F# is 70× faster.</P>
      <H3>Maps</H3>
      <P>The last data structure covered in this article is a functional 
      equivalent of the hash table. The map data structure allows key-value 
      bindings to be handled in a purely functional style, with the addition and 
      removal of bindings resulting in new maps.</P>
      <P>Just like a hash table, a map can be created from an association 
      list:</P>
<PRE>&gt; let m = Map.of_seq ["x", 3; "y", 4];;
val m : Map&lt;string,int&gt;</PRE>
      <P>Indexing by key returns the corresponding value. This example map binds 
      the string              <CODE>"x"</CODE> to the value              
      <CODE>3</CODE> :           </P>
<PRE>&gt; m.["x"];;
val it : int = 3</PRE>
      <P>Unlike the hash table, inserting and removing bindings from a map 
      result in new maps. So the              <CODE>m.[k] &lt;- v</CODE> syntax 
      cannot be used for insertion as it assumes a              
      <CODE>unit</CODE> return type. So we must use the              
      <CODE>Map.add</CODE> and              <CODE>Map.remove</CODE> functions:   
              </P>
<PRE>&gt; let m2 = Map.remove "x" m;;
val m2 : Map&lt;string,int&gt;</PRE>
      <P>The immutable              <CODE>Set</CODE> and              
      <CODE>Map</CODE> data structures use non-trivial algorithms to share data 
      internally such that, although the result of inserting a new element or 
      binding is a new set or map, the new data structures share most of their 
      internals with existing data structures. This allows these operations to 
      be performed both efficiently and safely.           </P>
      <P>Future journal articles will use these data structures extensively as 
      well as creating new customized data structures for various 
    purposes.</P></TD></TR></TBODY></TABLE>
<TABLE id="footer">
  <TBODY>
  <TR>
    <TD>© Flying Frog Consultancy Ltd., 2007</TD>
    <TD>Contact the            <A 
      href="mailto:webmaster@ffconsultancy.com">webmaster</A>         
  </TD></TR></TBODY></TABLE>
<SCRIPT src="F%23%20Journal%20Using%20the%20built-in%20Data%20Structures_files/urchin.js" type="text/javascript">
<script type="text/javascript">
_uacct = "UA-197840-1";
urchinTracker();</SCRIPT>
 </BODY></HTML>
