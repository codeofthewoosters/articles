<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0088)http://www.ffconsultancy.com/products/fsharp_journal/subscribers/silverlightsockets.html -->
<HTML><HEAD><META content="IE=7.0000" http-equiv="X-UA-Compatible">
<TITLE>F# Journal</TITLE>
<META content="text/html; charset=windows-1252" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="F%23%20Journal%20using%20sockets%20from%20silverlight_files/style.css"><LINK 
rel=stylesheet type=text/css 
href="F%23%20Journal%20using%20sockets%20from%20silverlight_files/style(1).css"><LINK 
rel=stylesheet type=text/css 
href="F%23%20Journal%20using%20sockets%20from%20silverlight_files/individual.css">
<META name=GENERATOR content="MSHTML 10.00.9200.16458"></HEAD>
<BODY>
<TABLE id=logo>
  <TBODY>
  <TR>
    <TD width="100%"><IMG 
      src="F%23%20Journal%20using%20sockets%20from%20silverlight_files/title.gif"> 
    </TD>
    <TD><IMG 
      src="F%23%20Journal%20using%20sockets%20from%20silverlight_files/left.gif"> 
    </TD></TR></TBODY></TABLE>
<TABLE id=menu>
  <TBODY>
  <TR>
    <TD width="25%">
    <TD width="25%"><A 
      href="http://www.ffconsultancy.com/products/index.html">Home Page</A> </TD>
    <TD width="25%"><A 
      href="http://www.ffconsultancy.com/products/fsharp_journal/subscribers/index.html">The 
      F# Journal</A> </TD>
    <TD width="25%"></TD></TR></TBODY></TABLE>
<TABLE id=page>
  <TBODY>
  <TR>
    <TD>
      <H1>Using sockets from Silverlight</H1>
      <P>Silverlight applications can communicate with remote servers via TCP 
      sockets. This can be done without requiring elevated permissions (e.g. in 
      browser) provided a client access policy server is running on the remote 
      machine. This article describes how both the client- and server-side 
      solutions to this problem can be written in F#.</P>
      <H2>Client access policy server</H2>
      <P>This is a TCP server that listens for connections on port 943, reads 
      and discards an instruction when a client connects and replies with a 
      fixed XML message.</P>
      <P>The XML message is most elegantly encoded in a Visual Studio solution 
      as an embedded resource. This is accomplished by adding the XML file to 
      the project and setting the "Build Action" in the properties pane for the 
      file to "EmbeddedResource". A running .NET assembly may then read a 
      resource embedded in the assembly as follows. First, the executing 
      assembly is obtained:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;assembly&nbsp;=&nbsp;System.Reflection.Assembly.GetExecutingAssembly();;</CODE></P>
      <P>Then the string containing the XML may be extracted by obtaining the 
      embedded resource as a stream:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;clientAccessPolicy&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;stream&nbsp;=&nbsp;assembly.GetManifestResourceStream("ClientAccessPolicy.xml")<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;stream&nbsp;=&nbsp;null&nbsp;then&nbsp;invalidArg&nbsp;"stream"&nbsp;"Failed&nbsp;to&nbsp;get&nbsp;manifest&nbsp;resource&nbsp;stream"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;reader&nbsp;=&nbsp;new&nbsp;System.IO.StreamReader(stream)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|for&nbsp;c&nbsp;in&nbsp;reader.ReadToEnd()&nbsp;-&gt;&nbsp;byte&nbsp;c|];;</CODE></P>
      <P>The TCP server will make use of definitions from the following 
      namespaces:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;open&nbsp;System.Net;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;open&nbsp;System.Net.Sockets;;</CODE></P>
      <P>In order to log messages to the console concurrently we used the 
      following <CODE>log</CODE> function that uses a lock to prevent 
      overwriting:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;log&nbsp;(s:&nbsp;string)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;stdout&nbsp;(fun&nbsp;()&nbsp;-&gt;&nbsp;System.Console.WriteLine&nbsp;s);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;log&nbsp;:&nbsp;string&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>The policy server is most simply implemented as an asynchronous 
      workflow:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;policyServer&nbsp;=&nbsp;async&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;listener&nbsp;=&nbsp;new&nbsp;Sockets.TcpListener(IPAddress.Any,&nbsp;943)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listener.Start()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log&nbsp;"Policy&nbsp;server&nbsp;started"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;true&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;client&nbsp;=&nbsp;listener.AcceptTcpClient()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;stream&nbsp;=&nbsp;client.GetStream()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log&nbsp;"Received&nbsp;connection&nbsp;to&nbsp;policy&nbsp;server"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;buffer&nbsp;=&nbsp;Array.create&nbsp;1024&nbsp;0uy<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let!&nbsp;count&nbsp;=&nbsp;stream.AsyncRead(buffer,&nbsp;0,&nbsp;buffer.Length)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log&nbsp;"Received&nbsp;policy&nbsp;request"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do!&nbsp;stream.AsyncWrite(clientAccessPolicy,&nbsp;0,&nbsp;clientAccessPolicy.Length)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;e&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log&nbsp;(sprintf&nbsp;"Policy&nbsp;server&nbsp;connection&nbsp;died&nbsp;with&nbsp;%A"&nbsp;e)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;|&gt;&nbsp;Async.Start<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;policyServer&nbsp;:&nbsp;Async&lt;unit&gt;</CODE></P>
      <P>Similarly, the message server may be written as follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;messageServer&nbsp;=&nbsp;async&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;listener&nbsp;=&nbsp;new&nbsp;Sockets.TcpListener(IPAddress.Any,&nbsp;4502)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listener.Start()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log&nbsp;"Message&nbsp;server&nbsp;started"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;n&nbsp;=&nbsp;ref&nbsp;0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;true&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;client&nbsp;=&nbsp;listener.AcceptTcpClient()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;incr&nbsp;n<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;n&nbsp;=&nbsp;!n<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log&nbsp;(sprintf&nbsp;"Client&nbsp;%d:&nbsp;Connected"&nbsp;n)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;stream&nbsp;=&nbsp;client.GetStream()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;reader&nbsp;=&nbsp;new&nbsp;System.IO.StreamReader(stream)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;writer&nbsp;=&nbsp;new&nbsp;System.IO.StreamWriter(stream)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;not&nbsp;reader.EndOfStream&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;line&nbsp;=&nbsp;reader.ReadLine()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log&nbsp;(sprintf&nbsp;"Client&nbsp;%d:&nbsp;Read&nbsp;'%s'"&nbsp;n&nbsp;line)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.WriteLine&nbsp;line<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writer.Flush()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;e&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log(sprintf&nbsp;"Client&nbsp;connection&nbsp;died&nbsp;with&nbsp;%A"&nbsp;e)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;|&gt;&nbsp;Async.Start<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;messageServer&nbsp;:&nbsp;Async&lt;unit&gt;</CODE></P>
      <P>The servers are most easily started by a main program that starts the 
      message server independently in the thread pool using 
      <CODE>Async.Start</CODE> and then starts the policy server and blocks 
      waiting for it to complete using <CODE>Async.RunSynchronously</CODE>:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Async.Start&nbsp;messageServer<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Async.RunSynchronously&nbsp;policyServer;;</CODE></P>
      <P>The remainder of this article is concerned with the Silverlight client 
      that accesses this server.</P>
      <H2>Silverlight client</H2>
      <P>We begin by opening the following namespaces:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;open&nbsp;System.Windows;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;open&nbsp;System.Net;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;open&nbsp;System.Net.Sockets;;</CODE></P>
      <P>Silverlight provides only an asynchronous API for communicating over 
      TCP sockets and not a synchronous interface. We can productively wrap this 
      API in order to use it from F# asynchronous workflows.</P>
      <P>The following <CODE>asyncOp</CODE> function is a generic way to 
      initiate an asynchronous operation using the 
      <CODE>SocketAsyncEventArgs</CODE> to convey information from one 
      continuation to the next, initializing this using the <CODE>init</CODE> 
      function:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;asyncOp&nbsp;(socket:&nbsp;Socket)&nbsp;init&nbsp;f&nbsp;k&nbsp;=&nbsp;async&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;e&nbsp;=&nbsp;new&nbsp;SocketAsyncEventArgs(RemoteEndPoint=socket.RemoteEndPoint)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init&nbsp;e<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;exec&nbsp;(onSuccess,&nbsp;onError,&nbsp;onCancelled)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;callback&nbsp;(e&nbsp;:&nbsp;SocketAsyncEventArgs)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;err&nbsp;=&nbsp;e.SocketError<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;err&nbsp;=&nbsp;SocketError.Success&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;result&nbsp;=&nbsp;k&nbsp;e<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.Dispose()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onSuccess&nbsp;result<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.Dispose()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onError&nbsp;(SocketException(int&nbsp;e.SocketError)&nbsp;:&gt;&nbsp;exn)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.Completed.Add&nbsp;callback<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;(f&nbsp;e)&nbsp;then&nbsp;callback&nbsp;e<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return!&nbsp;Async.FromContinuations&nbsp;exec<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;asyncOp&nbsp;:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Socket&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(SocketAsyncEventArgs&nbsp;-&gt;&nbsp;unit)&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(SocketAsyncEventArgs&nbsp;-&gt;&nbsp;bool)&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(SocketAsyncEventArgs&nbsp;-&gt;&nbsp;'a)&nbsp;-&gt;&nbsp;Async&lt;'a&gt;</CODE></P>
      <P>Note that this will not be a high performance solution as the 
      <CODE>SocketAsyncEventArgs</CODE> class is expensive and intended to be 
      reused.</P>
      <P>Sending and receiving requires the buffer to be set so we can 
      productively factor out the following commonality:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;asyncTransfer&nbsp;socket&nbsp;f&nbsp;buffer&nbsp;pos&nbsp;count&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asyncOp&nbsp;socket&nbsp;(fun&nbsp;e&nbsp;-&gt;&nbsp;e.SetBuffer(buffer,&nbsp;pos,&nbsp;count))&nbsp;f&nbsp;(fun&nbsp;e&nbsp;-&gt;&nbsp;e.BytesTransferred);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;asyncTransfer&nbsp;:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Socket&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(SocketAsyncEventArgs&nbsp;-&gt;&nbsp;bool)&nbsp;-&gt;&nbsp;byte&nbsp;[]&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;Async&lt;int&gt;</CODE></P>
      <P>The <CODE>Socket</CODE> class may then be augmented with extension 
      members to connect, send and receive asynchronously as follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;type&nbsp;System.Net.Sockets.Socket&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;socket.AsyncConnect&nbsp;endPoint&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asyncOp&nbsp;socket&nbsp;(fun&nbsp;e&nbsp;-&gt;&nbsp;e.RemoteEndPoint&nbsp;&lt;-&nbsp;endPoint)&nbsp;socket.ConnectAsync&nbsp;(fun&nbsp;e&nbsp;-&gt;&nbsp;())<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;socket.AsyncSend(buffer,&nbsp;pos,&nbsp;count)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asyncTransfer&nbsp;socket&nbsp;socket.SendAsync&nbsp;buffer&nbsp;pos&nbsp;count<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;socket.AsyncReceive(buffer,&nbsp;pos,&nbsp;count)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asyncTransfer&nbsp;socket&nbsp;socket.ReceiveAsync&nbsp;buffer&nbsp;pos&nbsp;count<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;socket.AsyncReallySend&nbsp;(buffer:&nbsp;byte&nbsp;[])&nbsp;=&nbsp;async&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;send&nbsp;position&nbsp;=&nbsp;async&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;position&nbsp;&lt;&nbsp;buffer.Length&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let!&nbsp;count&nbsp;=&nbsp;socket.AsyncSend(buffer,&nbsp;position,&nbsp;buffer.Length-position)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;count&nbsp;=&nbsp;0&nbsp;then&nbsp;raise(new&nbsp;System.IO.IOException())<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return!&nbsp;send&nbsp;(position&nbsp;+&nbsp;count)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do!&nbsp;send&nbsp;0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;socket.AsyncReallyReceive&nbsp;length&nbsp;=&nbsp;async&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;buffer&nbsp;=&nbsp;Array.create&nbsp;length&nbsp;0uy<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;read&nbsp;position&nbsp;=&nbsp;async&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;position&nbsp;&lt;&nbsp;length&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let!&nbsp;count&nbsp;=&nbsp;socket.AsyncReceive(buffer,&nbsp;position,&nbsp;buffer.Length&nbsp;-&nbsp;position)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;count&nbsp;=&nbsp;0&nbsp;then&nbsp;raise(new&nbsp;System.IO.IOException())<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return!&nbsp;read&nbsp;(position&nbsp;+&nbsp;count)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do!&nbsp;read&nbsp;0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;buffer<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};;<BR>&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;Socket&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;AsyncConnect&nbsp;:&nbsp;endPoint:System.Net.EndPoint&nbsp;-&gt;&nbsp;Async&lt;unit&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;Socket&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;AsyncSend&nbsp;:&nbsp;buffer:byte&nbsp;[]&nbsp;*&nbsp;pos:int&nbsp;*&nbsp;count:int&nbsp;-&gt;&nbsp;Async&lt;int&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;Socket&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;AsyncReceive&nbsp;:&nbsp;buffer:byte&nbsp;[]&nbsp;*&nbsp;pos:int&nbsp;*&nbsp;count:int&nbsp;-&gt;&nbsp;Async&lt;int&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;Socket&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;AsyncReallySend&nbsp;:&nbsp;buffer:byte&nbsp;[]&nbsp;-&gt;&nbsp;Async&lt;unit&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;Socket&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;AsyncReallyReceive&nbsp;:&nbsp;length:int&nbsp;-&gt;&nbsp;Async&lt;byte&nbsp;[]&gt;</CODE></P>
      <P>Finally, the <CODE>MainPage</CODE> control required for the Silverlight 
      application may be written as follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;type&nbsp;MainPage()&nbsp;as&nbsp;this&nbsp;=&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inherit&nbsp;Controls.UserControl()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;textbox&nbsp;=&nbsp;Controls.TextBox(IsReadOnly=true)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;log&nbsp;x&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;textbox.Dispatcher.BeginInvoke(fun&nbsp;()&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;textbox.Text&nbsp;&lt;-&nbsp;textbox.Text&nbsp;+&nbsp;x&nbsp;+&nbsp;"\n")<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;ignore;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;connect&nbsp;host&nbsp;=&nbsp;async&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;socket&nbsp;=&nbsp;new&nbsp;Sockets.Socket(Sockets.AddressFamily.InterNetwork,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sockets.SocketType.Stream,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sockets.ProtocolType.Tcp)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log&nbsp;"Connecting..."<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do!&nbsp;socket.AsyncConnect(DnsEndPoint(host,&nbsp;4502))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log&nbsp;"Connected."<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log&nbsp;"Sending&nbsp;data..."<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;msg&nbsp;=&nbsp;"Hello&nbsp;world!\n"B<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do!&nbsp;socket.AsyncReallySend&nbsp;msg<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let!&nbsp;msg&nbsp;=&nbsp;socket.AsyncReallyReceive&nbsp;msg.Length<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log&nbsp;(sprintf&nbsp;"Received&nbsp;'%s'"&nbsp;(String.concat&nbsp;""&nbsp;(Seq.map&nbsp;(char&nbsp;&gt;&gt;&nbsp;string)&nbsp;msg)))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log&nbsp;"Sent&nbsp;data."<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log&nbsp;"Closing&nbsp;connection..."<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;e&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log&nbsp;(sprintf&nbsp;"Client&nbsp;died&nbsp;with&nbsp;error&nbsp;%A"&nbsp;e)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log&nbsp;"Silverlight&nbsp;client&nbsp;started..."<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;panel&nbsp;=&nbsp;Controls.StackPanel()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;scroll&nbsp;=&nbsp;Controls.ScrollViewer(Content=textbox)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scroll.HorizontalScrollBarVisibility&nbsp;&lt;-&nbsp;Controls.ScrollBarVisibility.Visible<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scroll&nbsp;|&gt;&nbsp;panel.Children.Add<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;host&nbsp;=&nbsp;Controls.TextBox(Text="localhost")<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;host&nbsp;|&gt;&nbsp;panel.Children.Add<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;connectButton&nbsp;=&nbsp;Controls.Button(Content="Connect")<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connectButton.Click.Add(fun&nbsp;e&nbsp;-&gt;&nbsp;Async.Start(connect&nbsp;host.Text))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connectButton&nbsp;|&gt;&nbsp;panel.Children.Add<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.Content&nbsp;&lt;-&nbsp;panel</CODE></P>
      <P>This produces a Silverlight client that can connect to our echo server 
      using TCP sockets, thanks to the presence of a client access policy 
      server, and send/receive messages.</P>
      <H2>Summary</H2>
      <P>This article has described how to create a Silverlight client access 
      policy server and message server on a remote machine and a Silverlight 
      application on another that can connect to the message server in order to 
      communicate over the network without requiring elevated permissions.</P>
      <P>Future F#.NET Journal articles will revisit the subject of network 
      programming using Silverlight and F#.</P></TD></TR></TBODY></TABLE>
<TABLE id=footer>
  <TBODY>
  <TR>
    <TD>© Flying Frog Consultancy Ltd., 2010</TD>
    <TD>Contact the <A href="mailto:webmaster@ffconsultancy.com">webmaster</A> 
    </TD></TR></TBODY></TABLE>
<SCRIPT type=text/javascript 
src="F%23%20Journal%20using%20sockets%20from%20silverlight_files/urchin.js">
    <script type="text/javascript">_uacct = "UA-197840-1"; urchinTracker();</SCRIPT>
</BODY></HTML>
