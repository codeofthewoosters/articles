<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0090)http://www.ffconsultancy.com/products/fsharp_journal/subscribers/symbolicminimization.html -->
<HTML><HEAD><META content="IE=7.0000" http-equiv="X-UA-Compatible">
<TITLE>F# Journal</TITLE>
<META content="text/html; charset=windows-1252" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="F%23%20Journal%20symbolig%20differentiation%20and%20matrix%20inversion_files/style.css"><LINK 
rel=stylesheet type=text/css 
href="F%23%20Journal%20symbolig%20differentiation%20and%20matrix%20inversion_files/style(1).css"><LINK 
rel=stylesheet type=text/css 
href="F%23%20Journal%20symbolig%20differentiation%20and%20matrix%20inversion_files/individual.css">
<META name=GENERATOR content="MSHTML 10.00.9200.16458"></HEAD>
<BODY>
<TABLE id=logo>
  <TBODY>
  <TR>
    <TD width="100%"><IMG 
      src="F%23%20Journal%20symbolig%20differentiation%20and%20matrix%20inversion_files/title.gif"> 
    </TD>
    <TD><IMG 
      src="F%23%20Journal%20symbolig%20differentiation%20and%20matrix%20inversion_files/left.gif"> 
    </TD></TR></TBODY></TABLE>
<TABLE id=menu>
  <TBODY>
  <TR>
    <TD width="25%">
    <TD width="25%"><A 
      href="http://www.ffconsultancy.com/products/index.html">Home Page</A> </TD>
    <TD width="25%"><A 
      href="http://www.ffconsultancy.com/products/fsharp_journal/subscribers/index.html">The 
      F# Journal</A> </TD>
    <TD width="25%"></TD></TR></TBODY></TABLE>
<TABLE id=page>
  <TBODY>
  <TR>
    <TD>
      <H1>Symbolic differentiation and matrix inversion</H1>
      <P>Previous F#.NET Journal articles have covered manipulating symbolic 
      expressions, computing derivatives and inverting matrices. This article 
      combines these concepts in order to build a small computer algebra system 
      capable of symbolically computing and simplifying the inverse of the 
      Hessian matrix and grad of a given expression. This foundation is then 
      used to minimize a symbolic expression to arbitrary-precision using 
      rational arithmetic.</P>
      <H2>Expressions</H2>
      <P>We begin by referencing the F# PowerPack for its <CODE>vector</CODE> 
      and <CODE>matrix</CODE> types:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;#r&nbsp;"FSharp.PowerPack.dll";;</CODE></P>
      <P>In order to simplify symbolic expressions we wish to be able to pattern 
      matching against a few literal rational numbers such as <CODE>0N</CODE> 
      and <CODE>1N</CODE> but this is not permitted by the F# language so we 
      define active patterns that achieve the same effect:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;(|MinusOne|_|)&nbsp;n&nbsp;=&nbsp;if&nbsp;n&nbsp;=&nbsp;-1N&nbsp;then&nbsp;Some&nbsp;MinusOne&nbsp;else&nbsp;None;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;(&nbsp;|MinusOne|_|&nbsp;)&nbsp;:&nbsp;BigRational&nbsp;-&gt;&nbsp;unit&nbsp;option<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;(|Zero|_|)&nbsp;n&nbsp;=&nbsp;if&nbsp;n&nbsp;=&nbsp;0N&nbsp;then&nbsp;Some&nbsp;Zero&nbsp;else&nbsp;None;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;(&nbsp;|Zero|_|&nbsp;)&nbsp;:&nbsp;BigRational&nbsp;-&gt;&nbsp;unit&nbsp;option<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;(|One|_|)&nbsp;n&nbsp;=&nbsp;if&nbsp;n&nbsp;=&nbsp;1N&nbsp;then&nbsp;Some&nbsp;One&nbsp;else&nbsp;None;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;(&nbsp;|One|_|&nbsp;)&nbsp;:&nbsp;BigRational&nbsp;-&gt;&nbsp;unit&nbsp;option</CODE></P>
      <P>Now we can define an <CODE>expr</CODE> type capable of representing the 
      usual numbers, variables, sums and products but we also support 
      exponentiation and logarithms:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;type&nbsp;expr&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Num&nbsp;of&nbsp;BigRational<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Var&nbsp;of&nbsp;string<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Add&nbsp;of&nbsp;expr&nbsp;*&nbsp;expr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Mul&nbsp;of&nbsp;expr&nbsp;*&nbsp;expr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Power&nbsp;of&nbsp;expr&nbsp;*&nbsp;expr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Log&nbsp;of&nbsp;expr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;member&nbsp;Zero&nbsp;=&nbsp;Num&nbsp;0N<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;member&nbsp;One&nbsp;=&nbsp;Num&nbsp;1N<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;member&nbsp;(&nbsp;~-&nbsp;)&nbsp;f&nbsp;=&nbsp;Num&nbsp;-1N&nbsp;*&nbsp;f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;member&nbsp;(&nbsp;+&nbsp;)&nbsp;(f,&nbsp;g)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;f,&nbsp;g&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Num&nbsp;m,&nbsp;Num&nbsp;n&nbsp;-&gt;&nbsp;Num(m&nbsp;+&nbsp;n)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Num&nbsp;Zero,&nbsp;f&nbsp;|&nbsp;f,&nbsp;Num&nbsp;Zero&nbsp;-&gt;&nbsp;f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;f,&nbsp;Add(g,&nbsp;h)&nbsp;-&gt;&nbsp;f&nbsp;+&nbsp;g&nbsp;+&nbsp;h<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Add(f,&nbsp;g)&nbsp;as&nbsp;e,&nbsp;h&nbsp;-&gt;&nbsp;if&nbsp;g&nbsp;&gt;&nbsp;h&nbsp;then&nbsp;f&nbsp;+&nbsp;h&nbsp;+&nbsp;g&nbsp;else&nbsp;Add(e,&nbsp;h)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;f,&nbsp;g&nbsp;when&nbsp;f&nbsp;&gt;&nbsp;g&nbsp;-&gt;&nbsp;g&nbsp;+&nbsp;f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;f,&nbsp;g&nbsp;-&gt;&nbsp;Add(f,&nbsp;g)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;member&nbsp;(&nbsp;-&nbsp;)&nbsp;(f:&nbsp;expr,&nbsp;g)&nbsp;=&nbsp;f&nbsp;+&nbsp;-g<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;member&nbsp;(&nbsp;*&nbsp;)&nbsp;(f,&nbsp;g)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;f,&nbsp;g&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Num&nbsp;m,&nbsp;Num&nbsp;n&nbsp;-&gt;&nbsp;Num(m&nbsp;*&nbsp;n)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Num&nbsp;m,&nbsp;Mul(Num&nbsp;n,&nbsp;f)&nbsp;-&gt;&nbsp;Num(m&nbsp;*&nbsp;n)&nbsp;*&nbsp;f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Num&nbsp;Zero,&nbsp;f&nbsp;|&nbsp;f,&nbsp;Num&nbsp;Zero&nbsp;-&gt;&nbsp;Num&nbsp;0N<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Num&nbsp;One,&nbsp;f&nbsp;|&nbsp;f,&nbsp;Num&nbsp;One&nbsp;-&gt;&nbsp;f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;f,&nbsp;Mul(g,&nbsp;h)&nbsp;-&gt;&nbsp;f&nbsp;*&nbsp;g&nbsp;*&nbsp;h<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Mul(f,&nbsp;g)&nbsp;as&nbsp;e,&nbsp;h&nbsp;-&gt;&nbsp;if&nbsp;g&nbsp;&gt;&nbsp;h&nbsp;then&nbsp;f&nbsp;*&nbsp;h&nbsp;*&nbsp;g&nbsp;else&nbsp;Mul(e,&nbsp;h)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;f,&nbsp;g&nbsp;when&nbsp;f&nbsp;&gt;&nbsp;g&nbsp;-&gt;&nbsp;g&nbsp;*&nbsp;f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;f,&nbsp;g&nbsp;-&gt;&nbsp;Mul(f,&nbsp;g)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;member&nbsp;(&nbsp;/&nbsp;)&nbsp;(f:&nbsp;expr,&nbsp;g:&nbsp;expr)&nbsp;=&nbsp;f&nbsp;*&nbsp;g&nbsp;**&nbsp;Num&nbsp;-1N<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;member&nbsp;Pow&nbsp;(f,&nbsp;g)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;f,&nbsp;g&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;_,&nbsp;Num&nbsp;Zero&nbsp;-&gt;&nbsp;Num&nbsp;1N<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Num&nbsp;p,&nbsp;Num&nbsp;MinusOne&nbsp;-&gt;&nbsp;Num(1N&nbsp;/&nbsp;p)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Num&nbsp;p,&nbsp;Num&nbsp;q&nbsp;when&nbsp;q.Denominator&nbsp;=&nbsp;1I&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;q&nbsp;&lt;&nbsp;0N&nbsp;then&nbsp;Num(1N&nbsp;/&nbsp;p)&nbsp;**&nbsp;Num&nbsp;-q&nbsp;else&nbsp;Num&nbsp;p&nbsp;*&nbsp;Num&nbsp;p&nbsp;**&nbsp;Num(q&nbsp;-&nbsp;1N)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;f,&nbsp;Num&nbsp;One&nbsp;-&gt;&nbsp;f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;f,&nbsp;g&nbsp;-&gt;&nbsp;Power(f,&nbsp;g)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;member&nbsp;Sqrt&nbsp;(f:&nbsp;expr)&nbsp;=&nbsp;f&nbsp;**&nbsp;Num(1N&nbsp;/&nbsp;2N)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface&nbsp;INumeric&lt;expr&gt;&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;x.Abs&nbsp;a&nbsp;=&nbsp;a<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;x.Add(f,&nbsp;g)&nbsp;=&nbsp;f&nbsp;+&nbsp;g<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;x.Multiply(f,&nbsp;g)&nbsp;=&nbsp;f&nbsp;*&nbsp;g<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;x.Negate&nbsp;f&nbsp;=&nbsp;-f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;x.Subtract(f,&nbsp;g)&nbsp;=&nbsp;f&nbsp;-&nbsp;g<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;x.Parse(_,&nbsp;_,&nbsp;_)&nbsp;=&nbsp;failwith&nbsp;"Parse&nbsp;not&nbsp;supported"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;x.Sign&nbsp;_&nbsp;=&nbsp;failwith&nbsp;"Sign&nbsp;not&nbsp;supported"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;x.ToString&nbsp;(n,&nbsp;_,&nbsp;_)&nbsp;=&nbsp;(box&nbsp;n).ToString()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;x.One&nbsp;=&nbsp;Num&nbsp;1N<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;x.Zero&nbsp;=&nbsp;Num&nbsp;0N<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;x.Compare(_,&nbsp;_)&nbsp;=&nbsp;failwith&nbsp;"Compare&nbsp;not&nbsp;supported"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;x.Equals(_,&nbsp;_)&nbsp;=&nbsp;failwith&nbsp;"Compare&nbsp;not&nbsp;supported";;<BR>&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;expr&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Num&nbsp;of&nbsp;BigRational<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Var&nbsp;of&nbsp;string<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Add&nbsp;of&nbsp;expr&nbsp;*&nbsp;expr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Mul&nbsp;of&nbsp;expr&nbsp;*&nbsp;expr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Power&nbsp;of&nbsp;expr&nbsp;*&nbsp;expr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Log&nbsp;of&nbsp;expr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface&nbsp;INumeric&lt;expr&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;member&nbsp;Pow&nbsp;:&nbsp;f:expr&nbsp;*&nbsp;g:expr&nbsp;-&gt;&nbsp;expr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;member&nbsp;Sqrt&nbsp;:&nbsp;f:expr&nbsp;-&gt;&nbsp;expr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;member&nbsp;One&nbsp;:&nbsp;expr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;member&nbsp;Zero&nbsp;:&nbsp;expr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;member&nbsp;(&nbsp;+&nbsp;)&nbsp;:&nbsp;f:expr&nbsp;*&nbsp;g:expr&nbsp;-&gt;&nbsp;expr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;member&nbsp;(&nbsp;/&nbsp;)&nbsp;:&nbsp;f:expr&nbsp;*&nbsp;g:expr&nbsp;-&gt;&nbsp;expr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;member&nbsp;(&nbsp;*&nbsp;)&nbsp;:&nbsp;f:expr&nbsp;*&nbsp;g:expr&nbsp;-&gt;&nbsp;expr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;member&nbsp;(&nbsp;-&nbsp;)&nbsp;:&nbsp;f:expr&nbsp;*&nbsp;g:expr&nbsp;-&gt;&nbsp;expr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;member&nbsp;(&nbsp;~-&nbsp;)&nbsp;:&nbsp;f:expr&nbsp;-&gt;&nbsp;expr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</CODE></P>
      <P>This definition of the <CODE>expr</CODE> type includes operator 
      overloads that simplify expressions as they are constructed and implements 
      the <CODE>INumeric</CODE> interface in order to allow vectors and matrices 
      of symbolic expressions to be manipulated.</P>
      <P>For example, attempting to construct a symbolic expression that sums 
      two numbers and a variable <CODE>x</CODE> results in the two numbers being 
      added in order to simplify the expression:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;Num&nbsp;2N&nbsp;+&nbsp;Num&nbsp;3N&nbsp;+&nbsp;Var&nbsp;"x";;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;expr&nbsp;=&nbsp;Add&nbsp;(Add&nbsp;(Num&nbsp;5N,Var&nbsp;"x"),Var&nbsp;"y")</CODE></P>
      <P>Note how the simplifying rewrite rules in the operator overloads cause 
      terms in a sum to be sorted and numbers to be combined, leaving 
      <CODE>5+x+y</CODE> in this case.</P>
      <H2>Symbolic differentiation</H2>
      <P>We can write a function to compute the symbolic derivative of any value 
      of the type <CODE>expr</CODE> as follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;d&nbsp;x&nbsp;=&nbsp;function<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Var&nbsp;y&nbsp;when&nbsp;x=y&nbsp;-&gt;&nbsp;Num&nbsp;1N<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Num&nbsp;_&nbsp;|&nbsp;Var&nbsp;_&nbsp;-&gt;&nbsp;Num&nbsp;0N<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Add(f,&nbsp;g)&nbsp;-&gt;&nbsp;d&nbsp;x&nbsp;f&nbsp;+&nbsp;d&nbsp;x&nbsp;g<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Mul(f,&nbsp;g)&nbsp;-&gt;&nbsp;f&nbsp;*&nbsp;d&nbsp;x&nbsp;g&nbsp;+&nbsp;g&nbsp;*&nbsp;d&nbsp;x&nbsp;f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Power(f,&nbsp;(Num&nbsp;_&nbsp;as&nbsp;n))&nbsp;-&gt;&nbsp;n&nbsp;*&nbsp;d&nbsp;x&nbsp;f&nbsp;*&nbsp;f&nbsp;**&nbsp;(n&nbsp;-&nbsp;Num&nbsp;1N)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Power(f,&nbsp;g)&nbsp;-&gt;&nbsp;f&nbsp;**&nbsp;(g&nbsp;-&nbsp;Num&nbsp;1N)&nbsp;*&nbsp;(g&nbsp;*&nbsp;d&nbsp;x&nbsp;f&nbsp;+&nbsp;f&nbsp;*&nbsp;Log&nbsp;f&nbsp;*&nbsp;d&nbsp;x&nbsp;g)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Log&nbsp;f&nbsp;-&gt;&nbsp;f&nbsp;**&nbsp;Num&nbsp;-1N;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;d&nbsp;:&nbsp;string&nbsp;-&gt;&nbsp;expr&nbsp;-&gt;&nbsp;expr</CODE></P>
      <P>Note how the symbolic derivative of expressions of the form 
      <CODE>f^g</CODE> requires logarithm. This is why <CODE>Log</CODE> is part 
      of the definition of the <CODE>expr</CODE> type.</P>
      <P>For example, the derivative of the expression <CODE>x^x</CODE> with 
      respect to <CODE>x</CODE> is:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;d&nbsp;"x"&nbsp;(Var&nbsp;"x"&nbsp;**&nbsp;Var&nbsp;"x");;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;expr&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mul<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Add&nbsp;(Var&nbsp;"x",Mul&nbsp;(Var&nbsp;"x",Log&nbsp;(Var&nbsp;"x"))),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Power&nbsp;(Var&nbsp;"x",Add&nbsp;(Num&nbsp;-1N,Var&nbsp;"x")))</CODE></P>
      <P>This function will be used to compute the symbolic grad and hessian of 
      expressions.</P>
      <H2>Pretty printing</H2>
      <P>Symbolic expressions may be pretty printed using the following 
      <CODE>toString</CODE> function:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;toString&nbsp;()&nbsp;f&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;prod()&nbsp;=&nbsp;function<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Add&nbsp;_&nbsp;as&nbsp;f&nbsp;-&gt;&nbsp;sprintf&nbsp;"(%a)"&nbsp;toString&nbsp;f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;f&nbsp;-&gt;&nbsp;sprintf&nbsp;"%a"&nbsp;toString&nbsp;f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;pow()&nbsp;=&nbsp;function<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Add&nbsp;_&nbsp;|&nbsp;Mul&nbsp;_&nbsp;as&nbsp;f&nbsp;-&gt;&nbsp;sprintf&nbsp;"(%a)"&nbsp;toString&nbsp;f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;f&nbsp;-&gt;&nbsp;sprintf&nbsp;"%a"&nbsp;toString&nbsp;f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;func()&nbsp;=&nbsp;function<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Add&nbsp;_&nbsp;|&nbsp;Mul&nbsp;_&nbsp;|&nbsp;Power&nbsp;_&nbsp;as&nbsp;f&nbsp;-&gt;&nbsp;sprintf&nbsp;"(%a)"&nbsp;toString&nbsp;f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;f&nbsp;-&gt;&nbsp;sprintf&nbsp;"%a"&nbsp;toString&nbsp;f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;f&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Num&nbsp;n&nbsp;-&gt;&nbsp;sprintf&nbsp;"%A"&nbsp;n<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Var&nbsp;s&nbsp;-&gt;&nbsp;s<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Add(f,&nbsp;Mul(Num&nbsp;MinusOne,&nbsp;g))&nbsp;-&gt;&nbsp;sprintf&nbsp;"%a&nbsp;-&nbsp;%a"&nbsp;toString&nbsp;f&nbsp;toString&nbsp;g<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Add(f,&nbsp;g)&nbsp;-&gt;&nbsp;sprintf&nbsp;"%a&nbsp;+&nbsp;%a"&nbsp;toString&nbsp;f&nbsp;toString&nbsp;g<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Mul(f,&nbsp;Power(g,&nbsp;Num&nbsp;MinusOne))&nbsp;-&gt;&nbsp;sprintf&nbsp;"%a&nbsp;/&nbsp;%a"&nbsp;prod&nbsp;f&nbsp;prod&nbsp;g<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Mul(f,&nbsp;g)&nbsp;-&gt;&nbsp;sprintf&nbsp;"%a&nbsp;%a"&nbsp;prod&nbsp;f&nbsp;prod&nbsp;g<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Power(f,&nbsp;g)&nbsp;-&gt;&nbsp;sprintf&nbsp;"%a^%a"&nbsp;pow&nbsp;f&nbsp;pow&nbsp;g<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Log&nbsp;f&nbsp;-&gt;&nbsp;sprintf&nbsp;"log&nbsp;%a"&nbsp;func&nbsp;f;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;toString&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;expr&nbsp;-&gt;&nbsp;string</CODE></P>
      <P>We can make F# Interactive use this <CODE>toString</CODE> function to 
      pretty print symbolic expressions by registering it using the 
      <CODE>AddPrinter</CODE> member of the <CODE>fsi</CODE> object:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;fsi.AddPrinter(toString());;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;unit&nbsp;=&nbsp;()</CODE></P>
      <P>For example, the derivative used in the previous example is now pretty 
      printed as follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;d&nbsp;"x"&nbsp;(Var&nbsp;"x"&nbsp;**&nbsp;Var&nbsp;"x");;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;expr&nbsp;=&nbsp;(x&nbsp;+&nbsp;x&nbsp;log&nbsp;x)&nbsp;x^(-1N&nbsp;+&nbsp;x)</CODE></P>
      <P>This makes it easier to inspect the results of our functions.</P>
      <H2>Grad and Hessian of the Rosenbrock banana function</H2>
      <P>The Rosenbrock banana function is:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rosenbrock&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;sqr&nbsp;x&nbsp;:&nbsp;expr&nbsp;=&nbsp;x&nbsp;**&nbsp;Num&nbsp;2N<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x,&nbsp;y&nbsp;=&nbsp;Var&nbsp;"x",&nbsp;Var&nbsp;"y"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqr(Num&nbsp;1N&nbsp;-&nbsp;x)&nbsp;+&nbsp;Num&nbsp;100N&nbsp;*&nbsp;sqr(y&nbsp;-&nbsp;sqr&nbsp;x);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;rosenbrock&nbsp;:&nbsp;expr&nbsp;=&nbsp;(1N&nbsp;-&nbsp;x)^2N&nbsp;+&nbsp;100N&nbsp;(y&nbsp;-&nbsp;x^2N)^2N</CODE></P>
      <P>Rather than using the built-in <CODE>vector</CODE> and 
      <CODE>matrix</CODE> functions that construct vectors and matrices from 
      floating-point numbers, we shall alias the generic versions:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;vector&nbsp;=&nbsp;Vector.Generic.ofSeq;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;vector&nbsp;:&nbsp;(seq&lt;'a&gt;&nbsp;-&gt;&nbsp;Vector&lt;'a&gt;)<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;matrix&nbsp;=&nbsp;Matrix.Generic.ofSeq;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;matrix&nbsp;:&nbsp;(seq&lt;#seq&lt;'b&gt;&gt;&nbsp;-&gt;&nbsp;Matrix&lt;'b&gt;)</CODE></P>
      <H3>Computing the Grad</H3>
      <P>A function to compute the symbolic grad of an expression <CODE>f</CODE> 
      with respect to each of the variables <CODE>xs</CODE> may then be 
      written:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;grad&nbsp;xs&nbsp;f&nbsp;=&nbsp;vector[for&nbsp;x&nbsp;in&nbsp;xs&nbsp;-&gt;&nbsp;d&nbsp;x&nbsp;f];;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;grad&nbsp;:&nbsp;seq&lt;string&gt;&nbsp;-&gt;&nbsp;expr&nbsp;-&gt;&nbsp;Vector&lt;expr&gt;</CODE></P>
      <P>For example, given the variables used in our example Rosenbrock banana 
      function:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;xs&nbsp;=&nbsp;["x";&nbsp;"y"];;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;xs&nbsp;:&nbsp;string&nbsp;list&nbsp;=&nbsp;["x";&nbsp;"y"]</CODE></P>
      <P>we can compute its grad as follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;grad&nbsp;xs&nbsp;rosenbrock;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;Vector&lt;expr&gt;&nbsp;=</CODE></P>
      <P>vector [|-2N (1N - x) + -400N x (y - x^2N); 200N (y - x^2N)|]</P>
      <P>This is a vector containing the derivative of the expression with 
      respect to <CODE>x</CODE> and then with respect to <CODE>y</CODE>.</P>
      <H2>Computing the Hessian</H2>
      <P>The Hessian matrix of second derivatives is only slightly more 
      complicated to compute:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;hessian&nbsp;xs&nbsp;f&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xs&nbsp;|&gt;&nbsp;Seq.map&nbsp;(fun&nbsp;x&nbsp;-&gt;&nbsp;xs&nbsp;|&gt;&nbsp;Seq.map&nbsp;(fun&nbsp;y&nbsp;-&gt;&nbsp;d&nbsp;x&nbsp;f&nbsp;|&gt;&nbsp;d&nbsp;y))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;matrix;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;hessian&nbsp;:&nbsp;seq&lt;string&gt;&nbsp;-&gt;&nbsp;expr&nbsp;-&gt;&nbsp;Matrix&lt;expr&gt;</CODE></P>
      <P>This <CODE>hessian</CODE> function uses two nested applications of 
      <CODE>Seq.map</CODE> to create a sequence of sequences of the expression 
      <CODE>f</CODE> differentiated first with respect to <CODE>x</CODE> and 
      then with respect to <CODE>y</CODE> before the <CODE>matrix</CODE> 
      function is used to convert the result into a standard F# matrix.</P>
      <P>For example, the Hessian of the Rosenbrock banana function is:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;hessian&nbsp;xs&nbsp;rosenbrock;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;Matrix&lt;expr&gt;&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix&nbsp;[[2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N);&nbsp;-400N&nbsp;x]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-400N&nbsp;x;&nbsp;200N]]</CODE></P>
      <H2>Inverting the Hessian matrix</H2>
      <P>We can now implement functions to invert matrices of symbolic 
      expressions. We begin by defining active patterns that can be used to 
      recursively decompose matrices:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;(|Scalar|Blocks|)&nbsp;(a:&nbsp;Matrix&lt;_&gt;)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;m,&nbsp;n&nbsp;=&nbsp;a.Dimensions<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;m=1&nbsp;&amp;&amp;&nbsp;n=1&nbsp;then&nbsp;Scalar&nbsp;a.[0,0]&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Blocks(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Matrix.Generic.init&nbsp;(m/2)&nbsp;(n/2)&nbsp;(fun&nbsp;i&nbsp;j&nbsp;-&gt;&nbsp;a.[i,&nbsp;j]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matrix.Generic.init&nbsp;(m/2)&nbsp;(n&nbsp;-&nbsp;n/2)&nbsp;(fun&nbsp;i&nbsp;j&nbsp;-&gt;&nbsp;a.[i,&nbsp;j&nbsp;+&nbsp;n/2])),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Matrix.Generic.init&nbsp;(m&nbsp;-&nbsp;m/2)&nbsp;(n/2)&nbsp;(fun&nbsp;i&nbsp;j&nbsp;-&gt;&nbsp;a.[i&nbsp;+&nbsp;m/2,&nbsp;j]),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matrix.Generic.init&nbsp;(m&nbsp;-&nbsp;m/2)&nbsp;(n&nbsp;-&nbsp;n/2)&nbsp;(fun&nbsp;i&nbsp;j&nbsp;-&gt;&nbsp;a.[i&nbsp;+&nbsp;m/2,&nbsp;j&nbsp;+&nbsp;n/2])));;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;(&nbsp;|Scalar|Blocks|&nbsp;)&nbsp;:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matrix&lt;'a&gt;&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choice&lt;'a,((Matrix&lt;'a&gt;&nbsp;*&nbsp;Matrix&lt;'a&gt;)&nbsp;*&nbsp;(Matrix&lt;'a&gt;&nbsp;*&nbsp;Matrix&lt;'a&gt;))&gt;</CODE></P>
      <P>Conversely, we will require functions that compose matrices from a 
      single scalar and from smaller submatrices:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;Scalar&nbsp;x&nbsp;=&nbsp;Matrix.Generic.create&nbsp;1&nbsp;1&nbsp;x;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;Scalar&nbsp;:&nbsp;'a&nbsp;-&gt;&nbsp;Matrix&lt;'a&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;Blocks((a:&nbsp;Matrix&lt;_&gt;,&nbsp;b:&nbsp;Matrix&lt;_&gt;),&nbsp;(c:&nbsp;Matrix&lt;_&gt;,&nbsp;d:&nbsp;Matrix&lt;_&gt;))&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;m0,&nbsp;n0&nbsp;=&nbsp;a.Dimensions<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;m1,&nbsp;n1&nbsp;=&nbsp;d.Dimensions<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matrix.Generic.init&nbsp;(m0&nbsp;+&nbsp;m1)&nbsp;(n0&nbsp;+&nbsp;n1)&nbsp;(fun&nbsp;i&nbsp;j&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;i&nbsp;&lt;&nbsp;m0,&nbsp;j&nbsp;&lt;&nbsp;n0&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;true,&nbsp;true&nbsp;-&gt;&nbsp;a.[i,&nbsp;j]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;true,&nbsp;false&nbsp;-&gt;&nbsp;b.[i,&nbsp;j&nbsp;-&nbsp;n0]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;false,&nbsp;true&nbsp;-&gt;&nbsp;c.[i&nbsp;-&nbsp;m0,&nbsp;j]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;false,&nbsp;false&nbsp;-&gt;&nbsp;d.[i&nbsp;-&nbsp;m0,&nbsp;j&nbsp;-&nbsp;n0]);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;Blocks&nbsp;:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Matrix&lt;'a&gt;&nbsp;*&nbsp;Matrix&lt;'a&gt;)&nbsp;*&nbsp;(Matrix&lt;'a&gt;&nbsp;*&nbsp;Matrix&lt;'a&gt;)&nbsp;-&gt;&nbsp;Matrix&lt;'a&gt;</CODE></P>
      <P>A function to invert a symbolic matrix may then be written:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;invert&nbsp;(i:&nbsp;'a&nbsp;-&gt;&nbsp;'a)&nbsp;=&nbsp;function<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Scalar&nbsp;x&nbsp;-&gt;&nbsp;Scalar(i&nbsp;x)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Blocks((A,&nbsp;B),&nbsp;(C,&nbsp;D))&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;iA&nbsp;=&nbsp;invert&nbsp;i&nbsp;A<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;iAB&nbsp;=&nbsp;iA&nbsp;*&nbsp;B<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;E&nbsp;=&nbsp;invert&nbsp;i&nbsp;&lt;|&nbsp;D&nbsp;-&nbsp;C&nbsp;*&nbsp;iAB<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;SCiA&nbsp;=&nbsp;E&nbsp;*&nbsp;C&nbsp;*&nbsp;iA<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Blocks((iA&nbsp;+&nbsp;iAB&nbsp;*&nbsp;SCiA,&nbsp;-&nbsp;iAB&nbsp;*&nbsp;E),&nbsp;(-SCiA,&nbsp;E));;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;invert&nbsp;:&nbsp;('a&nbsp;-&gt;&nbsp;'a)&nbsp;-&gt;&nbsp;Matrix&lt;'a&gt;&nbsp;-&gt;&nbsp;Matrix&lt;'a&gt;</CODE></P>
      <P>Before we can use vectors and matrices with our <CODE>expr</CODE> type 
      we must register a value of the type for numeric association:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;Math.GlobalAssociations.RegisterNumericAssociation(Num&nbsp;0N);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;unit&nbsp;=&nbsp;()</CODE></P>
      <P>This is the technique F# uses to implement operator overloading.</P>
      <H2>Rewrite rules</H2>
      <P>We are now in a position to write some functions to manipulate symbolic 
      expressions that will be of use later. We begin by defining a higher-order 
      <CODE>recurse</CODE> function that applies the given <CODE>rule</CODE> 
      function to the subexpressions of the given expression:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;recurse&nbsp;rule&nbsp;=&nbsp;function<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Num&nbsp;_&nbsp;|&nbsp;Var&nbsp;_&nbsp;as&nbsp;f&nbsp;-&gt;&nbsp;f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Add(f,&nbsp;g)&nbsp;-&gt;&nbsp;rule&nbsp;f&nbsp;+&nbsp;rule&nbsp;g<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Mul(f,&nbsp;g)&nbsp;-&gt;&nbsp;rule&nbsp;f&nbsp;*&nbsp;rule&nbsp;g<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Power(f,&nbsp;g)&nbsp;-&gt;&nbsp;rule&nbsp;f&nbsp;**&nbsp;rule&nbsp;g<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Log&nbsp;f&nbsp;-&gt;&nbsp;Log(rule&nbsp;f);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;recurse&nbsp;:&nbsp;(expr&nbsp;-&gt;&nbsp;expr)&nbsp;-&gt;&nbsp;expr&nbsp;-&gt;&nbsp;expr</CODE></P>
      <P>Next, we define a <CODE>rewrite</CODE> function that uses the 
      <CODE>recurse</CODE> function to apply itself to the subexpressions of a 
      given expression before applying the given <CODE>rule</CODE> to the 
      result, iterating to fixed point:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;rewrite&nbsp;rule&nbsp;f&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;g&nbsp;=&nbsp;recurse&nbsp;(rewrite&nbsp;rule)&nbsp;f&nbsp;|&gt;&nbsp;rule<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;f=g&nbsp;then&nbsp;f&nbsp;else&nbsp;rewrite&nbsp;rule&nbsp;g;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;rewrite&nbsp;:&nbsp;(expr&nbsp;-&gt;&nbsp;expr)&nbsp;-&gt;&nbsp;expr&nbsp;-&gt;&nbsp;expr</CODE></P>
      <P>One useful rewrite rule that can be used in conjunction with the 
      <CODE>rewrite</CODE> function is the following <CODE>expand</CODE> 
      function that multiplies out brackets (sums inside products):</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;expand&nbsp;=&nbsp;function<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Mul(Add(f,&nbsp;g),&nbsp;h)&nbsp;-&gt;&nbsp;f*h&nbsp;+&nbsp;g*h<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Mul(f,&nbsp;Add(g,&nbsp;h))&nbsp;-&gt;&nbsp;f*g&nbsp;+&nbsp;f*h<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;f&nbsp;-&gt;&nbsp;f;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;expand&nbsp;:&nbsp;(expr&nbsp;-&gt;&nbsp;expr)</CODE></P>
      <P>For example, the expression 
      <CODE>(x&nbsp;+&nbsp;y)&nbsp;(x&nbsp;+&nbsp;2y)</CODE> is expanded to 
      <CODE>x^2&nbsp;+&nbsp;2xy&nbsp;+&nbsp;yx&nbsp;+&nbsp;2y^2</CODE>:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;x,&nbsp;y&nbsp;=&nbsp;Var&nbsp;"x",&nbsp;Var&nbsp;"y"&nbsp;in<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;expand&nbsp;((x&nbsp;+&nbsp;y)&nbsp;*&nbsp;(x&nbsp;+&nbsp;Num&nbsp;2N&nbsp;*&nbsp;y));;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;expr&nbsp;=&nbsp;x^2N&nbsp;+&nbsp;x&nbsp;2N&nbsp;y&nbsp;+&nbsp;y&nbsp;x&nbsp;+&nbsp;y&nbsp;2N&nbsp;y</CODE></P>
      <P>The symbolic inverse of the Hessian matrix for our example Rosenbrock 
      function is then given by:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;inverseHessian&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hessian&nbsp;xs&nbsp;rosenbrock<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;invert&nbsp;(fun&nbsp;x&nbsp;-&gt;&nbsp;Num&nbsp;1N&nbsp;/&nbsp;x);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;Matrix&lt;expr&gt;&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix&nbsp;[[(2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N))^-1N&nbsp;+&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N))^-1N&nbsp;-400N&nbsp;x&nbsp;(200N&nbsp;-&nbsp;-400N&nbsp;x&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N))^-1N&nbsp;-400N&nbsp;x)^-1N&nbsp;-400N&nbsp;x&nbsp;/&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1N&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N))^-1N&nbsp;-400N&nbsp;x&nbsp;/&nbsp;(200N&nbsp;-&nbsp;-400N&nbsp;x&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N))^-1N&nbsp;-400N&nbsp;x)]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1N&nbsp;(200N&nbsp;-&nbsp;-400N&nbsp;x&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N))^-1N&nbsp;-400N&nbsp;x)^-1N&nbsp;-400N&nbsp;x&nbsp;/&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(200N&nbsp;-&nbsp;-400N&nbsp;x&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N))^-1N&nbsp;-400N&nbsp;x)^-1N]]</CODE></P>
      <P>The result may be expanded out as follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;inverseHessian&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hessian&nbsp;xs&nbsp;rosenbrock<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;invert&nbsp;(fun&nbsp;x&nbsp;-&gt;&nbsp;Num&nbsp;1N&nbsp;/&nbsp;x)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Matrix.Generic.map&nbsp;(rewrite&nbsp;expand);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;Matrix&lt;expr&gt;&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix&nbsp;[[(2N&nbsp;+&nbsp;100N&nbsp;-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;100N&nbsp;y&nbsp;-4N&nbsp;+&nbsp;100N&nbsp;-1N&nbsp;x^2N&nbsp;-4N)^-1N&nbsp;+&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;100N&nbsp;y&nbsp;-4N&nbsp;+&nbsp;100N&nbsp;-1N&nbsp;x^2N&nbsp;-4N)^-1N&nbsp;-400N&nbsp;x&nbsp;(200N&nbsp;-&nbsp;-400N&nbsp;x&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;100N&nbsp;y&nbsp;-4N&nbsp;+&nbsp;100N&nbsp;-1N&nbsp;x^2N&nbsp;-4N)^-1N&nbsp;-400N&nbsp;x)^-1N&nbsp;-400N&nbsp;x&nbsp;/&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;100N&nbsp;y&nbsp;-4N&nbsp;+&nbsp;100N&nbsp;-1N&nbsp;x^2N&nbsp;-4N);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1N&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;100N&nbsp;y&nbsp;-4N&nbsp;+&nbsp;100N&nbsp;-1N&nbsp;x^2N&nbsp;-4N)^-1N&nbsp;-400N&nbsp;x&nbsp;/&nbsp;(200N&nbsp;-&nbsp;-400N&nbsp;x&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;100N&nbsp;y&nbsp;-4N&nbsp;+&nbsp;100N&nbsp;-1N&nbsp;x^2N&nbsp;-4N)^-1N&nbsp;-400N&nbsp;x)]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-1N&nbsp;(200N&nbsp;-&nbsp;-400N&nbsp;x&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;100N&nbsp;y&nbsp;-4N&nbsp;+&nbsp;100N&nbsp;-1N&nbsp;x^2N&nbsp;-4N)^-1N&nbsp;-400N&nbsp;x)^-1N&nbsp;-400N&nbsp;x&nbsp;/&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;100N&nbsp;y&nbsp;-4N&nbsp;+&nbsp;100N&nbsp;-1N&nbsp;x^2N&nbsp;-4N);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(200N&nbsp;-&nbsp;-400N&nbsp;x&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;100N&nbsp;y&nbsp;-4N&nbsp;+&nbsp;100N&nbsp;-1N&nbsp;x^2N&nbsp;-4N)^-1N&nbsp;-400N&nbsp;x)^-1N]]</CODE></P>
      <P>We can also define a rule that substitutes variables with values:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;subst&nbsp;rule&nbsp;=&nbsp;function<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Var&nbsp;x&nbsp;-&gt;&nbsp;rule&nbsp;x<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Num&nbsp;_&nbsp;as&nbsp;f&nbsp;-&gt;&nbsp;f<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Add(f,&nbsp;g)&nbsp;-&gt;&nbsp;subst&nbsp;rule&nbsp;f&nbsp;+&nbsp;subst&nbsp;rule&nbsp;g<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Mul(f,&nbsp;g)&nbsp;-&gt;&nbsp;subst&nbsp;rule&nbsp;f&nbsp;*&nbsp;subst&nbsp;rule&nbsp;g<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Power(f,&nbsp;g)&nbsp;-&gt;&nbsp;subst&nbsp;rule&nbsp;f&nbsp;**&nbsp;subst&nbsp;rule&nbsp;g<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Log&nbsp;f&nbsp;-&gt;&nbsp;Log(subst&nbsp;rule&nbsp;f);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;subst&nbsp;:&nbsp;(string&nbsp;-&gt;&nbsp;expr)&nbsp;-&gt;&nbsp;expr&nbsp;-&gt;&nbsp;expr</CODE></P>
      <P>For example, an iteration of the Newton method for minimizing a 
      function subtracts the inverse of the Hessian multiplied by the grad of 
      the expression, which may be computed as follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;inverseHessian&nbsp;*&nbsp;grad&nbsp;xs&nbsp;rosenbrock<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Vector.Generic.map&nbsp;(subst&nbsp;(function&nbsp;"x"&nbsp;-&gt;&nbsp;Num&nbsp;2N&nbsp;|&nbsp;"y"&nbsp;-&gt;&nbsp;Num&nbsp;3N));;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;Vector&lt;expr&gt;&nbsp;=&nbsp;vector&nbsp;[|1/201N;&nbsp;-197/201N|]</CODE></P>
      <P>The recurrence relation that defines the multivariate Newton method may 
      be found symbolically for the Rosenbrock function as follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;delta&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invert&nbsp;(fun&nbsp;x&nbsp;-&gt;&nbsp;Num&nbsp;1N&nbsp;/&nbsp;x)&nbsp;(hessian&nbsp;xs&nbsp;rosenbrock)&nbsp;*&nbsp;grad&nbsp;xs&nbsp;rosenbrock<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Vector.Generic.mapi&nbsp;(fun&nbsp;i&nbsp;f&nbsp;-&gt;&nbsp;Var&nbsp;xs.[i]&nbsp;-&nbsp;f&nbsp;|&gt;&nbsp;rewrite&nbsp;expand);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;delta&nbsp;:&nbsp;Vector&lt;expr&gt;&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vector&nbsp;[|x&nbsp;-&nbsp;((2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N))^-1N&nbsp;+&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N))^-1N&nbsp;-400N&nbsp;x&nbsp;(200N&nbsp;-&nbsp;-400N&nbsp;x&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N))^-1N&nbsp;-400N&nbsp;x)^-1N&nbsp;-400N&nbsp;x&nbsp;/&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N)))&nbsp;(-2N&nbsp;(1N&nbsp;-&nbsp;x)&nbsp;+&nbsp;100N&nbsp;-4N&nbsp;x&nbsp;(y&nbsp;-&nbsp;x^2N))&nbsp;+&nbsp;-1N&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N))^-1N&nbsp;-400N&nbsp;x&nbsp;/&nbsp;(200N&nbsp;-&nbsp;-400N&nbsp;x&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N))^-1N&nbsp;-400N&nbsp;x)&nbsp;200N&nbsp;(y&nbsp;-&nbsp;x^2N);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;-&nbsp;-1N&nbsp;(200N&nbsp;-&nbsp;-400N&nbsp;x&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N))^-1N&nbsp;-400N&nbsp;x)^-1N&nbsp;-400N&nbsp;x&nbsp;/&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N))&nbsp;(-2N&nbsp;(1N&nbsp;-&nbsp;x)&nbsp;+&nbsp;100N&nbsp;-4N&nbsp;x&nbsp;(y&nbsp;-&nbsp;x^2N))&nbsp;+&nbsp;(200N&nbsp;-&nbsp;-400N&nbsp;x&nbsp;(2N&nbsp;+&nbsp;100N&nbsp;(-4N&nbsp;x&nbsp;-2N&nbsp;x&nbsp;+&nbsp;(y&nbsp;-&nbsp;x^2N)&nbsp;-4N))^-1N&nbsp;-400N&nbsp;x)^-1N&nbsp;200N&nbsp;(y&nbsp;-&nbsp;x^2N)|]</CODE></P>
      <P>A single iteration of the Newton method may then be performed by 
      replacing the variables <CODE>x</CODE> and <CODE>y</CODE> with the results 
      given by the <CODE>delta</CODE> expression:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;newton&nbsp;(x&nbsp;:&nbsp;Vector&lt;_&gt;)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector.Generic.map&nbsp;(subst&nbsp;(function&nbsp;"x"&nbsp;-&gt;&nbsp;x.[0]&nbsp;|&nbsp;"y"&nbsp;-&gt;&nbsp;x.[1]))&nbsp;delta;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;newton&nbsp;:&nbsp;Vector&lt;expr&gt;&nbsp;-&gt;&nbsp;Vector&lt;expr&gt;</CODE></P>
      <P>The <CODE>Array.scan</CODE> function can be used to accumulate 
      iterations of the Newton method and the results can then be converted back 
      to floating-point numbers for easy interpretation:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;Array.scan&nbsp;(fun&nbsp;x&nbsp;_&nbsp;-&gt;&nbsp;newton&nbsp;x)&nbsp;(vector[Num&nbsp;3N;&nbsp;Num&nbsp;3N])&nbsp;[|1..5|]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Array.map&nbsp;(fun&nbsp;x&nbsp;-&gt;&nbsp;Vector.Generic.toArray&nbsp;x&nbsp;|&gt;&nbsp;Array.map&nbsp;(fun&nbsp;(Num&nbsp;p)&nbsp;-&gt;&nbsp;float&nbsp;p));;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;float&nbsp;[]&nbsp;[]&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|[|3.0;&nbsp;3.0|];&nbsp;[|2.998334721;&nbsp;8.990008326|];&nbsp;[|1.001107724;&nbsp;-2.986699005|];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|1.001106337;&nbsp;1.002213898|];&nbsp;[|1.0;&nbsp;0.999998776|];&nbsp;[|1.0;&nbsp;1.0|]|]</CODE></P>
      <P>In just five iterations we have reached the minimum of the Rosenbrock 
      function at <CODE>(1,&nbsp;1)</CODE>.</P>
      <H2>Summary</H2>
      <P>This article has described how a union type <CODE>expr</CODE> can be 
      used to represent and manipulate symbolic expressions including computing 
      derivatives, gradients, Hessian matrices and how these can be pulled 
      together to find symbolic representations of useful 
  algorithms.</P></TD></TR></TBODY></TABLE>
<TABLE id=footer>
  <TBODY>
  <TR>
    <TD>© Flying Frog Consultancy Ltd., 2010</TD>
    <TD>Contact the <A href="mailto:webmaster@ffconsultancy.com">webmaster</A> 
    </TD></TR></TBODY></TABLE>
<SCRIPT type=text/javascript 
src="F%23%20Journal%20symbolig%20differentiation%20and%20matrix%20inversion_files/urchin.js">
    <script type="text/javascript">_uacct = "UA-197840-1"; urchinTracker();</SCRIPT>
</BODY></HTML>
