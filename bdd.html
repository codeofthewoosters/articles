<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
  <head>
    <title>F# Journal</title>
    <link rel="stylesheet" type="text/css" href="../../../style.css"/>
    <link rel="stylesheet" type="text/css" href="../../style.css"/>
    <link rel="stylesheet" type="text/css" href="../../../individual.css"/>
  </head>
  <body>
    <table id="logo">
      <tr>
        <td width="100%">
          <img src="../../../images/title.gif"/>
        </td>
        <td>
          <img src="../../../images/left.gif"/>
        </td>
      </tr>
    </table>
    <table id="menu">
      <tr>
        <td width="25%"/>
        <td width="25%">
          <a href="../../index.html">Home Page</a>
        </td>
        <td width="25%">
          <a href="index.html">The F# Journal</a>
        </td>
        <td width="25%"/>
      </tr>
    </table>
    <table id="page">
      <tr>
        <td><h1>Testing: Behaviour-Driven Development with F#</h1><p>Of the many approaches taken to testing, Behaviour-Driven Development (BDD) is unusual in aiming to provide human-readable tests that can be used by non-technical people. The objective is to write the tests in a high-level language, as close to plain English as possible with data provided in the form of bullet-point lists or tables, that are interpreted by the machine in order to drive a production system and verify its behaviour. Naturally, F# is ideal in this situation because the challenge is essentially to implement an interpreter for a Domain Specific Language (DSL), the task that this family of languages were specifically bred for. This articles walks through a complete sample including Gherkin parser, interpreter and harnesses for the NUnit testing framework and F# interactive.</p><h2>Parsing Gherkin</h2><p>We begin by defining a suite of active patterns to parse a useful subset of the Gherkin language.</p><p>The following <code>Regex</code> active pattern checks the given string against the given regular expression (augmented with the <code>^</code> and <code>$</code> special characters to ensure that the pattern fills the entire string):</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;(|Regex|_|)&nbsp;re&nbsp;str&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;re&nbsp;=&nbsp;System.Text.RegularExpressions.Regex(&quot;^&quot;&nbsp;+&nbsp;re&nbsp;+&nbsp;&quot;$&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;m&nbsp;=&nbsp;re.Match&nbsp;str<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;m.Success&nbsp;then&nbsp;None&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some(Regex&nbsp;[&nbsp;for&nbsp;i&nbsp;in&nbsp;1&nbsp;..&nbsp;m.Groups.Count-1&nbsp;-&gt;&nbsp;m.Groups.[i].Value&nbsp;]);;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;(&nbsp;|Regex|_|&nbsp;)&nbsp;:&nbsp;string&nbsp;-&gt;&nbsp;string&nbsp;-&gt;&nbsp;string&nbsp;list&nbsp;option</code></p><p>For example, the following defines a <code>digits</code> string that contains a regular expression matching one or more digits:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;digits&nbsp;=&nbsp;&quot;[0-9]+&quot;;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;digits&nbsp;:&nbsp;string&nbsp;=&nbsp;&quot;[0-9]+&quot;</code></p><p>And a <code>dollars</code> string containing a regular expression that matches a dollar sign following by a sequence of digits that are extracted as a group:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;dollars&nbsp;=&nbsp;&quot;\\$(&quot;&nbsp;+&nbsp;digits&nbsp;+&nbsp;&quot;)&quot;;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;dollars&nbsp;:&nbsp;string&nbsp;=&nbsp;&quot;\$([0-9]+)&quot;</code></p><p>The <code>Regex</code> active pattern may then be used to extract the digits after a dollar sign as follows:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;(Regex&nbsp;dollars&nbsp;[n])&nbsp;=&nbsp;&quot;$1234&quot;;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;n&nbsp;:&nbsp;string&nbsp;=&nbsp;&quot;1234&quot;</code></p><p>This <code>Regex</code> active pattern has a wide variety of uses beyond the application described here.</p><p>In order to parse the Gherkin language, we begin by extracting tables that are delimited by pipe symbols at the start and end of the line and between each column. The following <code>Table</code> active pattern extracts a table if there is one or returns <code>None</code> otherwise:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;(|Table|)&nbsp;=&nbsp;function<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Regex&nbsp;&quot;\\|(.*)\\|&quot;&nbsp;[row]::Table(table,&nbsp;xs)&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;row&nbsp;=&nbsp;[for&nbsp;elt&nbsp;in&nbsp;row.Split[|'|'|]&nbsp;-&gt;&nbsp;elt.Trim()]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;table&nbsp;with<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Some&nbsp;rows&nbsp;-&gt;&nbsp;Some(row::rows),&nbsp;xs<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;None&nbsp;-&gt;&nbsp;Some[row],&nbsp;xs<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;xs&nbsp;-&gt;&nbsp;None,&nbsp;xs;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;(&nbsp;|Table|&nbsp;)&nbsp;:&nbsp;string&nbsp;list&nbsp;-&gt;&nbsp;string&nbsp;list&nbsp;list&nbsp;option&nbsp;*&nbsp;string&nbsp;list</code></p><p>The body of a scenario is broken down into sequences of &quot;given&quot;, &quot;when&quot; and &quot;then&quot; sentences. We begin by parsing the &quot;then&quot; sequences at the end of a scenario, each of which is optionally followed by a table:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;(|Thens|)&nbsp;=&nbsp;function<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Regex&nbsp;&quot;[aA]nd&nbsp;(.*)&quot;&nbsp;[t]::Table(table,&nbsp;Thens(ts,&nbsp;xs))&nbsp;-&gt;&nbsp;(t,&nbsp;table)::ts,&nbsp;xs<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;xs&nbsp;-&gt;&nbsp;[],&nbsp;xs;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;(&nbsp;|Thens|&nbsp;)&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;list&nbsp;-&gt;&nbsp;(string&nbsp;*&nbsp;string&nbsp;list&nbsp;list&nbsp;option)&nbsp;list&nbsp;*&nbsp;string&nbsp;list</code></p><p>Next, we parse the &quot;when&quot; sentences with their optional tables followed by a sequence of &quot;then&quot; statements:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;(|Whens|)&nbsp;=&nbsp;function<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Regex&nbsp;&quot;[aA]nd&nbsp;(.*)&quot;&nbsp;[w]::Table(table,&nbsp;Whens(ws,&nbsp;ts,&nbsp;xs))&nbsp;-&gt;&nbsp;(w,&nbsp;table)::ws,&nbsp;ts,&nbsp;xs<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Regex&nbsp;&quot;Then&nbsp;(.*)&quot;&nbsp;[t]::Table(table,&nbsp;Thens(ts,&nbsp;xs))&nbsp;-&gt;&nbsp;[],&nbsp;(t,&nbsp;table)::ts,&nbsp;xs<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;[]&nbsp;-&gt;&nbsp;invalidArg&nbsp;&quot;whens&quot;&nbsp;&quot;No&nbsp;thens&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x::_&nbsp;-&gt;&nbsp;invalidArg&nbsp;&quot;whens&quot;&nbsp;x;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;(&nbsp;|Whens|&nbsp;)&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;list&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string&nbsp;*&nbsp;string&nbsp;list&nbsp;list&nbsp;option)&nbsp;list&nbsp;*<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string&nbsp;*&nbsp;string&nbsp;list&nbsp;list&nbsp;option)&nbsp;list&nbsp;*&nbsp;string&nbsp;list</code></p><p>Note that we prohibit &quot;when&quot; sentences with no following &quot;then&quot; sentences, raising an exception in this case.</p><p>The &quot;given&quot; sentences may then be parsed as follows:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;(|Givens|)&nbsp;=&nbsp;function<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(Regex&nbsp;&quot;Given&nbsp;(.*)&quot;&nbsp;[g]&nbsp;|&nbsp;Regex&nbsp;&quot;[aA]nd&nbsp;(.*)&quot;&nbsp;[g])::Table(table,&nbsp;Givens((gs,&nbsp;ws,&nbsp;ts),&nbsp;xs))&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((g,&nbsp;table)::gs,&nbsp;ws,&nbsp;ts),&nbsp;xs<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Regex&nbsp;&quot;When&nbsp;(.*)&quot;&nbsp;[w]::Table(table,&nbsp;Whens(ws,&nbsp;ts,&nbsp;xs))&nbsp;-&gt;&nbsp;([],&nbsp;(w,&nbsp;table)::ws,&nbsp;ts),&nbsp;xs<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;[]&nbsp;-&gt;&nbsp;invalidArg&nbsp;&quot;givens&quot;&nbsp;&quot;No&nbsp;whens&nbsp;or&nbsp;thens&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x::_&nbsp;-&gt;&nbsp;invalidArg&nbsp;&quot;givens&quot;&nbsp;x;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;(&nbsp;|Givens|&nbsp;)&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;list&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((string&nbsp;*&nbsp;string&nbsp;list&nbsp;list&nbsp;option)&nbsp;list&nbsp;*<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string&nbsp;*&nbsp;string&nbsp;list&nbsp;list&nbsp;option)&nbsp;list&nbsp;*<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string&nbsp;*&nbsp;string&nbsp;list&nbsp;list&nbsp;option)&nbsp;list)&nbsp;*&nbsp;string&nbsp;list</code></p><p>This returns a tuple of the &quot;given&quot;, &quot;when&quot; and &quot;then&quot; sentences and their optional tables.</p><p>Each scenario begins &quot;Scenario:&quot; followed by the name of the scenario and, from the next line, three sequences of sentences that form the body of the scenario. The following <code>Scenarios</code> active pattern parses a sequence of scenarios, raising an exception if any unparsed lines remain:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;(|Scenarios|)&nbsp;=&nbsp;function<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;[]&nbsp;-&gt;&nbsp;[]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Regex&nbsp;&quot;Scenario:&nbsp;(.*)&quot;&nbsp;[name]::Givens(body,&nbsp;Scenarios&nbsp;scenarios)&nbsp;-&gt;&nbsp;(name,&nbsp;body)::scenarios<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;xs&nbsp;-&gt;&nbsp;invalidArg&nbsp;&quot;Scenarios&quot;&nbsp;(String.concat&nbsp;&quot;\n&quot;&nbsp;xs);;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;(&nbsp;|Scenarios|&nbsp;)&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;list&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string&nbsp;*<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((string&nbsp;*&nbsp;string&nbsp;list&nbsp;list&nbsp;option)&nbsp;list&nbsp;*<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string&nbsp;*&nbsp;string&nbsp;list&nbsp;list&nbsp;option)&nbsp;list&nbsp;*<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string&nbsp;*&nbsp;string&nbsp;list&nbsp;list&nbsp;option)&nbsp;list))&nbsp;list</code></p><p>Finally, an entire feature file begins with a line containing &quot;Feature:&quot; followed by the name of the feature and then the scenarios themselves:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;(|Feature|)&nbsp;=&nbsp;function<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Regex&nbsp;&quot;Feature:&nbsp;([^\\n]*)&quot;&nbsp;[featureName]::Scenarios&nbsp;scenarios&nbsp;-&gt;&nbsp;featureName,&nbsp;scenarios<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;s&nbsp;-&gt;&nbsp;invalidArg&nbsp;&quot;parseFeature&quot;&nbsp;&quot;Feature&nbsp;file&nbsp;is&nbsp;expected&nbsp;to&nbsp;begin&nbsp;with&nbsp;'Feature:&nbsp;...'&quot;;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;(&nbsp;|Feature|&nbsp;)&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;list&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;*<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string&nbsp;*<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((string&nbsp;*&nbsp;string&nbsp;list&nbsp;list&nbsp;option)&nbsp;list&nbsp;*<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string&nbsp;*&nbsp;string&nbsp;list&nbsp;list&nbsp;option)&nbsp;list&nbsp;*<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string&nbsp;*&nbsp;string&nbsp;list&nbsp;list&nbsp;option)&nbsp;list))&nbsp;list&nbsp;&nbsp;&nbsp;&nbsp;</code></p><p>These active patterns are a quick and easy way to parse a useful subset of the Gherkin language, capable of testing real production code.</p><h2>Application for testing</h2><p>We also need some kind of application to be tested. In this case, we shall write a simple program that simulates the actions of an ATM, such as dispensing cash and debiting bank accounts.</p><p>A bank card is either valid or invalid:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;type&nbsp;cardState&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Valid<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Invalid;;<br />&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;cardState&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Valid<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Invalid</code></p><p>The state for a test consists of the current bank balance in the user's account, the state of their card, the cash available for dispensing in the machine and the amount to be debited from the account:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;type&nbsp;state&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance:&nbsp;decimal;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cardState:&nbsp;cardState;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stock:&nbsp;decimal;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debit:&nbsp;decimal<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};;<br />&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;state&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{balance:&nbsp;decimal;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cardState:&nbsp;cardState;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stock:&nbsp;decimal;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debit:&nbsp;decimal;}</code></p><p>In this case, the user is capable of issuing a single kind of instruction to our system:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;type&nbsp;instruction&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Request&nbsp;of&nbsp;decimal;;<br />&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;instruction&nbsp;=&nbsp;|&nbsp;Request&nbsp;of&nbsp;decimal</code></p><p>Finally, the result is the set of outcomes:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;type&nbsp;result&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;InsufficientCreditInAccount<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;InsufficientMoneyInATM<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Dispensed&nbsp;of&nbsp;decimal<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;CardReturned<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;CardRetained;;<br />&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;result&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;InsufficientCreditInAccount<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;InsufficientMoneyInATM<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Dispensed&nbsp;of&nbsp;decimal<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;CardReturned<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;CardRetained</code></p><p>The actions of our system will be implemented by the following simple function in this case:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;handleRequest&nbsp;(state:&nbsp;state,&nbsp;results:&nbsp;result&nbsp;list)&nbsp;instruction&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;state,&nbsp;instruction&nbsp;with<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;{&nbsp;cardState&nbsp;=&nbsp;Valid&nbsp;},&nbsp;Request&nbsp;debit&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;state.balance&nbsp;&gt;=&nbsp;debit,&nbsp;state.stock&nbsp;&gt;=&nbsp;debit&nbsp;with<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;true,&nbsp;true&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;state&nbsp;with&nbsp;balance&nbsp;=&nbsp;state.balance&nbsp;-&nbsp;debit&nbsp;},<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dispensed&nbsp;debit&nbsp;::&nbsp;CardReturned&nbsp;::&nbsp;results<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;false,&nbsp;(true&nbsp;|&nbsp;false)&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state,&nbsp;CardReturned&nbsp;::&nbsp;InsufficientCreditInAccount&nbsp;::&nbsp;results<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;true,&nbsp;false&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state,&nbsp;CardReturned&nbsp;::&nbsp;InsufficientMoneyInATM&nbsp;::&nbsp;results<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;{&nbsp;cardState&nbsp;=&nbsp;Invalid&nbsp;},&nbsp;Request&nbsp;debit&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state,&nbsp;CardRetained&nbsp;::&nbsp;results;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;handleRequest&nbsp;:&nbsp;state&nbsp;*&nbsp;result&nbsp;list&nbsp;-&gt;&nbsp;instruction&nbsp;-&gt;&nbsp;state&nbsp;*&nbsp;result&nbsp;list</code></p><p>In practice, this approach is often used to test thousands of lines of F# code at a time.</p><h2>Test harness</h2><p>Now we need to build the test harness itself. Unlike most test harnesses, this is actually responsible for interpreting a high-level language. We begin by defining the type of a collection of sentences:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;type&nbsp;sentences&nbsp;=&nbsp;(string&nbsp;*&nbsp;string&nbsp;list&nbsp;list&nbsp;option)&nbsp;list;;<br />&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;sentences&nbsp;=&nbsp;(string&nbsp;*&nbsp;string&nbsp;list&nbsp;list&nbsp;option)&nbsp;list</code></p><p>Each scenario provides the following information:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;type&nbsp;scenario&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;featureName:&nbsp;string;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scenarioName:&nbsp;string;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;givens:&nbsp;sentences;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;whens:&nbsp;sentences;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thens:&nbsp;sentences<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};;<br />&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;scenario&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{featureName:&nbsp;string;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scenarioName:&nbsp;string;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;givens:&nbsp;sentences;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;whens:&nbsp;sentences;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thens:&nbsp;sentences;}</code></p><p>The <code>scenarioOfFeatures</code> function converts the plain text representation of a feature file into a list of scenarios:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;scenariosOfFeature&nbsp;(feature:&nbsp;string)&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;(Parse.Feature(featureName,&nbsp;scenarios))&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;for&nbsp;line&nbsp;in&nbsp;feature.Split[|'\n'|]&nbsp;do<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;line&nbsp;=&nbsp;line.Trim()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;line&nbsp;&lt;&gt;&nbsp;&quot;&quot;&nbsp;then&nbsp;yield&nbsp;line&nbsp;]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;for&nbsp;name,&nbsp;(givens,&nbsp;whens,&nbsp;thens)&nbsp;in&nbsp;scenarios&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;featureName&nbsp;=&nbsp;featureName;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scenarioName&nbsp;=&nbsp;name;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;givens&nbsp;=&nbsp;givens;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;whens&nbsp;=&nbsp;whens;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thens&nbsp;=&nbsp;thens<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;];;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;scenariosOfFeature&nbsp;:&nbsp;string&nbsp;-&gt;&nbsp;scenario&nbsp;list</code></p><p>Note the use of the <code>Feature</code> active pattern.</p><p>The following active pattern removes the commas from a string before converting it to the built-in <code>decimal</code> type:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;(|Dollars|_|)&nbsp;(s:&nbsp;string)&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;Some(Dollars(decimal(s.Replace(&quot;,&quot;,&nbsp;&quot;&quot;))))&nbsp;with&nbsp;_&nbsp;-&gt;&nbsp;None;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;(&nbsp;|Dollars|_|&nbsp;)&nbsp;:&nbsp;string&nbsp;-&gt;&nbsp;decimal&nbsp;option</code></p><p>The following <code>interpretGiven</code> function interprets a given statement and takes the necessary action on the given state, returning a new state:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;interpretGiven&nbsp;state&nbsp;=&nbsp;function<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Regex&nbsp;&quot;the&nbsp;account&nbsp;balance&nbsp;is&nbsp;\\$([,0-9]+)&quot;&nbsp;[Dollars&nbsp;balance],&nbsp;None&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;state&nbsp;with&nbsp;balance&nbsp;=&nbsp;balance&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Regex&nbsp;&quot;the&nbsp;card&nbsp;is&nbsp;valid&quot;&nbsp;[],&nbsp;None&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;state&nbsp;with&nbsp;cardState&nbsp;=&nbsp;Valid&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Regex&nbsp;&quot;the&nbsp;card&nbsp;is&nbsp;invalid&quot;&nbsp;[],&nbsp;None&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;state&nbsp;with&nbsp;cardState&nbsp;=&nbsp;Invalid&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Regex&nbsp;&quot;the&nbsp;machine&nbsp;contains&nbsp;\\$([,0-9]+)&quot;&nbsp;[Dollars&nbsp;stock],&nbsp;None&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;state&nbsp;with&nbsp;stock&nbsp;=&nbsp;stock&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;line&nbsp;-&gt;&nbsp;invalidArg&nbsp;(sprintf&nbsp;&quot;Failed&nbsp;to&nbsp;interpret&nbsp;Given&nbsp;%A&quot;&nbsp;line)&nbsp;&quot;line&quot;;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;interpretGiven&nbsp;:&nbsp;state&nbsp;-&gt;&nbsp;string&nbsp;*&nbsp;'a&nbsp;option&nbsp;-&gt;&nbsp;state</code></p><p>Note the discrepancy between this functional style of BDD implementation and the traditional solution that relies upon mutable global state. The functional style has some important benefits. Firstly, mutable global state makes it easy for one test to affect the next by corrupting the state. This is impossible with the functional style because the state does not even exist between tests. Secondly, the functional style makes it trivial to accumulate not only the current state but also all previous states and the actions that created them. In the context of testing, where the application is often behaving incorrectly, the ability to &quot;travel back in time&quot; by inspecting old states can greatly accelerate the identification and fixing of bugs.</p><p>The following <code>interpretWhen</code> function interprets the only kind of &quot;when&quot; statement supported in this case, a user requesting money from an ATM:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;interpretWhen&nbsp;instructions&nbsp;=&nbsp;function<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Regex&nbsp;&quot;the&nbsp;Account&nbsp;Holder&nbsp;requests&nbsp;\\$([,0-9]+)&quot;&nbsp;[Dollars&nbsp;debit],&nbsp;None&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Request&nbsp;debit&nbsp;::&nbsp;instructions<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;line&nbsp;-&gt;&nbsp;invalidArg&nbsp;(sprintf&nbsp;&quot;Failed&nbsp;to&nbsp;interpret&nbsp;When&nbsp;%A&quot;&nbsp;line)&nbsp;&quot;line&quot;;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;interpretWhen&nbsp;:&nbsp;instruction&nbsp;list&nbsp;-&gt;&nbsp;string&nbsp;*&nbsp;'a&nbsp;option&nbsp;-&gt;&nbsp;instruction&nbsp;list</code></p><p>The following operator is used to raise an exception when two values are expected to be equal but are found to differ:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;(=?)&nbsp;a&nbsp;b&nbsp;=&nbsp;if&nbsp;a&nbsp;&lt;&gt;&nbsp;b&nbsp;then&nbsp;failwith&nbsp;(sprintf&nbsp;&quot;Expected&nbsp;%A&nbsp;but&nbsp;found&nbsp;%A&quot;&nbsp;a&nbsp;b);;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;(&nbsp;=?&nbsp;)&nbsp;:&nbsp;'a&nbsp;-&gt;&nbsp;'a&nbsp;-&gt;&nbsp;unit&nbsp;when&nbsp;'a&nbsp;:&nbsp;equality</code></p><p>The <code>interpretThen</code> function interprets the tests themselves and uses the <code>=?</code> operator to validate the expectations described in the test against the actual result that it observes:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;interpretThen&nbsp;state&nbsp;results&nbsp;=&nbsp;function<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Regex&nbsp;&quot;the&nbsp;ATM&nbsp;should&nbsp;dispense&nbsp;\\$([,0-9]+)&quot;&nbsp;[Dollars&nbsp;dispensed],&nbsp;None&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispensed&nbsp;=?&nbsp;Seq.sumBy&nbsp;(function&nbsp;Dispensed&nbsp;n&nbsp;-&gt;&nbsp;n&nbsp;|&nbsp;_&nbsp;-&gt;&nbsp;0M)&nbsp;results<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Regex&nbsp;&quot;the&nbsp;ATM&nbsp;should&nbsp;not&nbsp;dispense&nbsp;any&nbsp;money&quot;&nbsp;[],&nbsp;None&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0M&nbsp;=?&nbsp;Seq.sumBy&nbsp;(function&nbsp;Dispensed&nbsp;n&nbsp;-&gt;&nbsp;n&nbsp;|&nbsp;_&nbsp;-&gt;&nbsp;0M)&nbsp;results<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Regex&nbsp;&quot;the&nbsp;ATM&nbsp;should&nbsp;retain&nbsp;the&nbsp;card&quot;&nbsp;[],&nbsp;None&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true&nbsp;=?&nbsp;Seq.exists&nbsp;((=)&nbsp;CardRetained)&nbsp;results<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Regex&nbsp;&quot;the&nbsp;card&nbsp;should&nbsp;be&nbsp;returned&quot;&nbsp;[],&nbsp;None&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true&nbsp;=?&nbsp;Seq.exists&nbsp;((=)&nbsp;CardReturned)&nbsp;results<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Regex&nbsp;&quot;the&nbsp;account&nbsp;balance&nbsp;should&nbsp;be&nbsp;\\$([,0-9]+)&quot;&nbsp;[Dollars&nbsp;balance],&nbsp;None&nbsp;-&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfn&nbsp;&quot;%A&quot;&nbsp;(balance,&nbsp;state.balance)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance&nbsp;=?&nbsp;state.balance<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;line&nbsp;-&gt;&nbsp;invalidArg&nbsp;(sprintf&nbsp;&quot;Failed&nbsp;to&nbsp;interpret&nbsp;Then&nbsp;%A&quot;&nbsp;line)&nbsp;&quot;line&quot;;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;interpretThen&nbsp;:&nbsp;state&nbsp;-&gt;&nbsp;seq&lt;result&gt;&nbsp;-&gt;&nbsp;string&nbsp;*&nbsp;'a&nbsp;option&nbsp;-&gt;&nbsp;unit</code></p><p>Finally the following <code>execute</code> function begins with a sane default state and runs the interpreters over the sentences of the BDD test, using the <code>handleRequest</code> function from the application to execute the instructions from the test:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;execute&nbsp;(scenario:&nbsp;scenario)&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;state&nbsp;=&nbsp;{&nbsp;balance&nbsp;=&nbsp;0M;&nbsp;cardState&nbsp;=&nbsp;Invalid;&nbsp;stock&nbsp;=&nbsp;0M;&nbsp;debit&nbsp;=&nbsp;0M&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;state&nbsp;=&nbsp;Seq.fold&nbsp;interpretGiven&nbsp;state&nbsp;scenario.givens<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;instructions&nbsp;=&nbsp;Seq.fold&nbsp;interpretWhen&nbsp;[]&nbsp;scenario.whens<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;state,&nbsp;results&nbsp;=&nbsp;Seq.fold&nbsp;Application.handleRequest&nbsp;(state,&nbsp;[])&nbsp;instructions<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Seq.iter&nbsp;(interpretThen&nbsp;state&nbsp;results)&nbsp;scenario.thens;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;execute&nbsp;:&nbsp;scenario&nbsp;-&gt;&nbsp;unit</code></p><p>This completes the test harness but we add a helper function <code>test</code> that loads a feature file from the source directory of the project in order to make it easier to run tests from F# interactive:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;test&nbsp;feature&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;scenarios&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.IO.File.ReadAllText(__SOURCE_DIRECTORY__&nbsp;+&nbsp;&quot;\\&quot;&nbsp;+&nbsp;feature&nbsp;+&nbsp;&quot;.feature&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;scenariosOfFeature<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfn&nbsp;&quot;Feature:&nbsp;%s&quot;&nbsp;feature<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;scenario&nbsp;in&nbsp;scenarios&nbsp;do<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printfn&nbsp;&quot;Scenario:&nbsp;%s&quot;&nbsp;scenario.scenarioName<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;execute&nbsp;scenario;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;test&nbsp;:&nbsp;string&nbsp;-&gt;&nbsp;unit</code></p><p>This completes the generic test harness including the interpreter. Next, we focus on integration with specific tools: NUnit and F# interactive.</p><h2>Integration with NUnit</h2><p>NUnit is a common testing framework that makes it easy to write and run unit tests. Many tools have been built upon NUnit including the TestDriven.NET application that provides easy access to tests from within Visual Studio.</p><p>After referencing <code>NUnit.Framework.dll</code>, our tests may be integrated with NUnit as follows. We begin by opening the NUnit namespace:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;open&nbsp;NUnit.Framework;;</code></p><p>Assuming the feature files have been included in the project as embedded resources, we can obtain them via the assembly:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;assembly&nbsp;=&nbsp;System.Reflection.Assembly.GetExecutingAssembly();;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;assembly&nbsp;:&nbsp;System.Reflection.Assembly</code></p><p>The following function extracts the resource embedded in the assembly as a string:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;load&nbsp;file&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;assembly&nbsp;=&nbsp;System.Reflection.Assembly.GetExecutingAssembly()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;s&nbsp;=&nbsp;assembly.GetManifestResourceStream(file)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;s&nbsp;=&nbsp;null&nbsp;then&nbsp;invalidArg&nbsp;(sprintf&nbsp;&quot;Failed&nbsp;to&nbsp;get&nbsp;manifest&nbsp;resource&nbsp;stream&nbsp;'%s'&quot;&nbsp;file)&nbsp;&quot;file&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;reader&nbsp;=&nbsp;new&nbsp;System.IO.StreamReader(s)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reader.ReadToEnd();;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;load&nbsp;:&nbsp;string&nbsp;-&gt;&nbsp;string</code></p><p>Finally, we create a class with the <code>TestFixture</code> attribute and two member functions that extract and execute the scenarios in a feature:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;[&lt;TestFixture&gt;]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;FeatureFixture&nbsp;()&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;Test&gt;]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;TestCaseSource(&quot;TestATM&quot;)&gt;]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;this.ATM&nbsp;scenario&nbsp;=&nbsp;TestHarness.execute&nbsp;scenario<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;this.TestATM()&nbsp;=&nbsp;TestHarness.scenariosOfFeature(load&nbsp;&quot;ATM.feature&quot;);;<br />&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;FeatureFixture&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;FeatureFixture<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;ATM&nbsp;:&nbsp;scenario:'a&nbsp;-&gt;&nbsp;unit<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;TestATM&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;TestHarness.scenario&nbsp;list<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</code></p><p>This approach ensures that NUnit displays different features separately and the tester can see immediately which feature failed.</p><h2>Testing directly from F# interactive</h2><p>F# facilitates a novel approach to testing: compiling and running within F# interactive. Whereas NUnit integration facilitates the use of many tools such as report generation during batch compilation that are already available from NUnit tests, executing tests interactively is faster and can provide more user-friendly feeback making it ideal for use during the development of tests.</p><p>The <code>test</code> function defined at the end of our test harness code was specifically designed to allow tests to be run as easily as possible from within F# interactive. With that function, a tester can compile the source code to the applications, the Gherkin parser and our test harness and use it to execute tests immediately as follows:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;#load&nbsp;&quot;Parse.fs&quot;&nbsp;&quot;Application.fs&quot;&nbsp;&quot;TestHarness.fs&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;open&nbsp;Acme.TestHarness<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;test&nbsp;&quot;ATM&quot;</code></p><p>This is much faster than invoking NUnit and running the tests from within the NUnit application.</p><h2>Summary</h2><p>This article has built upon the techniques described in several previous articles in order to build a test harness for a high-level domain specific language for testing. The result is a remarkably powerful approach to testing that allows succinct human readable tests to be executed by the machine. The tests can be made accessible to non-technical personnel. F# makes it easy for testers to work with. The functional style of threading the state through each part of the test makes it much easier to record a history of operations and internal states that culminated in erroneous behaviour and, therefore, to diagnose and fix bugs when they are found.</p><p>Moreover, the control this technique offers over the programmatic dissection of the tests opens up new avenues. For example, the high-level BDD tests can be used to derive low-level regression tests by recording the exact inputs and outputs to the system and generating code to verify low-level specifics during execution.</p><p>Future F#.NET Journal articles will revisit the subject of testing.</p>        </td>
      </tr>
    </table>
    <table id="footer">
      <tr>
        <td>&copy; Flying Frog Consultancy Ltd., 2010</td>
        <td>
Contact the 
          <a href="mailto:webmaster@ffconsultancy.com">webmaster</a>
        </td>
      </tr>
    </table>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"/>
    <script type="text/javascript">_uacct = "UA-197840-1"; urchinTracker();</script>
  </body>
</html>
