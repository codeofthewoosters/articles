<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0075)http://www.ffconsultancy.com/products/fsharp_journal/subscribers/astar.html -->
<!--?xml version="1.0" encoding="iso-8859-1"?--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><HTML><HEAD><META 
content="IE=10.000" http-equiv="X-UA-Compatible">
     <TITLE>F# Journal: The A* algorithm</TITLE>     
<META http-equiv="Content-Type" content="text/html; charset=utf-8"><LINK href="F%23%20Journal%20The%20A%20algorithm_files/style.css" 
rel="stylesheet" type="text/css">     <LINK href="F%23%20Journal%20The%20A%20algorithm_files/style(1).css" 
rel="stylesheet" type="text/css">     <LINK href="F%23%20Journal%20The%20A%20algorithm_files/individual.css" 
rel="stylesheet" type="text/css">   
<META name="GENERATOR" content="MSHTML 10.00.9200.16458"></HEAD>   
<BODY>
<TABLE id="logo">
  <TBODY>
  <TR>
    <TD width="100%"><IMG src="F%23%20Journal%20The%20A%20algorithm_files/title.gif"> 
              </TD>
    <TD><IMG src="F%23%20Journal%20The%20A%20algorithm_files/left.gif">        
     </TD></TR></TBODY></TABLE>
<TABLE id="menu">
  <TBODY>
  <TR>
    <TD width="25%">
    <TD width="25%"><A 
      href="http://www.ffconsultancy.com/products/index.html">Home Page</A>      
         </TD>
    <TD width="25%"><A href="http://www.ffconsultancy.com/products/fsharp_journal/subscribers/index.html">The 
      F# Journal</A>         </TD>
    <TD width="25%"></TR></TBODY></TABLE>
<TABLE id="page">
  <TBODY>
  <TR>
    <TD>
      <H1>The A* algorithm</H1>
      <P>The A* algorithm is often used for route finding in game AI and is a 
      generalization of Dijkstra's shortest-path algorithm from graph theory. 
      This article describes two generic implementations of the A* algorithm 
      written in F#. The first implementation is a simple prototype written in a 
      purely functional style using data structures provided by F#. The second 
      implementation uses mutable .NET collections to perform the same 
      computation substantially more quickly. Finally, an example application is 
      provided that finds a route across the Grand Canyon.</P>
      <H2>Introduction</H2>
      <P>Dijkstra's shortest path algorithm finds the shortest path between a 
      pair of nodes in a graph using a breadth-first traversal that 
      incrementally expands a set of nodes around the first node until it 
      includes the second node. Consequently, applying Dijkstra's algorithm to a 
      planar problem results in a roughly circular set of searched nodes. This 
      represents a lot of wasted effort because half of the steps taken were in 
      the wrong direction.</P>
      <P>In many cases, this naive shortest path algorithm may be substantially 
      improved upon by biasing the search towards nodes that are closer 
      according to some heuristic, such as the Euclidean distance between the 
      nodes. In the simplest case of a flat terrain, this heuristic-based 
      algorithm will find the shortest path almost immediately by taking steps 
      from the first node directly towards the second node. This is the A* 
      algorithm.</P>
      <P>This article describes a simple but efficient and reusable 
      implementation of the A* algorithm in F#.</P>
      <H2>Implementation</H2>
      <P>We shall examine a simple purely functional implementation that uses 
      only immutable data structures before optimizing it using mutable 
      collections. In both cases, the algorithm will act upon an abstract 
      representation of a graph using the following <CODE>IGraph&lt;_&gt;</CODE> 
      interface that is parameterized over the type of vertex:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;type&nbsp;IGraph&lt;'Node&gt;&nbsp;when&nbsp;'Node&nbsp;:&nbsp;comparison&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;distanceTo&nbsp;:&nbsp;'Node&nbsp;-&gt;&nbsp;'Node&nbsp;-&gt;&nbsp;float<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;iterNeighbors&nbsp;:&nbsp;'Node&nbsp;-&gt;&nbsp;('Node&nbsp;-&gt;&nbsp;unit)&nbsp;-&gt;&nbsp;unit;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;IGraph&lt;'Node&nbsp;when&nbsp;'Node&nbsp;:&nbsp;comparison&gt;&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;member&nbsp;distanceTo&nbsp;:&nbsp;'Node&nbsp;-&gt;&nbsp;'Node&nbsp;-&gt;&nbsp;float<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;member&nbsp;iterNeighbors&nbsp;:&nbsp;'Node&nbsp;-&gt;&nbsp;('Node&nbsp;-&gt;&nbsp;unit)&nbsp;-&gt;&nbsp;unit<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</CODE></P>
      <P>Both implementations will require a priority heap that is most easily 
      obtained by using a <CODE>Set</CODE> or <CODE>HashSet</CODE> with an 
      element type that has the appropriate total ordering implemented via the 
      <CODE>System.IComparable</CODE> interface. The following <CODE>Meta</CODE> 
      augmented record type serves this purpose:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;[&lt;CustomEquality&gt;]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;CustomComparison&gt;]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;Meta&lt;'t&gt;&nbsp;when&nbsp;'t&nbsp;:&nbsp;comparison&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;path:&nbsp;'t&nbsp;list;&nbsp;g:&nbsp;float;&nbsp;f:&nbsp;float;&nbsp;vertex:&nbsp;'t&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;x.Equals&nbsp;y&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compare&nbsp;x&nbsp;(y&nbsp;:?&gt;&nbsp;Meta&lt;_&gt;)&nbsp;=&nbsp;0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;x.GetHashCode()&nbsp;=&nbsp;x.vertex.GetHashCode()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface&nbsp;System.IComparable&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;x.CompareTo&nbsp;y&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;y&nbsp;=&nbsp;(y&nbsp;:?&gt;&nbsp;Meta&lt;_&gt;)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compare&nbsp;(x.f,&nbsp;x.vertex)&nbsp;(y.f,&nbsp;y.vertex);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;Meta&lt;'t&nbsp;when&nbsp;'t&nbsp;:&nbsp;comparison&gt;&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{path:&nbsp;'t&nbsp;list;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g:&nbsp;float;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f:&nbsp;float;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertex:&nbsp;'t;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface&nbsp;System.IComparable<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;Equals&nbsp;:&nbsp;y:obj&nbsp;-&gt;&nbsp;bool<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;GetHashCode&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;int<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</CODE></P>
      <P>The comparison function compares the estimated path lengths 
      <CODE>f</CODE> of two <CODE>Meta</CODE> objects before comparing the 
      vertices themselves.</P>
      <H3>Purely functional prototype</H3>
      <P>The following active patterns can be used to extract the first 
      (smallest) element from a <CODE>Set</CODE>:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;(|Empty|First|)&nbsp;xs&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;Set.isEmpty&nbsp;xs&nbsp;then&nbsp;Empty&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x&nbsp;=&nbsp;Set.minElement&nbsp;xs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;First(x,&nbsp;Set.remove&nbsp;x&nbsp;xs);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;(&nbsp;|Empty|First|&nbsp;)&nbsp;:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set&lt;'a&gt;&nbsp;-&gt;&nbsp;Choice&lt;unit,('a&nbsp;*&nbsp;Set&lt;'a&gt;)&gt;&nbsp;when&nbsp;'a&nbsp;:&nbsp;comparison</CODE></P>
      <P>We shall use the following <CODE>foldOfIter</CODE> function to create a 
      fold from the <CODE>iterNeighbors</CODE> function provided by values 
      implementing the <CODE>IGraph&lt;_&gt;</CODE> interface:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;foldOfIter&nbsp;iter&nbsp;f&nbsp;a&nbsp;xs&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;a&nbsp;=&nbsp;ref&nbsp;a<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iter&nbsp;xs&nbsp;(fun&nbsp;x&nbsp;-&gt;&nbsp;a&nbsp;:=&nbsp;f&nbsp;!a&nbsp;x)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!a;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;foldOfIter&nbsp;:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('a&nbsp;-&gt;&nbsp;('b&nbsp;-&gt;&nbsp;unit)&nbsp;-&gt;&nbsp;unit)&nbsp;-&gt;&nbsp;('c&nbsp;-&gt;&nbsp;'b&nbsp;-&gt;&nbsp;'c)&nbsp;-&gt;&nbsp;'c&nbsp;-&gt;&nbsp;'a&nbsp;-&gt;&nbsp;'c</CODE></P>
      <P>The A* algorithm may then be implemented as follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;search&nbsp;(graph:&nbsp;IGraph&lt;_&gt;)&nbsp;src&nbsp;dst&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;loop&nbsp;(meta,&nbsp;closedSet,&nbsp;openSet)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;openSet&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Empty&nbsp;-&gt;&nbsp;None,&nbsp;closedSet<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;First(x,&nbsp;openSet)&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;x.vertex&nbsp;=&nbsp;dst&nbsp;then&nbsp;Some&nbsp;x.path,&nbsp;closedSet&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;closedSet&nbsp;=&nbsp;Set.add&nbsp;x.vertex&nbsp;closedSet<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;aux&nbsp;(meta,&nbsp;open_set)&nbsp;y&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;Set.contains&nbsp;y&nbsp;closedSet&nbsp;then&nbsp;meta,&nbsp;openSet&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;y'&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;g'&nbsp;=&nbsp;x.g&nbsp;+&nbsp;graph.distanceTo&nbsp;x.vertex&nbsp;y<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;path&nbsp;=&nbsp;y::x.path;&nbsp;g&nbsp;=&nbsp;g';&nbsp;f&nbsp;=&nbsp;g'&nbsp;+&nbsp;graph.distanceTo&nbsp;y&nbsp;dst;&nbsp;vertex&nbsp;=&nbsp;y&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;meta'&nbsp;openSet&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map.add&nbsp;y&nbsp;y'&nbsp;meta,&nbsp;Set.add&nbsp;y'&nbsp;openSet<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;Map.containsKey&nbsp;y&nbsp;meta&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;y&nbsp;=&nbsp;Map.find&nbsp;y&nbsp;meta<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;Set.contains&nbsp;y&nbsp;openSet&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;y'.g&nbsp;&gt;=&nbsp;y.g&nbsp;then&nbsp;meta,&nbsp;openSet&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meta'(Set.remove&nbsp;y&nbsp;openSet)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meta'&nbsp;openSet<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meta'&nbsp;openSet<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;meta,&nbsp;openSet&nbsp;=&nbsp;foldOfIter&nbsp;graph.iterNeighbors&nbsp;aux&nbsp;(meta,&nbsp;openSet)&nbsp;x.vertex<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop(meta,&nbsp;closedSet,&nbsp;openSet)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x&nbsp;=&nbsp;{&nbsp;path&nbsp;=&nbsp;[src];&nbsp;g&nbsp;=&nbsp;0.0;&nbsp;f&nbsp;=&nbsp;graph.distanceTo&nbsp;src&nbsp;dst;&nbsp;vertex&nbsp;=&nbsp;src&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop(Map.add&nbsp;src&nbsp;x&nbsp;Map.empty,&nbsp;Set.empty,&nbsp;Set.singleton&nbsp;x);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;search&nbsp;:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IGraph&lt;'a&gt;&nbsp;-&gt;&nbsp;'a&nbsp;-&gt;&nbsp;'a&nbsp;-&gt;&nbsp;'a&nbsp;list&nbsp;option&nbsp;*&nbsp;Set&lt;'a&gt;&nbsp;when&nbsp;'a&nbsp;:&nbsp;comparison</CODE></P>
      <P>For the purposes of this demonstration, we are returning the closed set 
      (the set of visited nodes) as well as the shortest path.</P>
      <P>This <CODE>search</CODE> function maintains a closed set of visited 
      nodes and an open set of nodes that are being visited. If the open set is 
      empty then no path exists between the two nodes and <CODE>None</CODE> is 
      returned. Otherwise, the node <CODE>x</CODE> in the open set with the 
      shortest estimated path length is extracted, removing it from the open 
      set. If <CODE>x</CODE> is the destination node then the shortest path has 
      been found and it is returned. Otherwise, its neighbors are examined and 
      each neighbor <CODE>y</CODE> that is not already in the closed set has its 
      estimated path length refined using the exact distance between the current 
      node <CODE>x</CODE> and its adjacent neighbor <CODE>y</CODE>.</P>
      <P>One particularly cute improvement over the more conventional imperative 
      implementation is that the paths can be accumulated in the metadata using 
      the ordinary immutable F# <CODE>list</CODE> type. Each time a new vertex 
      is prepended onto an existing path it is sharing that existing path with 
      any other vertices that use it. This reuse of paths is an example of the 
      use of persistence, a feature intrinsically provided by all immutable data 
      structures.</P>
      <P>The example given in this article searches for the shortest path across 
      a 1,201×1,201 height field of the Grand Canyon. The simple purely 
      functional implementation described above takes 111s to find the path 
      across it. This is far too slow for most purposes so we should optimize 
      the program to obtain better performance.</P>
      <H3>Faster imperative implementation</H3>
      <P>The simplest way to improve the low-level performance of the prototype 
      implementation is to resort to mutable data structures for the metadata, 
      open and closed sets. Specifically, a .NET hash table 
      (<CODE>Dictionary</CODE>) can be used instead of a <CODE>Map</CODE> for 
      the metadata, a <CODE>HashSet</CODE> can be used for the closed set and 
      the open set (which must be ordered) can use the <CODE>SortedSet</CODE> 
      data structure provided by .NET:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;open&nbsp;System.Collections.Generic;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;search&nbsp;(graph:&nbsp;IGraph&lt;_&gt;)&nbsp;src&nbsp;dst&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;meta&nbsp;=&nbsp;Dictionary&nbsp;HashIdentity.Structural<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;closedSet&nbsp;=&nbsp;HashSet&nbsp;HashIdentity.Structural<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;openSet&nbsp;=&nbsp;SortedSet()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x&nbsp;=&nbsp;{&nbsp;path&nbsp;=&nbsp;[src];&nbsp;g&nbsp;=&nbsp;0.0;&nbsp;f&nbsp;=&nbsp;graph.distanceTo&nbsp;src&nbsp;dst;&nbsp;vertex&nbsp;=&nbsp;src&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meta.Add(src,&nbsp;x)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;openSet.Add&nbsp;x&nbsp;|&gt;&nbsp;ignore<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;loop()&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;openSet.Count&nbsp;=&nbsp;0&nbsp;then&nbsp;None&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x&nbsp;=&nbsp;openSet.Min<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;openSet.Remove&nbsp;x&nbsp;|&gt;&nbsp;ignore<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;x.vertex&nbsp;=&nbsp;dst&nbsp;then&nbsp;Some&nbsp;x.path&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closedSet.Add&nbsp;x.vertex&nbsp;|&gt;&nbsp;ignore<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;graph.iterNeighbors&nbsp;x.vertex&nbsp;(fun&nbsp;y&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not(closedSet.Contains&nbsp;y)&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;y''&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;g''&nbsp;=&nbsp;x.g&nbsp;+&nbsp;graph.distanceTo&nbsp;x.vertex&nbsp;y<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;path&nbsp;=&nbsp;y::x.path;&nbsp;g&nbsp;=&nbsp;g'';&nbsp;f&nbsp;=&nbsp;g''&nbsp;+&nbsp;graph.distanceTo&nbsp;y&nbsp;dst;&nbsp;vertex&nbsp;=&nbsp;y&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;y'&nbsp;=&nbsp;ref&nbsp;y''<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;meta.TryGetValue(y,&nbsp;y')&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;y'&nbsp;=&nbsp;!y'<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;openSet.Contains&nbsp;y'&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;y''.g&nbsp;&lt;&nbsp;y'.g&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meta.Remove&nbsp;y&nbsp;|&gt;&nbsp;ignore<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meta.Add(y,&nbsp;y'')<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;openSet.Remove&nbsp;y'&nbsp;|&gt;&nbsp;ignore<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;openSet.Add&nbsp;y''&nbsp;|&gt;&nbsp;ignore<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meta.Add(y,&nbsp;y'')<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;openSet.Add&nbsp;y''&nbsp;|&gt;&nbsp;ignore<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meta.Add(y,&nbsp;y'')<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;openSet.Add&nbsp;y''&nbsp;|&gt;&nbsp;ignore)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;(),&nbsp;closedSet;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;search&nbsp;:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IGraph&lt;'a&gt;&nbsp;-&gt;&nbsp;'a&nbsp;-&gt;&nbsp;'a&nbsp;-&gt;&nbsp;'a&nbsp;list&nbsp;option&nbsp;*&nbsp;HashSet&lt;'a&gt;&nbsp;when&nbsp;'a&nbsp;:&nbsp;comparison</CODE></P>
      <P>Persistence was only used for the path itself so we leave this use of 
      an immutable data structure. This could also be optimized away by 
      replacing the list with back references and accumulating the path at the 
      end of the search.</P>
      <P>Resorting to mutable data structures dramatically improves the 
      performance of our implementation. The time taken for the Grand Canyon 
      example falls from 111s to 17.7s, over 6× faster.</P>
      <H2>Concrete graph implementation</H2>
      <P>Searching a graph for a shortest path requires a concrete 
      implementation of the abstract <CODE>IGraph&lt;_&gt;</CODE> interface and 
      an implementation of vertices. The following <CODE>Manhattan</CODE> module 
      defines <CODE>Vertex</CODE> and <CODE>Graph</CODE> types that represent 
      graphs over square grids of vertices, allowing traversal one square at a 
      time both along axes and diagonally:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;module&nbsp;Manhattan&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;Struct&gt;]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;CustomEquality&gt;]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;CustomComparison&gt;]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;Vertex(x:&nbsp;int,&nbsp;y:&nbsp;int)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;p.X&nbsp;=&nbsp;x<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;p.Y&nbsp;=&nbsp;y<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;p0.Equals&nbsp;p1&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;p1&nbsp;=&nbsp;(p1&nbsp;:?&gt;&nbsp;Vertex)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p0.X&nbsp;=&nbsp;p1.X&nbsp;&amp;&amp;&nbsp;p0.Y&nbsp;=&nbsp;p1.Y<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;p.GetHashCode()&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;+&nbsp;65536&nbsp;*&nbsp;y<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface&nbsp;System.IComparable&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;p0.CompareTo&nbsp;p1&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;p1&nbsp;=&nbsp;(p1&nbsp;:?&gt;&nbsp;Vertex)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;c&nbsp;=&nbsp;compare&nbsp;p0.X&nbsp;p1.X<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;c&lt;&gt;0&nbsp;then&nbsp;c&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compare&nbsp;p0.Y&nbsp;p1.Y<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;Struct&gt;]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;Graph(n:&nbsp;int,&nbsp;z:&nbsp;int&nbsp;*&nbsp;int&nbsp;-&gt;&nbsp;float)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface&nbsp;IGraph&lt;Vertex&gt;&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;g.distanceTo&nbsp;p0&nbsp;p1&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x0,&nbsp;y0,&nbsp;x1,&nbsp;y1&nbsp;=&nbsp;p0.X,&nbsp;p0.Y,&nbsp;p1.X,&nbsp;p1.Y<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x,&nbsp;y,&nbsp;z&nbsp;=&nbsp;float(x1-x0),&nbsp;float(y1-y0),&nbsp;float&nbsp;n&nbsp;*&nbsp;(z(x1,&nbsp;y1)&nbsp;-&nbsp;z(x0,&nbsp;y0))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqrt(x&nbsp;*&nbsp;x&nbsp;+&nbsp;y&nbsp;*&nbsp;y&nbsp;+&nbsp;z&nbsp;*&nbsp;z)<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;g.iterNeighbors&nbsp;p&nbsp;f&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dx&nbsp;=&nbsp;-1&nbsp;to&nbsp;1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dy&nbsp;=&nbsp;-1&nbsp;to&nbsp;1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x,&nbsp;y&nbsp;=&nbsp;p.X&nbsp;+&nbsp;dx,&nbsp;p.Y&nbsp;+&nbsp;dy<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(dx,dy)&nbsp;&lt;&gt;&nbsp;(0,0)&nbsp;&amp;&amp;&nbsp;x&nbsp;&gt;=&nbsp;0&nbsp;&amp;&amp;&nbsp;x&nbsp;&lt;&nbsp;n&nbsp;&amp;&amp;&nbsp;y&nbsp;&gt;=&nbsp;0&nbsp;&amp;&amp;&nbsp;y&nbsp;&lt;&nbsp;n&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f(Vertex(x,&nbsp;y));;<BR>&nbsp;&nbsp;&nbsp;&nbsp;module&nbsp;Manhattan&nbsp;=&nbsp;begin<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;Vertex&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface&nbsp;System.IComparable<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;:&nbsp;x:int&nbsp;*&nbsp;y:int&nbsp;-&gt;&nbsp;Vertex<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;Equals&nbsp;:&nbsp;p1:obj&nbsp;-&gt;&nbsp;bool<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;override&nbsp;GetHashCode&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;int<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;X&nbsp;:&nbsp;int<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;Y&nbsp;:&nbsp;int<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;Graph&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface&nbsp;IGraph&lt;Vertex&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;:&nbsp;n:int&nbsp;*&nbsp;z:(int&nbsp;*&nbsp;int&nbsp;-&gt;&nbsp;float)&nbsp;-&gt;&nbsp;Graph<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<BR>&nbsp;&nbsp;&nbsp;&nbsp;end</CODE></P>
      <P>We have used structs rather than classes in both cases because 
      inheritance is not required and using structs avoids a significant amount 
      of allocation.</P>
      <P>Note that we are careful to define a good <CODE>GetHashCode</CODE> 
      member for the <CODE>Vertex</CODE> type to ensure that values of this type 
      will work well with the <CODE>Dictionary</CODE> and <CODE>HashSet</CODE> 
      data structures used in the imperative implementation.</P>
      <H2>Visualization</H2>
      <P>We begin by referencing the DLLs required to use WPF and opening the 
      relevant namespace:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;#r&nbsp;"System.Xaml.dll";;<BR>&nbsp;&nbsp;&nbsp;&nbsp;--&gt;&nbsp;Referenced&nbsp;'C:\Program&nbsp;Files\Reference&nbsp;Assemblies\Microsoft\Framework\v3.0\<BR>&nbsp;&nbsp;&nbsp;&nbsp;System.Xaml.dll'<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;#r&nbsp;"PresentationCore.dll";;<BR>&nbsp;&nbsp;&nbsp;&nbsp;--&gt;&nbsp;Referenced&nbsp;'C:\Program&nbsp;Files\Reference&nbsp;Assemblies\Microsoft\Framework\v3.0\<BR>&nbsp;&nbsp;&nbsp;&nbsp;PresentationCore.dll'<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;#r&nbsp;"PresentationFramework.dll";;<BR>&nbsp;&nbsp;&nbsp;&nbsp;--&gt;&nbsp;Referenced&nbsp;'C:\Program&nbsp;Files\Reference&nbsp;Assemblies\Microsoft\Framework\v3.0\<BR>&nbsp;&nbsp;&nbsp;&nbsp;PresentationFramework.dll'<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;#r&nbsp;"WindowsBase.dll";;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;&nbsp;Referenced&nbsp;'C:\Program&nbsp;Files\Reference&nbsp;Assemblies\Microsoft\Framework\v3.0\<BR>&nbsp;&nbsp;&nbsp;&nbsp;WindowsBase.dll'<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;open&nbsp;System.Windows;;</CODE></P>
      <P>The following <CODE>load</CODE> function loads an image from a URI, 
      extracts the pixels as floating point numbers (a height map) and returns a 
      </P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;load&nbsp;uri&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;input&nbsp;=&nbsp;Media.Imaging.BitmapImage&nbsp;uri<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;w,&nbsp;h&nbsp;=&nbsp;input.PixelWidth,&nbsp;input.PixelHeight<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;n&nbsp;=&nbsp;min&nbsp;w&nbsp;h<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;bpp&nbsp;=&nbsp;input.Format.BitsPerPixel&nbsp;/&nbsp;8<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;pixel&nbsp;=&nbsp;Array.create&nbsp;(w&nbsp;*&nbsp;h&nbsp;*&nbsp;bpp)&nbsp;0uy<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input.CopyPixels(pixel,&nbsp;w&nbsp;*&nbsp;bpp,&nbsp;0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n,&nbsp;Array2D.init&nbsp;n&nbsp;n&nbsp;(fun&nbsp;i&nbsp;j&nbsp;-&gt;&nbsp;float&nbsp;pixel.[(i&nbsp;*&nbsp;w&nbsp;+&nbsp;j)*bpp]&nbsp;/&nbsp;255.0);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;load&nbsp;:&nbsp;System.Uri&nbsp;-&gt;&nbsp;int&nbsp;*&nbsp;float&nbsp;[,]</CODE></P>
      <P>The following <CODE>heat</CODE> function converts a single value in the 
      range 0..1 into three values in the range 0..1 representing the red, green 
      and blue components of a heat-map:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;heat&nbsp;z&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z,&nbsp;1.0&nbsp;-&nbsp;abs(z&nbsp;-&nbsp;0.5),&nbsp;1.0&nbsp;-&nbsp;z;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;heat&nbsp;:&nbsp;float&nbsp;-&gt;&nbsp;float&nbsp;*&nbsp;float&nbsp;*&nbsp;float</CODE></P>
      <P>The following <CODE>source</CODE> function creates an 
      <CODE>ImageSource</CODE> object from a height map and <CODE>visited</CODE> 
      function that determines whether or not each vertex in the graph had been 
      visited:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;source&nbsp;n&nbsp;(heightMap:&nbsp;_&nbsp;[,])&nbsp;visited&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;format&nbsp;=&nbsp;Media.PixelFormats.Rgb24<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;bpp&nbsp;=&nbsp;format.BitsPerPixel&nbsp;/&nbsp;8<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;pixel&nbsp;=&nbsp;Array.create&nbsp;(bpp&nbsp;*&nbsp;n&nbsp;*&nbsp;n)&nbsp;0uy<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i=0&nbsp;to&nbsp;n-1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;j=0&nbsp;to&nbsp;n-1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;r,&nbsp;g,&nbsp;b&nbsp;=&nbsp;heat&nbsp;heightMap.[i,&nbsp;j]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;f&nbsp;z&nbsp;=&nbsp;(255.0&nbsp;*&nbsp;z&nbsp;*&nbsp;if&nbsp;visited&nbsp;(Manhattan.Vertex(j,&nbsp;i))&nbsp;then&nbsp;1.0&nbsp;else&nbsp;0.5)&nbsp;|&gt;&nbsp;byte<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixel.[bpp*(i&nbsp;*&nbsp;n&nbsp;+&nbsp;j)]&nbsp;&lt;-&nbsp;f&nbsp;r<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixel.[bpp*(i&nbsp;*&nbsp;n&nbsp;+&nbsp;j)&nbsp;+&nbsp;1]&nbsp;&lt;-&nbsp;f&nbsp;g<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixel.[bpp*(i&nbsp;*&nbsp;n&nbsp;+&nbsp;j)&nbsp;+&nbsp;2]&nbsp;&lt;-&nbsp;f&nbsp;b<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Media.Imaging.BitmapSource.Create(n,&nbsp;n,&nbsp;1.0,&nbsp;1.0,&nbsp;format,&nbsp;null,&nbsp;pixel,&nbsp;bpp*n);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;source&nbsp;:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;[,]&nbsp;-&gt;&nbsp;ICollection&lt;Manhattan.Vertex&gt;&nbsp;-&gt;&nbsp;Media.Imaging.BitmapSource</CODE></P>
      <P>Finally, the following main program loads a suitable grayscale image, 
      computes a shortest path across it and visualizes the result using WPF as 
      an heat-map image of the height field with the path overlaid as a white 
      line:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&lt;System.STAThread&gt;]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;n,&nbsp;heightMap,&nbsp;height&nbsp;=&nbsp;load(System.Uri&nbsp;"grandcan.gif")<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;pts,&nbsp;closedSet&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;t&nbsp;=&nbsp;System.Diagnostics.Stopwatch.StartNew()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;graph&nbsp;=&nbsp;Manhattan.Graph(n,&nbsp;fun&nbsp;(x,&nbsp;y)&nbsp;-&gt;&nbsp;heightMap.[y,&nbsp;x])<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;pts&nbsp;=&nbsp;search&nbsp;graph&nbsp;(Manhattan.Vertex(0,&nbsp;n/3))&nbsp;(Manhattan.Vertex(n-1,&nbsp;2*n/3))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;"Took&nbsp;%gs\n"&nbsp;t.Elapsed.TotalSeconds<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pts<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;canvas&nbsp;=&nbsp;Controls.Canvas(Width=float&nbsp;n,&nbsp;Height=float&nbsp;n)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;add&nbsp;(x,&nbsp;y)&nbsp;elt&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controls.Canvas.SetLeft(elt,&nbsp;x)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controls.Canvas.SetTop(elt,&nbsp;y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;canvas.Children.Add&nbsp;elt&nbsp;|&gt;&nbsp;ignore<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;image&nbsp;=&nbsp;Controls.Image(Width=float&nbsp;n,&nbsp;Height=float&nbsp;n)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image.Source&nbsp;&lt;-&nbsp;source&nbsp;n&nbsp;heightMap&nbsp;closedSet.Contains<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;(0.0,&nbsp;0.0)&nbsp;image<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;pts&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;pts&nbsp;with<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;None&nbsp;-&gt;&nbsp;[]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Some&nbsp;pts&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;for&nbsp;p&nbsp;in&nbsp;pts&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point(float&nbsp;p.X,&nbsp;float&nbsp;p.Y)&nbsp;]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;path&nbsp;=&nbsp;Shapes.Polyline(Width=float&nbsp;n,&nbsp;Height=float&nbsp;n)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path.Points&nbsp;&lt;-&nbsp;Media.PointCollection&nbsp;pts<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path.Stroke&nbsp;&lt;-&nbsp;Media.Brushes.White<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path.StrokeThickness&nbsp;&lt;-&nbsp;1.0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;(0.5,&nbsp;0.5)&nbsp;path<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Window(Content=Controls.Viewbox(Child=canvas),&nbsp;Title="A*&nbsp;algorithm")<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Application().Run<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;ignore</CODE></P>
      <P>Previous articles have visualized either vector graphics or images but 
      the program in this articles combines an image with a vector overlay by 
      using the <CODE>Canvas</CODE> control to lay out the components. In 
      particular, note how the width and height of the components on the canvas 
      must be defined.</P>
      <H2>Results</H2>
      <P>The following screenshot shows the shortest path (the white line) found 
      by this program across the Grand Canyon:</P>
      <P style="text-align: center;"><IMG src="F%23%20Journal%20The%20A%20algorithm_files/canyon.png"></P>
      <P>Color is used to convey the height and the region searched is shown 
      brighter. Dijkstra's algorithm would have searched almost every vertex in 
      the entire graph because the shortest path spans the entire graph. The 
      much smaller region searched by the A* algorithm in this case clearly 
      illustrates how much of the search was culled.</P>
      <H2>Summary</H2>
      <P>This article has described two implementations of the A* algorithm in 
      F#, one simple and one efficient, and a route-finding example that 
      illustrates not only how efficient this algorithm is over a brute-force 
      solution such as Dijkstra's algorithm but also how elegantly and 
      succinctly this problem can be both solved and visualized using F#.</P>
      <P>Future F#.NET Journal articles will revisit the subjects of route 
      finding, game AI and visualization.</P></TD></TR></TBODY></TABLE>
<TABLE id="footer">
  <TBODY>
  <TR>
    <TD>© Flying Frog Consultancy Ltd., 2010</TD>
    <TD>Contact the            <A 
      href="mailto:webmaster@ffconsultancy.com">webmaster</A>         
  </TD></TR></TBODY></TABLE>
<SCRIPT src="F%23%20Journal%20The%20A%20algorithm_files/urchin.js" type="text/javascript">
    <script type="text/javascript">_uacct = "UA-197840-1"; urchinTracker();</SCRIPT>
   </BODY></HTML>
