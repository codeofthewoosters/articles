<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
  <head>
    <title>F# Journal</title>
    <link rel="stylesheet" type="text/css" href="../../../style.css"/>
    <link rel="stylesheet" type="text/css" href="../../style.css"/>
    <link rel="stylesheet" type="text/css" href="../../../individual.css"/>
  </head>
  <body>
    <table id="logo">
      <tr>
        <td width="100%">
          <img src="../../../images/title.gif"/>
        </td>
        <td>
          <img src="../../../images/left.gif"/>
        </td>
      </tr>
    </table>
    <table id="menu">
      <tr>
        <td width="25%"/>
        <td width="25%">
          <a href="../../index.html">Home Page</a>
        </td>
        <td width="25%">
          <a href="index.html">The F# Journal</a>
        </td>
        <td width="25%"/>
      </tr>
    </table>
    <table id="page">
      <tr>
        <td><h1>Sliding averages</h1><p>Sliding window algorithms are a class of algorithms that treat streams of data by computing a statistic across a window for each position of the window within the data stream. Moving averages are sliding window algorithms that compute an average over each window. This article begins with a simple implementation of the sliding mean average and goes on to examine more efficient algorithms for both mean and median sliding averages.</p><h2>Introduction</h2><p>Sliding window algorithms are commonly used to study medium-range effects in data. Perhaps the most influential sliding window algorithm is the foundation of the graphic equalizer: a primitive method of time-frequency analysis called the Windowed Fourier Transform (WFT) that computes the FFTs of windows at different positions within a signal in order to estimate the frequencies present at a given point in time. This article examines the simpler but still tricky problem of sliding averages.</p><h3>Simple solutions</h3><p>Luckily, F# provides an easy way to break a sequence into a sequence of fixed-width windows in the form of the <code>Seq.windowed</code> function:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;xs&nbsp;=&nbsp;[0.0;&nbsp;1.0;&nbsp;0.0;&nbsp;-1.0;&nbsp;0.0;&nbsp;1.0;&nbsp;0.0;&nbsp;-1.0];;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;xs&nbsp;:&nbsp;float&nbsp;list&nbsp;=&nbsp;[0.0;&nbsp;1.0;&nbsp;0.0;&nbsp;-1.0;&nbsp;0.0;&nbsp;1.0;&nbsp;0.0;&nbsp;-1.0]<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;Seq.windowed&nbsp;2&nbsp;xs;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;seq&lt;float&nbsp;[]&gt;&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq&nbsp;[[|0.0;&nbsp;1.0|];&nbsp;[|1.0;&nbsp;0.0|];&nbsp;[|0.0;&nbsp;-1.0|];&nbsp;[|-1.0;&nbsp;0.0|];&nbsp;...]</code></p><p>Note how the sequence was broken up into windows containing two elements each. This is not the same as dividing the input into <code>n/2</code> subsequences because the window is slid across the input one element at a time.</p><p>Sliding averages are easily computed using the <code>Seq.windowed</code> function. The sliding mean may be computed by applying the <code>Seq.average</code> function to each subsequence using a configurable window width <code>n</code> as follows:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;slidingMean&nbsp;n&nbsp;(xs:&nbsp;float&nbsp;seq)&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xs<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Seq.windowed&nbsp;n<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Seq.map&nbsp;Seq.average;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;slidingMean&nbsp;:&nbsp;int&nbsp;-&gt;&nbsp;seq&lt;float&gt;&nbsp;-&gt;&nbsp;seq&lt;float&gt;</code></p><p>Note that is it necessary to annotate the type of this function because the built-in functions are generic over any numeric types that provide the appropriate operations.</p><p>For example, applying <code>slidingMean</code> to our example data set <code>xs</code> produces a downsampling of the data where consecutive pairs of elements have been averaged together.</p><p>The genericity may be preserved by marking the <code>slidingMean</code> function <code>inline</code> as follows:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;inline&nbsp;slidingMean&nbsp;xs&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xs<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Seq.windowed&nbsp;10<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Seq.map&nbsp;Seq.average;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;inline&nbsp;slidingMean&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq&lt;&nbsp;^a&gt;&nbsp;-&gt;&nbsp;seq&lt;&nbsp;^a&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when&nbsp;&nbsp;^a&nbsp;:&nbsp;(static&nbsp;member&nbsp;(&nbsp;+&nbsp;)&nbsp;:&nbsp;&nbsp;^a&nbsp;*&nbsp;&nbsp;^a&nbsp;-&gt;&nbsp;&nbsp;^a)&nbsp;and<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^a&nbsp;:&nbsp;(static&nbsp;member&nbsp;DivideByInt&nbsp;:&nbsp;&nbsp;^a&nbsp;*&nbsp;int&nbsp;-&gt;&nbsp;&nbsp;^a)&nbsp;and<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^a&nbsp;:&nbsp;(static&nbsp;member&nbsp;get_Zero&nbsp;:&nbsp;-&gt;&nbsp;&nbsp;^a)</code></p><p>Similarly, the simplest way to compute the moving median for a data set is to explicitly extract the array of elements in each window, sort them and extract the median from the center of the resulting array. A function to compute the median of a sequence may be written in F# as follows:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;median&nbsp;xs&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;xs&nbsp;=&nbsp;Array.ofSeq&nbsp;xs<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;n&nbsp;=&nbsp;xs.Length<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array.sortInPlaceWith&nbsp;compare&nbsp;xs<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;n&nbsp;%&nbsp;2&nbsp;=&nbsp;1&nbsp;then&nbsp;xs.[n/2]&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(xs.[n/2]&nbsp;+&nbsp;xs.[n/2&nbsp;-&nbsp;1])&nbsp;/&nbsp;2.0;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;median&nbsp;:&nbsp;seq&lt;float&gt;&nbsp;-&gt;&nbsp;float</code></p><p>A function to compute the sliding median can then map this <code>median</code> function over the windows:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;slidingMedian&nbsp;n&nbsp;xs&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xs<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Seq.windowed&nbsp;n<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Seq.map&nbsp;median;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;slidingMedian&nbsp;:&nbsp;int&nbsp;-&gt;&nbsp;seq&lt;float&gt;&nbsp;-&gt;&nbsp;seq&lt;float&gt;</code></p><p>However, the main weakness of these implementations of sliding averages is that they fail to reuse computations from each window to the next and, consequently, perform many redundant calculations and could be much more efficient. As these kinds of statistical averages are often applied to large data sets there is great value in optimizing these algorithms in order to reduce the amount of time it takes to compute a sliding average.</p><p>For example, the following constructs an example data set that we can use to benchmark our solutions:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;example&nbsp;=&nbsp;Array.init&nbsp;100000&nbsp;(fun&nbsp;i&nbsp;-&gt;&nbsp;tan(float&nbsp;i&nbsp;/&nbsp;1000.0));;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;example&nbsp;:&nbsp;float&nbsp;[]&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|0.0;&nbsp;0.001000000333;&nbsp;0.002000002667;&nbsp;0.003000009;&nbsp;0.004000021333;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.005000041667;&nbsp;0.006000072001;&nbsp;0.007000114336;&nbsp;0.008000170671;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.009000243008;&nbsp;0.01000033335;&nbsp;0.01100044369;&nbsp;0.01200057603;&nbsp;0.01300073238;</code></p><p>In this case, the naive <code>slidingMedian</code> function takes 73s:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;xys&nbsp;=&nbsp;slidingMedian&nbsp;1000&nbsp;example&nbsp;|&gt;&nbsp;Array.ofSeq;;<br />&nbsp;&nbsp;&nbsp;&nbsp;Real:&nbsp;00:01:12.965,&nbsp;CPU:&nbsp;00:02:06.594,&nbsp;GC&nbsp;gen0:&nbsp;1626,&nbsp;gen1:&nbsp;1618,&nbsp;gen2:&nbsp;1618<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;xys&nbsp;:&nbsp;float&nbsp;[]&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|0.5456536209;&nbsp;0.5469520681;&nbsp;0.5482519365;&nbsp;0.549553231;&nbsp;0.5508559565;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5521601181;&nbsp;0.5534657206;&nbsp;0.5547727692;&nbsp;0.5560812688;&nbsp;0.5573912245;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5587026413;&nbsp;0.5600155243;&nbsp;0.5613298787;&nbsp;0.5626457094;&nbsp;0.5639630216;</code></p><p>Naturally, we can optimize this simple solution in order to improve its performance.</p><h2>Algorithmic optimization</h2><p>As always, the first step towards a usefully-efficient implementation is to attempt algorithmic optimizations. This requires us to think about the operations being performed and how the most common operations might be made more efficient.</p><p>The core inefficiency of the naive algorithm is that it fails to capitalize on the relationship between the median of one window and the median of the next window. The median splits the set of values in the window in half, with 50% of the values appearing below the median and 50% above. The simplest way to represent this in F# is to maintain a pair of sets for the lower and upper halves of the window and rebalance the sets to keep them the same size as new elements are added into the window and removed from the back of the window. This is complicated by the fact that the built-in <code>Set</code> data structure removes duplicates but we want to allow them. There are several possible solutions to this, including implementing a multiset data structure, but we can work around the issue most simply by storing not only the value from the stream in the set but also its index, i.e. a pair.</p><p>The following <code>balance</code> function uses the <code>Set.count</code> function of the sets to determine the number of elements in each set and moves the smallest element in the upper set or the largest element from the lower set across in order to balance the sets such that the number of elements in the lower set is either equal to or one greater than that of the upper set:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;balance&nbsp;(lt,&nbsp;gt)&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;dn&nbsp;=&nbsp;Set.count&nbsp;gt&nbsp;-&nbsp;Set.count&nbsp;lt<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;dn&nbsp;&gt;&nbsp;0&nbsp;then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;y&nbsp;=&nbsp;Set.minElement&nbsp;gt<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set.add&nbsp;y&nbsp;lt,&nbsp;Set.remove&nbsp;y&nbsp;gt<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;dn&nbsp;&lt;&nbsp;-1&nbsp;then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x&nbsp;=&nbsp;Set.maxElement&nbsp;lt<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set.remove&nbsp;x&nbsp;lt,&nbsp;Set.add&nbsp;x&nbsp;gt<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lt,&nbsp;gt;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;balance&nbsp;:&nbsp;Set&lt;'a&gt;&nbsp;*&nbsp;Set&lt;'a&gt;&nbsp;-&gt;&nbsp;Set&lt;'a&gt;&nbsp;*&nbsp;Set&lt;'a&gt;&nbsp;when&nbsp;'a&nbsp;:&nbsp;comparison</code></p><p>The following <code>median</code> function determines the median of the union of the two sets either as the largest element in the lower set (for an odd number of elements in the window) or as an average of the two middle elements:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;median&nbsp;(lt,&nbsp;gt)&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x,&nbsp;_&nbsp;=&nbsp;Set.maxElement&nbsp;lt<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;Set.count&nbsp;lt&nbsp;&gt;&nbsp;Set.count&nbsp;gt&nbsp;then&nbsp;x&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x&nbsp;+&nbsp;fst(Set.minElement&nbsp;gt))&nbsp;/&nbsp;2.0;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;median&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set&lt;float&nbsp;*&nbsp;'a&gt;&nbsp;*&nbsp;Set&lt;float&nbsp;*&nbsp;'b&gt;&nbsp;-&gt;&nbsp;float<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when&nbsp;'a&nbsp;:&nbsp;comparison&nbsp;and&nbsp;'b&nbsp;:&nbsp;comparison</code></p><p>Before writing a function to implement the sliding median we shall write a pair of auxiliary functions to insert an element into our pair of sets when it enters the sliding window and another function to remove an element from our pair of sets when it leaves the sliding window.</p><p>An <code>add</code> function to insert an element may be written as follows:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;add&nbsp;x&nbsp;(lt,&nbsp;gt)&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;Set.isEmpty&nbsp;lt&nbsp;then&nbsp;lt,&nbsp;Set.add&nbsp;x&nbsp;gt<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;x&nbsp;&lt;=&nbsp;Set.maxElement&nbsp;lt&nbsp;then&nbsp;Set.add&nbsp;x&nbsp;lt,&nbsp;gt<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;lt,&nbsp;Set.add&nbsp;x&nbsp;gt<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;balance;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;add&nbsp;:&nbsp;'a&nbsp;-&gt;&nbsp;Set&lt;'a&gt;&nbsp;*&nbsp;Set&lt;'a&gt;&nbsp;-&gt;&nbsp;Set&lt;'a&gt;&nbsp;*&nbsp;Set&lt;'a&gt;&nbsp;when&nbsp;'a&nbsp;:&nbsp;comparison</code></p><p>If the set <code>lt</code> of elements less than or equal to the median is empty then the new element is inserted into the set of elements greater than or equal to the median. Otherwise the new element is compared with the largest element from the smaller set and inserted into either the lower or upper set accordingly. Finally, the <code>balance</code> function is used to rebalance the two sets once the new element has been added.</p><p>The <code>remove</code> function to remove an element from the sets is much simpler:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;remove&nbsp;x&nbsp;(lt,&nbsp;gt)&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance(Set.remove&nbsp;x&nbsp;lt,&nbsp;Set.remove&nbsp;x&nbsp;gt);;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;remove&nbsp;:&nbsp;'a&nbsp;-&gt;&nbsp;Set&lt;'a&gt;&nbsp;*&nbsp;Set&lt;'a&gt;&nbsp;-&gt;&nbsp;Set&lt;'a&gt;&nbsp;*&nbsp;Set&lt;'a&gt;&nbsp;when&nbsp;'a&nbsp;:&nbsp;comparison</code></p><p>This relies upon the <code>Set.remove</code> function returning the original set if the given element could not be found.</p><p>Finally, the following <code>slidingMedian</code> function computes the sliding median average over a given sequence using the given window width:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;slidingMedian&nbsp;n&nbsp;xs&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq&nbsp;{&nbsp;let&nbsp;window&nbsp;=&nbsp;System.Collections.Generic.Queue()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;s&nbsp;=&nbsp;ref(Set.empty,&nbsp;Set.empty)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;xs&nbsp;|&gt;&nbsp;Seq.mapi&nbsp;(fun&nbsp;i&nbsp;x&nbsp;-&gt;&nbsp;x,&nbsp;i)&nbsp;do<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;window.Count&nbsp;&lt;&nbsp;n&nbsp;then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;:=&nbsp;add&nbsp;x&nbsp;!s<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.Enqueue&nbsp;x<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;window.Count&nbsp;=&nbsp;n&nbsp;then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;median&nbsp;!s<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;y&nbsp;=&nbsp;window.Dequeue()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;:=&nbsp;add&nbsp;x&nbsp;(remove&nbsp;y&nbsp;!s)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;median&nbsp;!s<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.Enqueue&nbsp;x&nbsp;};;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;slidingMedian&nbsp;:&nbsp;int&nbsp;-&gt;&nbsp;seq&lt;float&gt;&nbsp;-&gt;&nbsp;seq&lt;float&gt;</code></p><p>In this case, we use a sequence expression to provide an elegant way to generate medians on-the-fly. A mutable queue is used to track the elements in the current window, in order to remove elements as they fall out of the window. The <code>Seq.mapi</code> function is used to convert the sequence of input values into value and index pairs to ensure that the elements stored in the F# <code>Set</code> collections are always unique. The input elements are iterated over using a <code>for</code> comprehension, adding new elements to the window until it fills whereupon the last element is also dequeued in order to maintain a constant length <code>n</code> window. Nothing is yielded from the sequence expression while the window is fulling but a single element is yielded when the window is first full and then an element is yielded for each new element from the input sequence.</p><p>This implementation of the <code>slidingMedian</code> function is almost 9&#215; faster than the previous implementation thanks to the algorithmic optimization of tracking just the changes in the median as the window is slid across the input sequence rather than recomputing each median separately:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;slidingMedian&nbsp;1000&nbsp;example<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Array.ofSeq;;<br />&nbsp;&nbsp;&nbsp;&nbsp;Real:&nbsp;00:00:08.350,&nbsp;CPU:&nbsp;00:00:08.346,&nbsp;GC&nbsp;gen0:&nbsp;87,&nbsp;gen1:&nbsp;2,&nbsp;gen2:&nbsp;1<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;float&nbsp;[]&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|0.5456536209;&nbsp;0.5469520681;&nbsp;0.5482519365;&nbsp;0.549553231;&nbsp;0.5508559565;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5521601181;&nbsp;0.5534657206;&nbsp;0.5547727692;&nbsp;0.5560812688;&nbsp;0.5573912245;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5587026413;&nbsp;0.5600155243;&nbsp;0.5613298787;&nbsp;0.5626457094;&nbsp;0.5639630216;</code></p><p>Further performance improvements can be obtained by applying low-level optimizations to the solution in order to reduce the constant factor in the algorithmic complexity.</p><h2>Low-level optimization</h2><p>The program can be optimized further by fine tuning the way in which it is implemented in order to improve performance by a significant constant factor. We begin by defining a struct type <code>T2</code> to hold a pair of values unboxed, to replace our previous use of a tuple:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;[&lt;Struct&gt;]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;T2&lt;'a,&nbsp;'b&gt;&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;a&nbsp;:&nbsp;'a<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;b&nbsp;:&nbsp;'b<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new(a,&nbsp;b)&nbsp;=&nbsp;{a=a;&nbsp;b=b};;<br />&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;T2&lt;'a,'b&gt;&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;:&nbsp;a:'a&nbsp;*&nbsp;b:'b&nbsp;-&gt;&nbsp;T2&lt;'a,'b&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;a:&nbsp;'a<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;b:&nbsp;'b<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</code></p><p>Next, we replace each of the <code>balance</code>, <code>median</code>, <code>add</code> and <code>remove</code> functions with equivalents using the mutable <code>SortedSet</code> collection provided by .NET instead of the purely functional <code>Set</code> collection provided by F#. The <code>balance</code> function becomes:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;balance&nbsp;(lt:&nbsp;SortedSet&lt;_&gt;,&nbsp;gt:&nbsp;SortedSet&lt;_&gt;)&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;dn&nbsp;=&nbsp;gt.Count&nbsp;-&nbsp;lt.Count<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;dn&nbsp;&gt;&nbsp;0&nbsp;then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x&nbsp;=&nbsp;gt.Min<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lt.Add&nbsp;x&nbsp;|&gt;&nbsp;ignore<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gt.Remove&nbsp;x&nbsp;|&gt;&nbsp;ignore<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;dn&nbsp;&lt;&nbsp;-1&nbsp;then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x&nbsp;=&nbsp;lt.Max<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lt.Remove&nbsp;x&nbsp;|&gt;&nbsp;ignore<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gt.Add&nbsp;x&nbsp;|&gt;&nbsp;ignore;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;balance&nbsp;:&nbsp;SortedSet&lt;'a&gt;&nbsp;*&nbsp;SortedSet&lt;'a&gt;&nbsp;-&gt;&nbsp;unit</code></p><p>The <code>median</code> function becomes:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;median&nbsp;(lt:&nbsp;SortedSet&lt;T2&lt;_,&nbsp;_&gt;&gt;,&nbsp;gt:&nbsp;SortedSet&lt;T2&lt;_,&nbsp;_&gt;&gt;)&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x&nbsp;=&nbsp;lt.Max.a<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;lt.Count&nbsp;&gt;&nbsp;gt.Count&nbsp;then&nbsp;x&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x&nbsp;+&nbsp;gt.Min.a)&nbsp;/&nbsp;2.0;;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;median&nbsp;:&nbsp;SortedSet&lt;T2&lt;float,'a&gt;&gt;&nbsp;*&nbsp;SortedSet&lt;T2&lt;float,'b&gt;&gt;&nbsp;-&gt;&nbsp;float</code></p><p>The <code>add</code> function becomes:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;add&nbsp;x&nbsp;(lt:&nbsp;SortedSet&lt;_&gt;,&nbsp;gt:&nbsp;SortedSet&lt;_&gt;)&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;lt.Count&nbsp;=&nbsp;0&nbsp;||&nbsp;x&nbsp;&gt;&nbsp;lt.Max&nbsp;then&nbsp;gt.Add&nbsp;x&nbsp;|&gt;&nbsp;ignore&nbsp;else&nbsp;lt.Add&nbsp;x&nbsp;|&gt;&nbsp;ignore<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance&nbsp;(lt,&nbsp;gt);;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;add&nbsp;:&nbsp;'a&nbsp;-&gt;&nbsp;SortedSet&lt;'a&gt;&nbsp;*&nbsp;SortedSet&lt;'a&gt;&nbsp;-&gt;&nbsp;unit&nbsp;when&nbsp;'a&nbsp;:&nbsp;comparison</code></p><p>The <code>remove</code> function becomes:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;remove&nbsp;x&nbsp;(lt:&nbsp;SortedSet&lt;_&gt;,&nbsp;gt:&nbsp;SortedSet&lt;_&gt;)&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lt.Remove&nbsp;x&nbsp;|&gt;&nbsp;ignore<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gt.Remove&nbsp;x&nbsp;|&gt;&nbsp;ignore<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance&nbsp;(lt,&nbsp;gt);;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;remove&nbsp;:&nbsp;'a&nbsp;-&gt;&nbsp;SortedSet&lt;'a&gt;&nbsp;*&nbsp;SortedSet&lt;'a&gt;&nbsp;-&gt;&nbsp;unit</code></p><p>Note that all of these functions now require type annotations because we are using members to add and remove elements rather than calling a static function with a known type.</p><p>Now we are ready to replace the <code>slidingMedian</code> function itself:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;slidingMedian&nbsp;n&nbsp;xs&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq&nbsp;{&nbsp;let&nbsp;window&nbsp;=&nbsp;System.Collections.Generic.Queue()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;lt,&nbsp;gt&nbsp;=&nbsp;SortedSet(),&nbsp;SortedSet()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;xs&nbsp;|&gt;&nbsp;Seq.mapi&nbsp;(fun&nbsp;i&nbsp;x&nbsp;-&gt;&nbsp;T2(x,&nbsp;i))&nbsp;do<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;window.Count&nbsp;&lt;&nbsp;n&nbsp;then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;x&nbsp;(lt,&nbsp;gt)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.Enqueue&nbsp;x<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;window.Count&nbsp;=&nbsp;n&nbsp;then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;median&nbsp;(lt,&nbsp;gt)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;y&nbsp;=&nbsp;window.Dequeue()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;y&nbsp;(lt,&nbsp;gt)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;x&nbsp;(lt,&nbsp;gt)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;median&nbsp;(lt,&nbsp;gt)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.Enqueue&nbsp;x&nbsp;};;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;slidingMedian&nbsp;:&nbsp;int&nbsp;-&gt;&nbsp;seq&lt;float&gt;&nbsp;-&gt;&nbsp;seq&lt;float&gt;</code></p><p>The changes are remarkably small. The <code>SortedSet</code> constructor is used to initialize the collections instead of using the <code>Set.empty</code> value.</p><p>Thanks to the use of mutable collections, this new version is over 3.3&#215; faster again:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;slidingMedian&nbsp;1000&nbsp;example<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Array.ofSeq;;<br />&nbsp;&nbsp;&nbsp;&nbsp;Real:&nbsp;00:00:02.498,&nbsp;CPU:&nbsp;00:00:02.355,&nbsp;GC&nbsp;gen0:&nbsp;99,&nbsp;gen1:&nbsp;1,&nbsp;gen2:&nbsp;1<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;float&nbsp;[]&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|0.5456536209;&nbsp;0.5469520681;&nbsp;0.5482519365;&nbsp;0.549553231;&nbsp;0.5508559565;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5521601181;&nbsp;0.5534657206;&nbsp;0.5547727692;&nbsp;0.5560812688;&nbsp;0.5573912245;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5587026413;&nbsp;0.5600155243;&nbsp;0.5613298787;&nbsp;0.5626457094;&nbsp;0.5639630216;</code></p><p>The same basic technique of exploiting redundancy between computations using algorithmic optimizations and then applying low-level optimizations such as avoiding allocations is a powerful way to create production-quality solutions to such problems.</p><h2>Summary</h2><p>This article has described a generic approach for solving sliding window problems easily and efficiently. The trick is to compute the small changes in the median from one window to the next rather than recomputing each result from scratch.</p><p>Future F#.NET Journal articles will revisit the subject of semi-numerical algorithms.</p>        </td>
      </tr>
    </table>
    <table id="footer">
      <tr>
        <td>&copy; Flying Frog Consultancy Ltd., 2010</td>
        <td>
Contact the 
          <a href="mailto:webmaster@ffconsultancy.com">webmaster</a>
        </td>
      </tr>
    </table>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"/>
    <script type="text/javascript">_uacct = "UA-197840-1"; urchinTracker();</script>
  </body>
</html>
