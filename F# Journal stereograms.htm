<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0081)http://www.ffconsultancy.com/products/fsharp_journal/subscribers/stereograms.html -->
<HTML><HEAD><META content="IE=7.0000" http-equiv="X-UA-Compatible">
<TITLE>F# Journal</TITLE>
<META content="text/html; charset=windows-1252" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="F%23%20Journal%20stereograms_files/style.css"><LINK rel=stylesheet 
type=text/css href="F%23%20Journal%20stereograms_files/style(1).css"><LINK 
rel=stylesheet type=text/css 
href="F%23%20Journal%20stereograms_files/individual.css">
<META name=GENERATOR content="MSHTML 10.00.9200.16458"></HEAD>
<BODY>
<TABLE id=logo>
  <TBODY>
  <TR>
    <TD width="100%"><IMG src="F%23%20Journal%20stereograms_files/title.gif"> 
    </TD>
    <TD><IMG src="F%23%20Journal%20stereograms_files/left.gif"> 
</TD></TR></TBODY></TABLE>
<TABLE id=menu>
  <TBODY>
  <TR>
    <TD width="25%">
    <TD width="25%"><A 
      href="http://www.ffconsultancy.com/products/index.html">Home Page</A> </TD>
    <TD width="25%"><A 
      href="http://www.ffconsultancy.com/products/fsharp_journal/subscribers/index.html">The 
      F# Journal</A> </TD>
    <TD width="25%"></TD></TR></TBODY></TABLE>
<TABLE id=page>
  <TBODY>
  <TR>
    <TD>
      <H1>Rendering autostereograms</H1>
      <P>An autostereogram is a tiling distorted such that the differences 
      between one column of tiles and the next simulate the differences between 
      images seen by the left and right eyes when viewing a 3D scene. This 
      allows a practiced viewer to stare through the picture such that their 
      eyes view the stereogram offset by a single column of tiles and, 
      therefore, they perceive the image to be 3D. This article describes a 
      simple technique that allows autostereograms to be generated by a 
      parallelized F# program.</P>
      <P>We begin by referencing the four assemblies required by WPF 
      applications:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;#r&nbsp;"PresentationCore.dll";;<BR>&nbsp;&nbsp;&nbsp;&nbsp;--&gt;&nbsp;Referenced&nbsp;'C:\Program&nbsp;Files\Reference&nbsp;Assemblies\Microsoft\Framework\v3.0\PresentationCore.dll'<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;#r&nbsp;"PresentationFramework.dll";;<BR>&nbsp;&nbsp;&nbsp;&nbsp;--&gt;&nbsp;Referenced&nbsp;'C:\Program&nbsp;Files\Reference&nbsp;Assemblies\Microsoft\Framework\v3.0\PresentationFramework.dll'<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;#r&nbsp;"System.Xaml.dll";;<BR>&nbsp;&nbsp;&nbsp;&nbsp;--&gt;&nbsp;Referenced&nbsp;'C:\windows\Microsoft.NET\Framework\v4.0.30319\System.Xaml.dll'<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;#r&nbsp;"WindowsBase.dll";;<BR>&nbsp;&nbsp;&nbsp;&nbsp;--&gt;&nbsp;Referenced&nbsp;'C:\Program&nbsp;Files\Reference&nbsp;Assemblies\Microsoft\Framework\v3.0\WindowsBase.dll'</CODE></P>
      <P>The program will use many definitions from the 
      <CODE>System.Windows</CODE> namespace so we begin by opening it:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;open&nbsp;System.Windows;;</CODE></P>
      <P>The width and height of the individual tiles is given by the following 
      <CODE>size</CODE> parameter:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;size&nbsp;=&nbsp;75;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;size&nbsp;:&nbsp;int&nbsp;=&nbsp;75</CODE></P>
      <P>The number of rows of tiles down the image is given by the following 
      <CODE>repeats</CODE> parameter:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;repeats&nbsp;=&nbsp;5;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;repeats&nbsp;:&nbsp;int&nbsp;=&nbsp;5</CODE></P>
      <P>The following <CODE>gray</CODE> function rescales a floating point 
      number expected to by in the range [0,1] to a byte, clamping the result in 
      order to handle out-of-range values:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;gray&nbsp;x&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;128.0&nbsp;*&nbsp;x&nbsp;+&nbsp;128.0&nbsp;|&gt;&nbsp;max&nbsp;0.0&nbsp;|&gt;&nbsp;min&nbsp;255.0&nbsp;|&gt;&nbsp;byte;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;gray&nbsp;:&nbsp;float&nbsp;-&gt;&nbsp;byte</CODE></P>
      <P>A common problem with early autostereogram generators was accidental 
      quantization of the depth. These discrete depths were often clearly 
      visible to the viewer and gave the autostereogram an 
      unnecessarily-synthetic appearance. The origin of the quantization was the 
      use of low resolution tiles. The distances from the same point on one tile 
      to the next can then only be an integral number of pixels and this 
      distance determines the perceived depth which is, therefore, quantized. 
      The simplest solution to this problem is to replace the bitmap 
      representation of a tile with a function, effectively making the 
      resolution infinite and, therefore, eliminating the quantization. The 
      simplest tiling functions are Fourier series.</P>
      <P>The following defines an array <CODE>ds</CODE> of colors and 
      wavevectors that will be used to compute the color at any point on a tile 
      without quantization due to fixed resolution:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;ds&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rand&nbsp;=&nbsp;System.Random();;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|for&nbsp;dx&nbsp;in&nbsp;-3.0..3.0&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;dy&nbsp;in&nbsp;-3.0..3.0&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;dx&lt;&gt;0.0&nbsp;||&nbsp;dy&lt;&gt;0.0&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;d&nbsp;=&nbsp;sqrt(dx*dx&nbsp;+&nbsp;dy*dy)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;Array.init&nbsp;3&nbsp;(fun&nbsp;_&nbsp;-&gt;&nbsp;d&nbsp;*&nbsp;exp(-d/10.0)&nbsp;*&nbsp;rand.NextDouble()),&nbsp;dx,&nbsp;dy|];;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;ds&nbsp;:&nbsp;(float&nbsp;[]&nbsp;*&nbsp;float&nbsp;*&nbsp;float)&nbsp;[]&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|([|1.328390891;&nbsp;1.213586188;&nbsp;2.403107807|],&nbsp;-3.0,&nbsp;-3.0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([|1.845402782;&nbsp;0.1797820848;&nbsp;0.481707461|],&nbsp;-3.0,&nbsp;-2.0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([|1.562788973;&nbsp;1.057728908;&nbsp;0.2128285068|],&nbsp;-3.0,&nbsp;-1.0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([|0.5434150051;&nbsp;0.8609366094;&nbsp;0.8125586158|],&nbsp;-3.0,&nbsp;0.0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([|1.47256067;&nbsp;2.033820394;&nbsp;1.421215889|],&nbsp;-3.0,&nbsp;1.0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...|]</CODE></P>
      <P>The following <CODE>tile</CODE> function computes the color of the tile 
      at a given <CODE>x,y</CODE> coordinate by summing the contributions of the 
      waves:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;tile&nbsp;x&nbsp;y&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;sin&nbsp;x&nbsp;=&nbsp;sin(2.0&nbsp;*&nbsp;System.Math.PI&nbsp;*&nbsp;x&nbsp;/&nbsp;float&nbsp;size)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;wave&nbsp;i&nbsp;(c:&nbsp;_&nbsp;[],&nbsp;dx,&nbsp;dy)&nbsp;=&nbsp;c.[i]&nbsp;*&nbsp;sin(float&nbsp;dx&nbsp;*&nbsp;x&nbsp;+&nbsp;float&nbsp;dy&nbsp;*&nbsp;y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array.init&nbsp;3&nbsp;(fun&nbsp;i&nbsp;-&gt;&nbsp;ds&nbsp;|&gt;&nbsp;Array.sumBy&nbsp;(wave&nbsp;i)&nbsp;|&gt;&nbsp;gray);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;tile&nbsp;:&nbsp;float&nbsp;-&gt;&nbsp;float&nbsp;-&gt;&nbsp;byte&nbsp;[]</CODE></P>
      <P>The sum can easy extend beyond the range [0,1] so the <CODE>gray</CODE> 
      function clamps the values, saturating the colors.</P>
      <P>The following <CODE>depth</CODE> function defines the depth of the 
      image at a given <CODE>x,y</CODE> coordinate:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;depth&nbsp;x&nbsp;y&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;r&nbsp;=&nbsp;x*x&nbsp;+&nbsp;y*y<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-3.0&nbsp;*&nbsp;cos(0.15&nbsp;*&nbsp;sqrt&nbsp;r)&nbsp;*&nbsp;exp(-r/5000.0);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;depth&nbsp;:&nbsp;float&nbsp;-&gt;&nbsp;float&nbsp;-&gt;&nbsp;float</CODE></P>
      <P>In this case, we use a cosine wave emanating from the center of the 
      image with a Gaussian envelope to attenuate the waves further from the 
      center.</P>
      <P>The following <CODE>nest</CODE> function nests <CODE>n</CODE> 
      applications of the function <CODE>f</CODE> around the value 
      <CODE>x</CODE>:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;nest&nbsp;n&nbsp;f&nbsp;x&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;n=0&nbsp;then&nbsp;x&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nest&nbsp;(n-1)&nbsp;f&nbsp;(f&nbsp;x);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;nest&nbsp;:&nbsp;int&nbsp;-&gt;&nbsp;('a&nbsp;-&gt;&nbsp;'a)&nbsp;-&gt;&nbsp;'a&nbsp;-&gt;&nbsp;'a</CODE></P>
      <P>This will be used to accumulate the required horizontal displacement 
      over several tiles.</P>
      <P>The following <CODE>stereogram</CODE> function computes the color of 
      the stereogram at the given coordinate by nesting several displacements 
      and adjusting the result by an offset that focusses the distortion on the 
      center of the image (otherwise the right-hand side of the image can become 
      severely distorted because every pixel accumulates all of the 
      displacements to its left):</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;stereogram&nbsp;y&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;f&nbsp;x&nbsp;=&nbsp;x&nbsp;-&nbsp;float&nbsp;size&nbsp;-&nbsp;depth&nbsp;x&nbsp;y<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;offset&nbsp;=&nbsp;nest&nbsp;repeats&nbsp;f&nbsp;0.0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;x&nbsp;-&gt;&nbsp;tile&nbsp;(nest&nbsp;repeats&nbsp;f&nbsp;x&nbsp;+&nbsp;offset)&nbsp;y;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;stereogram&nbsp;:&nbsp;float&nbsp;-&gt;&nbsp;(float&nbsp;-&gt;&nbsp;byte&nbsp;[])</CODE></P>
      <P>Note that the calculation of <CODE>offset</CODE> has been hoisted so 
      that partial application of the <CODE>stereogram</CODE> function to its 
      <CODE>y</CODE> argument alone gives a more efficient function to compute 
      results at a fixed <CODE>y</CODE> value. This roughly doubles performance 
      because the number of calls to <CODE>depth</CODE> in the inner loop has 
      been halved.</P>
      <P>The width of the bitmap image is:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;width&nbsp;=&nbsp;size&nbsp;*&nbsp;repeats;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;width&nbsp;:&nbsp;int&nbsp;=&nbsp;375</CODE></P>
      <P>The height is set to give a 16:9 aspect ratio, i.e. widescreen:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;height&nbsp;=&nbsp;width*9/16;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;height&nbsp;:&nbsp;int&nbsp;=&nbsp;210</CODE></P>
      <P>We shall use 24-bit RGB colors in the bitmap:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;format&nbsp;=&nbsp;Media.PixelFormats.Rgb24;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;format&nbsp;:&nbsp;Media.PixelFormat&nbsp;=&nbsp;Rgb24</CODE></P>
      <P>The stride of the bitmap is the number of bytes from the start of one 
      row of pixels in the array representation of the bitmap to the start of 
      the next row of pixels:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;stride&nbsp;=&nbsp;format.BitsPerPixel&nbsp;/&nbsp;8&nbsp;*&nbsp;width;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;stride&nbsp;:&nbsp;int&nbsp;=&nbsp;1125</CODE></P>
      <P>A suitable bitmap may then be created as follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;bitmap&nbsp;=&nbsp;Media.Imaging.WriteableBitmap(width,&nbsp;height,&nbsp;1.0,&nbsp;1.0,&nbsp;format,&nbsp;null);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;bitmap&nbsp;:&nbsp;Media.Imaging.WriteableBitmap&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.Windows.Media.Imaging.WriteableBitmap</CODE></P>
      <P>The array containing the red, green and blue bytes representing the 
      bitmap may then be defined as follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;pixels&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array.init&nbsp;height&nbsp;(fun&nbsp;y&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;stereogram&nbsp;=&nbsp;stereogram&nbsp;(float(y&nbsp;-&nbsp;height/2))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array.init&nbsp;width&nbsp;(fun&nbsp;x&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stereogram&nbsp;(float(x&nbsp;-&nbsp;width/2&nbsp;-&nbsp;size/2)))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Array.concat)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Array.concat;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;pixels&nbsp;:&nbsp;byte&nbsp;[]&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|255uy;&nbsp;255uy;&nbsp;15uy;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;&nbsp;255uy;&nbsp;255uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0uy;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;&nbsp;196uy;&nbsp;255uy;&nbsp;0uy;&nbsp;126uy;&nbsp;255uy;&nbsp;0uy;&nbsp;59uy;&nbsp;255uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0uy;&nbsp;0uy;&nbsp;228uy;&nbsp;0uy;&nbsp;0uy;&nbsp;178uy;&nbsp;0uy;&nbsp;0uy;&nbsp;123uy;&nbsp;0uy;&nbsp;0uy;&nbsp;63uy;&nbsp;0uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0uy;&nbsp;1uy;&nbsp;60uy;&nbsp;0uy;&nbsp;0uy;&nbsp;154uy;&nbsp;0uy;&nbsp;0uy;&nbsp;251uy;&nbsp;0uy;&nbsp;0uy;&nbsp;255uy;&nbsp;0uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0uy;&nbsp;255uy;&nbsp;0uy;&nbsp;0uy;&nbsp;255uy;&nbsp;7uy;&nbsp;0uy;&nbsp;255uy;&nbsp;62uy;&nbsp;0uy;&nbsp;255uy;&nbsp;121uy;&nbsp;0uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255uy;&nbsp;180uy;&nbsp;0uy;&nbsp;255uy;&nbsp;239uy;&nbsp;0uy;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;&nbsp;255uy;&nbsp;255uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;62uy;&nbsp;245uy;&nbsp;255uy;&nbsp;145uy;&nbsp;140uy;&nbsp;255uy;&nbsp;228uy;&nbsp;38uy;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;&nbsp;255uy;&nbsp;...|]</CODE></P>
      <P>Note the elegant use of the <CODE>Array.init</CODE> and 
      <CODE>Array.concat</CODE> functions and the partial application of the 
      <CODE>stereogram</CODE> function in the outer loop to avoid needlessly 
      recomputing <CODE>offset</CODE>.</P>
      <P>The main program then fills in the bitmap, creates an 
      <CODE>Image</CODE> control to display it, nests that in a 
      <CODE>Viewbox</CODE> control to have the image automatically stretched and 
      then places that in a <CODE>Window</CODE>:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;[&lt;System.STAThread&gt;]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bitmap.Lock()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;source&nbsp;=&nbsp;Int32Rect(0,&nbsp;0,&nbsp;width,&nbsp;height)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bitmap.WritePixels(source,&nbsp;pixels,&nbsp;stride,&nbsp;0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bitmap.Unlock()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;control&nbsp;=&nbsp;Controls.Image(Source=bitmap)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;viewBox&nbsp;=&nbsp;Controls.Viewbox(Child=control,&nbsp;Stretch=Media.Stretch.Uniform)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Application().Run(Window(Content=viewBox))&nbsp;|&gt;&nbsp;ignore;;</CODE></P>
      <H2>Parallelization</H2>
      <P>This program is remarkably easy to parallelize in F#. As most of the 
      time is spent in numerical code that is evaluated independently for each 
      row of pixels, the outer loop in the definition of <CODE>pixels</CODE> 
      that was implemented using <CODE>Array.init</CODE> may be parallelized 
      simply by replacing this with <CODE>Array.Parallel.init</CODE>.</P>
      <P>The definition of <CODE>pixels</CODE> is then:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;pixels&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array.Parallel.init&nbsp;height&nbsp;(fun&nbsp;y&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;stereogram&nbsp;=&nbsp;stereogram&nbsp;(float(y&nbsp;-&nbsp;height/2))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array.init&nbsp;width&nbsp;(fun&nbsp;x&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stereogram&nbsp;(float(x&nbsp;-&nbsp;width/2&nbsp;-&nbsp;size/2)))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Array.concat)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Array.concat;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;pixels&nbsp;:&nbsp;byte&nbsp;[]&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|255uy;&nbsp;255uy;&nbsp;15uy;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;&nbsp;255uy;&nbsp;255uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0uy;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;&nbsp;196uy;&nbsp;255uy;&nbsp;0uy;&nbsp;126uy;&nbsp;255uy;&nbsp;0uy;&nbsp;59uy;&nbsp;255uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0uy;&nbsp;0uy;&nbsp;228uy;&nbsp;0uy;&nbsp;0uy;&nbsp;178uy;&nbsp;0uy;&nbsp;0uy;&nbsp;123uy;&nbsp;0uy;&nbsp;0uy;&nbsp;63uy;&nbsp;0uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0uy;&nbsp;1uy;&nbsp;60uy;&nbsp;0uy;&nbsp;0uy;&nbsp;154uy;&nbsp;0uy;&nbsp;0uy;&nbsp;251uy;&nbsp;0uy;&nbsp;0uy;&nbsp;255uy;&nbsp;0uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0uy;&nbsp;255uy;&nbsp;0uy;&nbsp;0uy;&nbsp;255uy;&nbsp;7uy;&nbsp;0uy;&nbsp;255uy;&nbsp;62uy;&nbsp;0uy;&nbsp;255uy;&nbsp;121uy;&nbsp;0uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255uy;&nbsp;180uy;&nbsp;0uy;&nbsp;255uy;&nbsp;239uy;&nbsp;0uy;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;&nbsp;255uy;&nbsp;255uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;62uy;&nbsp;245uy;&nbsp;255uy;&nbsp;145uy;&nbsp;140uy;&nbsp;255uy;&nbsp;228uy;&nbsp;38uy;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255uy;&nbsp;255uy;&nbsp;0uy;&nbsp;255uy;&nbsp;...|]</CODE></P>
      <P>The program then takes full advantage of the sophisticated parallelism 
      capabilities in .NET 4 and achieves linear speedup on a multicore.</P>
      <H2>Summary</H2>
      <P>This article has shown how a WPF application can draw autostereograms 
      using programmatically generated tiles rendered onto a bitmap and viewed 
      in an <CODE>Image</CODE> control that is automatically resized by a 
      <CODE>Viewbox</CODE> control. This basic framework is applicable to a wide 
      variety of graphical problems but, in this case, is used to create a 
      seamless autostereogram.</P>
      <P>The F#.NET Journal will revisit the subject of optical illusions in the 
      future.</P></TD></TR></TBODY></TABLE>
<TABLE id=footer>
  <TBODY>
  <TR>
    <TD>© Flying Frog Consultancy Ltd., 2010</TD>
    <TD>Contact the <A href="mailto:webmaster@ffconsultancy.com">webmaster</A> 
    </TD></TR></TBODY></TABLE>
<SCRIPT type=text/javascript src="F%23%20Journal%20stereograms_files/urchin.js">
    <script type="text/javascript">_uacct = "UA-197840-1"; urchinTracker();</SCRIPT>
</BODY></HTML>
