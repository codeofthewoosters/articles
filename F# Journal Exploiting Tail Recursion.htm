<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0084)http://www.ffconsultancy.com/products/fsharp_journal/subscribers/tail_recursion.html -->
<!--?xml version="1.0" encoding="iso-8859-1"?--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><HTML><HEAD><META 
content="IE=10.000" http-equiv="X-UA-Compatible">
   <TITLE>F# Journal: Exploiting Tail Recursion</TITLE>   
<META http-equiv="Content-Type" content="text/html; charset=windows-1252"><LINK 
href="F%23%20Journal%20Exploiting%20Tail%20Recursion_files/style.css" rel="stylesheet" 
type="text/css">   <LINK href="F%23%20Journal%20Exploiting%20Tail%20Recursion_files/style(1).css" 
rel="stylesheet" type="text/css">   <LINK href="F%23%20Journal%20Exploiting%20Tail%20Recursion_files/individual.css" 
rel="stylesheet" type="text/css"> 
<META name="GENERATOR" content="MSHTML 10.00.9200.16458"></HEAD>
<BODY>       <TITLE>F# Journal: Exploiting Tail Recursion</TITLE>     <LINK 
href="F%23%20Journal%20Exploiting%20Tail%20Recursion_files/style.css" rel="stylesheet" 
type="text/css">     <LINK href="F%23%20Journal%20Exploiting%20Tail%20Recursion_files/style(1).css" 
rel="stylesheet" type="text/css">     <LINK href="F%23%20Journal%20Exploiting%20Tail%20Recursion_files/individual.css" 
rel="stylesheet" type="text/css">         
<TABLE id="logo">
  <TBODY>
  <TR>
    <TD width="100%"><IMG src="F%23%20Journal%20Exploiting%20Tail%20Recursion_files/title.gif"> 
              </TD>
    <TD><IMG src="F%23%20Journal%20Exploiting%20Tail%20Recursion_files/left.gif"> 
              </TD></TR></TBODY></TABLE>
<TABLE id="menu">
  <TBODY>
  <TR>
    <TD width="25%">
    <TD width="25%"><A 
      href="http://www.ffconsultancy.com/products/index.html">Home Page</A>      
         </TD>
    <TD width="25%"><A href="http://www.ffconsultancy.com/products/fsharp_journal/subscribers/index.html">The 
      F# Journal</A>         </TD>
    <TD width="25%"></TR></TBODY></TABLE>
<TABLE id="page">
  <TBODY>
  <TR>
    <TD>
      <H1>Exploiting Tail Recursion</H1>
      <P>Recursion is essential to functional programming and practical use of 
      functional programming languages and a functional style requires the 
      ability to write recursive functions that do not consume stack space. 
      Function calls that require no stack space are called tail calls. This 
      article describes the use of tail calls to write robust and efficient tail 
      recursive functions in F#.</P>
      <H2>Introduction</H2>
      <P>As we have seen, the use of immutable data structures requires 
      recursion to replace conventional loops. A common cost with recursion that 
      appears in F# programs is the consumption of system stack space to 
      allocate local variables. The system stack is a much more limited resource 
      than the heap. Also, F# programs run more slowly as the stack grows. 
      Consequently, programmers must be careful to avoid using too much stack 
      space.</P>
      <P>Consider the following              <CODE>factorial</CODE> function:    
             </P>
<PRE>let rec factorial = function
  | 0 | 1 -&gt; 1
  | n -&gt; n * factorial(n - 1)</PRE>
      <P>Each time this              <CODE>factorial</CODE> function calls 
      itself, it consumes another stack frame. As we shall see, rewriting this   
                 <CODE>factorial</CODE> function in tail recursive form allows 
      us to avoid this stack growth. However, a conceptual understanding of why 
      the stack is consumed helps enormously in understanding what tail calls 
      are and why they work.           </P>
      <P>To understand this, consider the sequence of actions performed by this  
                  <CODE>factorial</CODE> function:           </P>
      <P>
      <UL>
        <LI>For a given n:</LI>
        <LI>if n=0 then return 1</LI>
        <LI>compute (n-1)!</LI>
        <LI>multiply it by n</LI>
        <LI>return the result</LI></UL>
      <P></P>
      <P>The critical point is that the result of the recursive call             
       <CODE>factorial(n-1)</CODE> is used in further computation before a value 
      is returned. Specifically,              <CODE>factorial(n-1)</CODE> is 
      multiplied by              <CODE>n</CODE> and the result is returned.      
           </P>
      <P>If the              <CODE>factorial</CODE> function could be rewritten 
      such that the value resulting from the recursive call were returned 
      immediately then there would be no need to grow the stack: the recursive 
      function call could be replaced by a goto. This is exactly what happens 
      with a tail call.           </P>
      <P>Let's see what happens when the stack overflows in practice before 
      moving on to solving the problem.</P>
      <H2>When stacks go bad</H2>
      <P>The following              <CODE>ipow</CODE> function allows us to test 
      the depth of recursion allowed on a machine:           </P>
<PRE>&gt; let rec ipow x n =
    match x, n with
    | 0., _ -&gt; 0.
    | _, 0 -&gt; 1.
    | x, 1 -&gt; x
    | x, n when n&lt;0 -&gt; 1. / ipow x (-n)
    | x, n -&gt; x * ipow x (n - 1);;
val ipow : float -&gt; int -&gt; float</PRE>
      <P>This implementation of the              <CODE>ipow</CODE> function is 
      not tail recursive and the function consumes O(n) stack space as a result. 
      Using this function in an F# interactive session with progressively larger 
      arguments eventually results in a stack overflow:           </P>
<PRE>&gt; ipow (1. + 1e-10) 1000;;
val it : float = 1.0000001
&gt; ipow (1. + 1e-10) 10000;;
val it : float = 1.000001
&gt; ipow (1. + 1e-10) 100000;;</PRE>
<PRE>Process is terminated due to StackOverflowException.</PRE>
<PRE>Session termination detected. Press Enter to restart.</PRE>
      <P>The final invocation requires 10             <SUP>5</SUP>  recursions, 
      consuming the entire .NET stack and causing a stack overflow. At the time 
      of writing, the overflow is not handled by the F# interactive mode, 
      causing the entire session to die:           </P>
      <P>
      <P style="text-align: center;"><IMG src="F%23%20Journal%20Exploiting%20Tail%20Recursion_files/stack_overflow.gif"> 
                  </P>
      <P></P>
      <P>A compiled application would be able to catch the exception and try to 
      recover but the loss of all data in the F# interactive session indicates 
      the severity of this error. Consequently, the ability to write functions 
      that avoid stack consumption is one of the most important low-level 
      aspects of the F# language, something that all F# programmers should be 
      aware of.</P>
      <H2>Tail calls</H2>
      <P>There are two approaches to writing functions such that they return the 
      result of a computation directly. The first is to accumulate the result in 
      a function argument, the second is to accumulate a function that computes 
      the result in an argument.</P>
      <H3>Accumulators</H3>
      <P>Adding an argument to a function that is used to accumulate the result 
      is the simplest approach to writing tail recursive functions.</P>
      <P>The              <CODE>factorial</CODE> function is easily written 
      using an accumulator:           </P>
<PRE>&gt; let rec factorial_aux n = function
    | 0 | 1 -&gt; n
    | m -&gt; factorial_aux (n*m) (m-1);;
val factorial : int -&gt; int -&gt; int
&gt; let factorial = factorial_aux 1;;
val factorial : int -&gt; int
&gt; factorial 5;;
val it : int = 120</PRE>
      <P>In this case, the use of an accumulator with the base case              
      <CODE>n=1</CODE> is hidden behind an auxiliary function              
      <CODE>factorial_aux</CODE> that is called by the              
      <CODE>factorial</CODE> function.           </P>
      <P>Note that the result of the recursive call to              
      <CODE>factorial_aux</CODE> is returned immediately and, consequently, this 
      is a tail call.           </P>
      <P>A similar style is to nest the auxiliary function inside the function 
      that requires it. This can be seen in the implementation of              
      <CODE>List.length</CODE> in the F# standard library 
      (source\fsharp\fslib\prim-types.fs):           </P>
<PRE>let length x = 
  let rec lacc acc l = match l with [] -&gt; acc | h::t -&gt; lacc (acc+1) t 
  lacc 0 x</PRE>
      <P>The length of the list is accumulated in              <CODE>acc</CODE> 
      with a base case of zero. This formulation allows the              
      <CODE>List.length</CODE> function to be applied to arbitrarily-long lists 
      without causing a stack overflow.           </P>
      <P>The              <CODE>ipow</CODE> function can be made tail recursive 
      using an accumulator:           </P>
<PRE>&gt; let rec ipow_aux y x n =
    match x, n with
    | 0., _ -&gt; 0.
    | _, 0 -&gt; y
    | x, 1 -&gt; x * y
    | x, n when n&lt;0 -&gt; 1. / ipow_aux y x (-n)
    | x, n -&gt; ipow_aux (x * y) x (n - 1);;
val ipow_aux : float -&gt; float -&gt; int -&gt; float
&gt; let ipow = ipow_aux 1.;;
val ipow : float -&gt; int -&gt; float</PRE>
      <P>This program is no longer susceptible to stack overflows:</P>
<PRE>&gt; ipow (1. + 1e-10) 1000000;;
val it : float = 1.0001</PRE>
      <P>Note that the recursive call invoked when              
      <CODE>n&lt;0</CODE> is not a tail call and, consequently, will consume 
      stack space. However, this call is only made once at most, so the total 
      stack consumption is constant.           </P>
      <H3>Continuation passing style</H3>
      <P>A more sophisticated technique called              <I>continuation 
      passing style</I> (CPS) may also be used to avoid stack consumption. This 
      technique involves accumulating a function called a continuation. A 
      continuation is a function that performs the remainder of a computation.   
              </P>
      <P>For example, the              <CODE>factorial</CODE> function may be 
      written in CPS as follows:           </P>
<PRE>&gt; let rec factorial_aux k = function
  | 0 | 1 -&gt; k 1
  | n -&gt; factorial_aux (fun m -&gt; k (n * m)) (n - 1);;
val factorial_aux : (int -&gt; 'a) -&gt; int -&gt; 'a
&gt; let factorial = factorial_aux (fun n -&gt; n);;
val factorial : int -&gt; int
&gt; factorial 5;;
val it : int = 120</PRE>
      <P>There are three important points to note about this formulation:</P>
      <P>
      <UL>
        <LI>The recursive call to                  <CODE>factorial_aux</CODE> is 
        a tail call: the result is returned immediately               </LI>
        <LI>The call to the old continuation                  <CODE>k</CODE> in 
        the new continuation                  <CODE>fun m -&gt; k (n*m)</CODE> 
        is also a tail call               </LI>
        <LI>As the continuation                  <CODE>k</CODE> is not known to 
        return, its inferred return type in the signature of                  
        <CODE>factorial_aux</CODE> is the polymorphic type variable              
            <CODE>'a</CODE>               </LI></UL>
      <P></P>
      <P>Checking for the inference of a type variable as the return type of the 
      continuation is a good way to make sure that a function has been written 
      correctly in CPS because both obvious mistakes (non tail calls) result in 
      the specific return type              <CODE>int</CODE> :           </P>
<PRE>&gt; let rec factorial_aux k = function
    | 0 | 1 -&gt; k 1
    | n -&gt; factorial_aux (fun m -&gt; n * k m) (n - 1);;
val factorial_aux : (int -&gt; int) -&gt; int -&gt; int
&gt; let rec factorial_aux k = function
    | 0 | 1 -&gt; k 1
    | n -&gt; k(factorial_aux (fun m -&gt; n * m) (n - 1));;
val factorial_aux : (int -&gt; int) -&gt; int -&gt; int</PRE>
      <P>For a slightly more sophisticated example, consider writing the         
           <CODE>List.map</CODE> function in continuation passing style:         
        </P>
<PRE>&gt; let rec map_aux k f = function
  | [] -&gt; k []
  | h::t -&gt; map_aux (fun t -&gt; k(f h::t)) f t;;
val map_aux : ('a list -&gt; 'b) -&gt; ('c -&gt; 'a) -&gt; 'c list -&gt; 'b
&gt; let map f = map_aux (fun t -&gt; t) f;;
val map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list</PRE>
      <P>For example, mapping a function that prepends              
      <CODE>"a"</CODE> onto each string in a list:           </P>
<PRE>&gt; map (( + ) "a") ["1"; "2"; "3"];;
val it : string list = ["a1"; "a2"; "a3"]</PRE>
      <P>The design is very similar to the              <CODE>factorial</CODE> 
      function. Specifically, the base case in the first match applies the 
      continuation to the empty list. All other applications accumulate a 
      continuation by creating a new continuation              <CODE>fun t -&gt; 
      k(f h::t)</CODE> that applies the current continuation with              
      <CODE>f h</CODE> prepended onto the tail list that it is given (not the 
      tail list from the pattern match). The              
      <CODE>factorial_aux</CODE> function then recurses to accumulate a 
      continuation that is only invoked by the first match case when the end of 
      the list is reached.           </P>
      <P>In this case, continuation passing style replaced the sequence of stack 
      frames in the original version with a series of nested closures (each 
      closure referring to the next). As closures are stored on the heap rather 
      than the stack and the              <CODE>factorial_aux</CODE> function 
      uses only tail calls, the stack is not consumed.           </P>
      <H2>Exception handlers</H2>
      <P>The              <CODE>try .. with</CODE> and              <CODE>try .. 
      finally</CODE> constructs allow exceptions to be handled. The body of code 
      in this construct is evaluated with the exception handler on the stack. 
      Consequently, recursive calls inside a              <CODE>try .. 
      with</CODE> cannot be tail calls, even if they appear to be in tail 
      position.           </P>
      <P>This problem is sometimes discovered when trying to write functions to 
      handle input from a file using the OCaml-style              
      <CODE>input_line</CODE> functions. For example, the following              
      <CODE>read_aux</CODE> function tries to read the lines of a file into a 
      string using recursion:           </P>
<PRE>&gt; let rec read_aux lines ch =
    try
      read_aux (input_line ch :: lines) ch
    with
    | End_of_file -&gt;
        List.rev lines;;
val read_aux : string list -&gt; in_channel -&gt; string list
&gt; let read file =
    let ch = open_in file
    try
      read_aux [] ch
    finally
      close_in ch;;
val read : string -&gt; string list</PRE>
      <P>However, the recursive call to              <CODE>read_aux</CODE> lies 
      inside a              <CODE>try .. with</CODE> block and, consequently, is 
      not a tail call even though it appears in what might otherwise be 
      considered tail position. As a result, this function will stack overflow 
      whilst trying to read files with many lines:           </P>
<PRE>&gt; read "C:\huge.txt";;</PRE>
<PRE>Process is terminated due to StackOverflowException.</PRE>
<PRE>Session termination detected. Press Enter to restart.</PRE>
      <P>The solution is to move the recursive call outside the              
      <CODE>try .. with</CODE> block. This can be done quite simply by returning 
      an option type that conveys either the value returned (             
      <CODE>Some x</CODE> ) or that the              <CODE>End_of_file</CODE> 
      exception was raised (             <CODE>None</CODE> ):           </P>
<PRE>&gt; let try_input_line ch =
    try
      Some(input_line ch)
    with
    | End_of_file -&gt;
        None;;
val try_input_line : in_channel -&gt; string option
&gt; let rec read_aux lines ch =
    match try_input_line ch with
    | Some line -&gt; read_aux (line :: lines) ch
    | None -&gt; List.rev lines;;
val read_aux : string list -&gt; in_channel -&gt; string list</PRE>
      <P>The solution reflects the fact that the functionality provided by 
      exceptions can always be implemented by returning a sum type giving either 
      the resulting value or the raised exception. The disadvantage of this 
      approach is the cost of boxing the returned value, which incurs an 
      allocation and is significantly slower than using the built-in exception 
      handling. However, this is insignificant in the context of file IO.</P>
      <H2>Standard library functions</H2>
      <P>The F# development team have gone to great lengths to make sure the 
      standard library functions are robust and, in particular, all tail 
      recursive.</P>
      <P>Many functions, such as              <CODE>List.map</CODE> are not 
      naturally tail recursive because they require a list to be traversed in 
      reverse order. As lists are singly linked, this is most naturally 
      implemented by recursing to the end of the list and accumulating the 
      result on the way back up. The              <CODE>List.fold_right</CODE> 
      function is another example of a function that is not naturally tail 
      recursive:           </P>
<PRE>&gt; let rec fold_right f list accu =
    match list with
    | [] -&gt; accu
    | h::t -&gt; f h (fold_right f t accu);;
val fold_right : ('a -&gt; 'b -&gt; 'b) -&gt; 'a list -&gt; 'b -&gt; 'b</PRE>
      <P>Thanks to the efforts of the developers, the only perceivable 
      difference between the tail recursive and naturally not tail recursive 
      functions, such as              <CODE>List.fold_left</CODE> vs             
       <CODE>List.fold_right</CODE> , is the difference in performance required 
      to implement tail recursion. Specifically, the naturally tail recursive 
      functions are typically twice as fast.           </P>
      <P>The robustness of the F# standard library helps enormously in writing 
      robust programs. However, many programs use pattern matching to dissect 
      lists and other O(n)-deep data structures and care must be taken to write 
      these functions in tail recursive form if they are to avoid stack 
      overflows.</P>
      <H2>Summary</H2>
      <P>If a function is expected to recurse deeply then it should be written 
      in tail recursive form. The simplest solution is to use accumulators to 
      avoid non-tail calls. Continuation passing style is a more advanced 
      approach that is easier to test and can be easier to implement for some 
      forms of recursion.</P></TD></TR></TBODY></TABLE>
<TABLE id="footer">
  <TBODY>
  <TR>
    <TD>© Flying Frog Consultancy Ltd., 2007</TD>
    <TD>Contact the            <A 
      href="mailto:webmaster@ffconsultancy.com">webmaster</A>         
  </TD></TR></TBODY></TABLE>
<SCRIPT src="F%23%20Journal%20Exploiting%20Tail%20Recursion_files/urchin.js" type="text/javascript">
<script type="text/javascript">
_uacct = "UA-197840-1";
urchinTracker();</SCRIPT>
 </BODY></HTML>
