<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0097)http://www.ffconsultancy.com/products/fsharp_journal/subscribers/FastStructuralSerialization.html -->
<HTML><HEAD><META content="IE=7.0000" http-equiv="X-UA-Compatible">
<TITLE>F# Journal</TITLE>
<META content="text/html; charset=windows-1252" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="F%23%20Journal%20fast%20structural%20serialization_files/style.css"><LINK 
rel=stylesheet type=text/css 
href="F%23%20Journal%20fast%20structural%20serialization_files/style(1).css"><LINK 
rel=stylesheet type=text/css 
href="F%23%20Journal%20fast%20structural%20serialization_files/individual.css">
<META name=GENERATOR content="MSHTML 10.00.9200.16458"></HEAD>
<BODY>
<TABLE id=logo>
  <TBODY>
  <TR>
    <TD width="100%"><IMG 
      src="F%23%20Journal%20fast%20structural%20serialization_files/title.gif"> 
    </TD>
    <TD><IMG 
      src="F%23%20Journal%20fast%20structural%20serialization_files/left.gif"> 
    </TD></TR></TBODY></TABLE>
<TABLE id=menu>
  <TBODY>
  <TR>
    <TD width="25%">
    <TD width="25%"><A 
      href="http://www.ffconsultancy.com/products/index.html">Home Page</A> </TD>
    <TD width="25%"><A 
      href="http://www.ffconsultancy.com/products/fsharp_journal/subscribers/index.html">The 
      F# Journal</A> </TD>
    <TD width="25%"></TD></TR></TBODY></TABLE>
<TABLE id=page>
  <TBODY>
  <TR>
    <TD>
      <H1>Efficient structural serialization</H1>
      <P>The .NET Framework provides binary, JSON and XML serializers. This 
      article takes a look at these built-in serializers before developing a new 
      structural serializer for values of F# types that addresses some of the 
      shortcomings of the existing serializers.</P>
      <H2>Introduction</H2>
      <P>The .NET Framework provides a simple binary serializer in the 
      <CODE>System.Runtime.Serialization</CODE> namespace.</P>
      <P>The following <CODE>saveBinary</CODE> function tries to convert a value 
      of any type into a byte array from which it can be reconstructed:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;saveBinary&nbsp;x&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;binaryFormatter&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.Runtime.Serialization.Formatters.Binary.BinaryFormatter()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;stream&nbsp;=&nbsp;new&nbsp;System.IO.MemoryStream()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binaryFormatter.Serialize(stream,&nbsp;x)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream.ToArray();;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;saveBinary&nbsp;:&nbsp;'a&nbsp;-&gt;&nbsp;byte&nbsp;[]</CODE></P>
      <P>And the following <CODE>loadBinary</CODE> function does the opposite, 
      converting the byte array back into a value:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;loadBinary&nbsp;(bytes:&nbsp;byte&nbsp;[])&nbsp;:&nbsp;'a&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;binaryFormatter&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.Runtime.Serialization.Formatters.Binary.BinaryFormatter()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;stream&nbsp;=&nbsp;new&nbsp;System.IO.MemoryStream(bytes)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binaryFormatter.Deserialize&nbsp;stream&nbsp;:?&gt;&nbsp;'a;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;loadBinary&nbsp;:&nbsp;byte&nbsp;[]&nbsp;-&gt;&nbsp;'a</CODE></P>
      <P>For example, the following creates a data structure including ints, 
      floats, lists and an array, serializes and deserializes it before 
      comparing for equality with the original:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;xs&nbsp;=&nbsp;Array.init&nbsp;100&nbsp;(fun&nbsp;i&nbsp;-&gt;&nbsp;i,&nbsp;List.init&nbsp;i&nbsp;float);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;xs&nbsp;:&nbsp;(int&nbsp;*&nbsp;float&nbsp;list)&nbsp;[]&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|(0,&nbsp;[]);&nbsp;(1,&nbsp;[0.0]);&nbsp;(2,&nbsp;[0.0;&nbsp;1.0]);&nbsp;(3,&nbsp;[0.0;&nbsp;1.0;&nbsp;2.0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4,&nbsp;[0.0;&nbsp;1.0;&nbsp;2.0;&nbsp;3.0]);&nbsp;(5,&nbsp;[0.0;&nbsp;1.0;&nbsp;2.0;&nbsp;3.0;&nbsp;4.0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(6,&nbsp;[0.0;&nbsp;1.0;&nbsp;2.0;&nbsp;3.0;&nbsp;4.0;&nbsp;5.0]);&nbsp;...<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;loadBinary(saveBinary&nbsp;xs)&nbsp;=&nbsp;xs;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;bool&nbsp;=&nbsp;true</CODE></P>
      <P>As expected, we recover the value back again. Note that the return type 
      of the <CODE>loadBinary</CODE> function dictates how the value is 
      deserialized and, in this case, is inferred from the test for equality 
      with the original value.</P>
      <P>However, the .NET binary serializer enforces nominal typing so the 
      exact same version of the same DLL containing the same type definition 
      must be used to load values back in or the deserializer will stop with an 
      error. Also, the serializer encodes a lot of type information in the 
      message so seemingly-small data structures can be surprisingly-large when 
      serialized.</P>
      <P>For example, the following defines a type <CODE>Person</CODE> with two 
      fields and serializes a value of this type to a byte array:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;type&nbsp;Person&nbsp;=&nbsp;{&nbsp;Name:&nbsp;string;&nbsp;Age:&nbsp;int&nbsp;};;<BR>&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;Person&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Name:&nbsp;string;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Age:&nbsp;int;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;bytes&nbsp;=&nbsp;saveBinary&nbsp;{&nbsp;Name="Jon";&nbsp;Age=34&nbsp;};;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;bytes&nbsp;:&nbsp;byte&nbsp;[]&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|0uy;&nbsp;1uy;&nbsp;0uy;&nbsp;0uy;&nbsp;0uy;&nbsp;255uy;&nbsp;255uy;&nbsp;255uy;&nbsp;255uy;&nbsp;1uy;&nbsp;0uy;&nbsp;0uy;&nbsp;0uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0uy;&nbsp;0uy;&nbsp;0uy;&nbsp;0uy;&nbsp;12uy;&nbsp;2uy;&nbsp;0uy;&nbsp;0uy;&nbsp;0uy;&nbsp;67uy;&nbsp;70uy;&nbsp;83uy;&nbsp;73uy;&nbsp;45uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;65uy;&nbsp;83uy;&nbsp;83uy;&nbsp;69uy;&nbsp;77uy;&nbsp;66uy;&nbsp;76uy;&nbsp;89uy;&nbsp;44uy;&nbsp;32uy;&nbsp;86uy;&nbsp;101uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</CODE></P>
      <P>The resulting array contains 147 bytes even though this message only 
      contains a 3-char string and a small int:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;bytes.Length;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;int&nbsp;=&nbsp;147</CODE></P>
      <P>The message created using the .NET binary serializer is obviously much 
      bigger than necessary.</P>
      <P>We can recover the original value using the same type:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;(loadBinary&nbsp;bytes&nbsp;:&nbsp;Person);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;Person&nbsp;=&nbsp;{Name&nbsp;=&nbsp;"Jon";<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;=&nbsp;34;}</CODE></P>
      <P>But redefining the type breaks the serializer:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;type&nbsp;Person&nbsp;=&nbsp;{&nbsp;Name:&nbsp;string;&nbsp;Age:&nbsp;int&nbsp;};;<BR>&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;Person&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Name:&nbsp;string;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Age:&nbsp;int;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;(loadBinary&nbsp;bytes&nbsp;:&nbsp;Person);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;System.InvalidCastException:&nbsp;[A]Person&nbsp;cannot&nbsp;be&nbsp;cast&nbsp;to<BR>&nbsp;&nbsp;&nbsp;&nbsp;[B]Person.&nbsp;Type&nbsp;A&nbsp;originates&nbsp;from&nbsp;'FSI-ASSEMBLY,<BR>&nbsp;&nbsp;&nbsp;&nbsp;Version=0.0.0.0,&nbsp;Culture=neutral,&nbsp;PublicKeyToken=null'&nbsp;in<BR>&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;context&nbsp;'LoadNeither'&nbsp;in&nbsp;a&nbsp;byte&nbsp;array.&nbsp;Type&nbsp;B&nbsp;originates<BR>&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;'FSI-ASSEMBLY,&nbsp;Version=0.0.0.0,&nbsp;Culture=neutral,<BR>&nbsp;&nbsp;&nbsp;&nbsp;PublicKeyToken=null'&nbsp;in&nbsp;the&nbsp;context&nbsp;'LoadNeither'&nbsp;in&nbsp;a&nbsp;byte<BR>&nbsp;&nbsp;&nbsp;&nbsp;array.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;Microsoft.FSharp.Core.LanguagePrimitives.<BR>&nbsp;&nbsp;&nbsp;&nbsp;IntrinsicFunctions.UnboxGeneric[T](Object&nbsp;source)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;FSI_0011.loadBinary[a](Byte[]&nbsp;bytes)&nbsp;in&nbsp;C:\Users\Jon\<BR>&nbsp;&nbsp;&nbsp;&nbsp;Documents\Visual&nbsp;Studio&nbsp;2010\Projects\F#&nbsp;Journal\<BR>&nbsp;&nbsp;&nbsp;&nbsp;Not&nbsp;yet&nbsp;published\StructuralSerialization\<BR>&nbsp;&nbsp;&nbsp;&nbsp;StructuralSerialization\Others.fs:line&nbsp;49<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;&lt;StartupCode$FSI_0072&gt;.$FSI_0072.main@()<BR>&nbsp;&nbsp;&nbsp;&nbsp;Stopped&nbsp;due&nbsp;to&nbsp;error</CODE></P>
      <P>Large space overheads per message make the .NET binary serializer 
      unsuitable for many message passing applications. The inability to load 
      data back in to structurally-identical types make this serializer 
      unsuitable for saving and reloading data in F# Interactive.</P>
      <P>The JSON serializer does not suffer from these problems because it does 
      not encode any type information beyond structure and, consequently, can 
      deserialize into any structurally-equivalent type.</P>
      <P>The following <CODE>saveJSON</CODE> and <CODE>loadJSON</CODE> functions 
      serialize and deserialize values to the JSON format, respectively:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;#r&nbsp;"System.Runtime.Serialization.dll";;<BR>&nbsp;&nbsp;&nbsp;&nbsp;--&gt;&nbsp;Referenced&nbsp;'C:\windows\Microsoft.NET\Framework\v4.0.30319\<BR>&nbsp;&nbsp;&nbsp;&nbsp;System.Runtime.Serialization.dll'<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;saveJSON&nbsp;x&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;jsonSerializer&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.Runtime.Serialization.Json.DataContractJsonSerializer(x.GetType())<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;stream&nbsp;=&nbsp;new&nbsp;System.IO.MemoryStream()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jsonSerializer.WriteObject(stream,&nbsp;x)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream.ToArray();;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;saveJSON&nbsp;:&nbsp;'a&nbsp;-&gt;&nbsp;byte&nbsp;[]<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;loadJSON&nbsp;(bytes:&nbsp;byte&nbsp;[])&nbsp;:&nbsp;'a&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;jsonSerializer&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.Runtime.Serialization.Json.DataContractJsonSerializer(typeof&lt;'a&gt;)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;stream&nbsp;=&nbsp;new&nbsp;System.IO.MemoryStream(bytes)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jsonSerializer.ReadObject&nbsp;stream&nbsp;:?&gt;&nbsp;'a;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;loadJSON&nbsp;:&nbsp;byte&nbsp;[]&nbsp;-&gt;&nbsp;'a</CODE></P>
      <P>Our example value of the type <CODE>Person</CODE> serializes to just 25 
      bytes (compared to 147 bytes for the binary serializer):</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;bytes&nbsp;=&nbsp;saveJSON&nbsp;{&nbsp;Name="Jon";&nbsp;Age=34&nbsp;};;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;bytes&nbsp;:&nbsp;byte&nbsp;[]&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|123uy;&nbsp;34uy;&nbsp;65uy;&nbsp;103uy;&nbsp;101uy;&nbsp;64uy;&nbsp;34uy;&nbsp;58uy;&nbsp;51uy;&nbsp;52uy;&nbsp;44uy;&nbsp;34uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;78uy;&nbsp;97uy;&nbsp;109uy;&nbsp;101uy;&nbsp;64uy;&nbsp;34uy;&nbsp;58uy;&nbsp;34uy;&nbsp;74uy;&nbsp;111uy;&nbsp;110uy;&nbsp;34uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;125uy|]<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;bytes.Length;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;int&nbsp;=&nbsp;25</CODE></P>
      <P>And, of course, we can deserialize the value back again:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;(loadJSON&nbsp;bytes&nbsp;:&nbsp;Person);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;Person&nbsp;=&nbsp;{Name&nbsp;=&nbsp;"Jon";<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;=&nbsp;34;}</CODE></P>
      <P>In fact, the bytes are a human-readable string:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;String.init&nbsp;bytes.Length&nbsp;(fun&nbsp;i&nbsp;-&gt;&nbsp;char&nbsp;bytes.[i]&nbsp;|&gt;&nbsp;string);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;string&nbsp;=&nbsp;"{"Age@":34,"Name@":"Jon"}"</CODE></P>
      <P>However, the JSON serializer corrupts values of the 
      <CODE>DateTime</CODE> type:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;dt&nbsp;=&nbsp;System.DateTime.Now;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;dt&nbsp;:&nbsp;System.DateTime&nbsp;=&nbsp;12/03/2012&nbsp;08:00:58<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;loadJSON(saveJSON&nbsp;dt)&nbsp;=&nbsp;dt;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;bool&nbsp;=&nbsp;false</CODE></P>
      <P>Note how the recovered <CODE>DateTime</CODE> value is not equal to the 
      original although the trextual representation looks the same:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;(loadJSON(saveJSON&nbsp;dt)&nbsp;:&nbsp;System.DateTime);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;System.DateTime&nbsp;=&nbsp;12/03/2012&nbsp;08:00:58&nbsp;{Date&nbsp;=&nbsp;12/03/2012&nbsp;00:00:00;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Day&nbsp;=&nbsp;12;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DayOfWeek&nbsp;=&nbsp;Monday;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DayOfYear&nbsp;=&nbsp;72;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hour&nbsp;=&nbsp;8;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Kind&nbsp;=&nbsp;Local;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Millisecond&nbsp;=&nbsp;674;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Minute&nbsp;=&nbsp;0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Month&nbsp;=&nbsp;3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Second&nbsp;=&nbsp;58;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ticks&nbsp;=&nbsp;634671360586740000L;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimeOfDay&nbsp;=&nbsp;08:00:58.6740000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Year&nbsp;=&nbsp;2012;}</CODE></P>
      <P>Converting the <CODE>DateTime</CODE> values to their binary 
      representation as a 64-bit int shows that there is a slight discrepancy, a 
      kind of round-off error from the encoding used by JSON:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;dt.ToBinary();;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;int64&nbsp;=&nbsp;-8588700676268032123L<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;(loadJSON(saveJSON&nbsp;dt)&nbsp;:&nbsp;System.DateTime).ToBinary();;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;int64&nbsp;=&nbsp;-8588700676268035808L</CODE></P>
      <P>The JSON serializer can also produce messages that are significantly 
      larger than necessary and can take a long time to do so. Perhaps the most 
      extreme example is the serialization of a byte array because the binary 
      serializer can encode this directly with a small overhead whereas the JSON 
      serializer converts each byte to a string and back.</P>
      <P>Consider serializing the follow byte array:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;xs&nbsp;=&nbsp;Array.init&nbsp;100000&nbsp;byte;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;xs&nbsp;:&nbsp;byte&nbsp;[]&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|0uy;&nbsp;1uy;&nbsp;2uy;&nbsp;3uy;&nbsp;4uy;&nbsp;5uy;&nbsp;6uy;&nbsp;7uy;&nbsp;8uy;&nbsp;9uy;&nbsp;10uy;&nbsp;11uy;&nbsp;12uy;&nbsp;13uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14uy;&nbsp;15uy;&nbsp;16uy;&nbsp;17uy;&nbsp;18uy;&nbsp;19uy;&nbsp;20uy;&nbsp;21uy;&nbsp;22uy;&nbsp;23uy;&nbsp;24uy;&nbsp;25uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;26uy;&nbsp;27uy;&nbsp;28uy;&nbsp;29uy;&nbsp;30uy;&nbsp;31uy;&nbsp;32uy;&nbsp;33uy;&nbsp;34uy;&nbsp;35uy;&nbsp;36uy;&nbsp;37uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;38uy;&nbsp;39uy;&nbsp;40uy;&nbsp;41uy;&nbsp;42uy;&nbsp;43uy;&nbsp;44uy;&nbsp;45uy;&nbsp;46uy;&nbsp;47uy;&nbsp;48uy;&nbsp;49uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50uy;&nbsp;51uy;&nbsp;52uy;&nbsp;53uy;&nbsp;54uy;&nbsp;55uy;&nbsp;56uy;&nbsp;57uy;&nbsp;58uy;&nbsp;59uy;&nbsp;60uy;&nbsp;61uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;62uy;&nbsp;63uy;&nbsp;64uy;&nbsp;65uy;&nbsp;66uy;&nbsp;67uy;&nbsp;68uy;&nbsp;69uy;&nbsp;70uy;&nbsp;71uy;&nbsp;72uy;&nbsp;73uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;74uy;&nbsp;75uy;&nbsp;76uy;&nbsp;77uy;&nbsp;78uy;&nbsp;79uy;&nbsp;80uy;&nbsp;81uy;&nbsp;82uy;&nbsp;83uy;&nbsp;84uy;&nbsp;85uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;86uy;&nbsp;87uy;&nbsp;88uy;&nbsp;89uy;&nbsp;90uy;&nbsp;91uy;&nbsp;92uy;&nbsp;93uy;&nbsp;94uy;&nbsp;95uy;&nbsp;96uy;&nbsp;97uy;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;98uy;&nbsp;99uy;&nbsp;...|]</CODE></P>
      <P>JSON serializes this to 348kB:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;(saveJSON&nbsp;xs).Length;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;int&nbsp;=&nbsp;356991</CODE></P>
      <P>and takes 1.3s to serialize and deserialize the value:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;loadJSON(saveJSON&nbsp;xs)&nbsp;=&nbsp;xs;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;Real:&nbsp;00:00:01.327,&nbsp;CPU:&nbsp;00:00:01.279,&nbsp;GC&nbsp;gen0:&nbsp;1,&nbsp;gen1:&nbsp;0,&nbsp;gen2:&nbsp;0<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;bool&nbsp;=&nbsp;true</CODE></P>
      <P>In contract, the binary serializer requires only 97kB:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;(saveBinary&nbsp;xs).Length;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;int&nbsp;=&nbsp;100028</CODE></P>
      <P>and takes just 4ms:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;loadBinary(saveBinary&nbsp;xs)&nbsp;=&nbsp;xs;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;Real:&nbsp;00:00:00.004,&nbsp;CPU:&nbsp;00:00:00.000,&nbsp;GC&nbsp;gen0:&nbsp;0,&nbsp;gen1:&nbsp;0,&nbsp;gen2:&nbsp;0<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;bool&nbsp;=&nbsp;true</CODE></P>
      <P>So JSON required 3.5x more space and took over 300x longer.</P>
      <P>There is clearly room for improvement and the remainder of this article 
      is devoted to a basic structural serialization library that can serialize 
      and deserialize values of many different types:</P>
      <H2>Simple structural serialization</H2>
      <H3>Serialization</H3>
      <P>We begin by opening the following namepsaces:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;open&nbsp;System;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;open&nbsp;System.Collections.Generic;;</CODE></P>
      <P>The following function writes a byte array to a stream:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;write&nbsp;(stream:&nbsp;System.IO.Stream)&nbsp;(xs:&nbsp;byte&nbsp;[])&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream.Write(xs,&nbsp;0,&nbsp;xs.Length);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;write&nbsp;:&nbsp;IO.Stream&nbsp;-&gt;&nbsp;byte&nbsp;[]&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>A 32-bit int may be written to a stream by first converting it to a 
      byte array using the <CODE>System.BitConverter.GetBytes</CODE> function as 
      follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;writeInt&nbsp;stream&nbsp;(n:&nbsp;int)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.BitConverter.GetBytes&nbsp;n&nbsp;|&gt;&nbsp;write&nbsp;stream;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;writeInt&nbsp;:&nbsp;IO.Stream&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>Similarly for a 64-bit int:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;writeInt64&nbsp;stream&nbsp;(n:&nbsp;int64)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.BitConverter.GetBytes&nbsp;n&nbsp;|&gt;&nbsp;write&nbsp;stream;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;writeInt64&nbsp;:&nbsp;IO.Stream&nbsp;-&gt;&nbsp;int64&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>and a float:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;serializeFloat&nbsp;stream&nbsp;(x:&nbsp;float)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.BitConverter.GetBytes&nbsp;x&nbsp;|&gt;&nbsp;write&nbsp;stream;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;serializeFloat&nbsp;:&nbsp;IO.Stream&nbsp;-&gt;&nbsp;float&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>.NET 4 provides a built-in struct type for complex numbers that we can 
      serialize by writing each of the two components in turn as follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;serializeComplex&nbsp;stream&nbsp;(z:&nbsp;System.Numerics.Complex)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serializeFloat&nbsp;stream&nbsp;z.Real<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serializeFloat&nbsp;stream&nbsp;z.Imaginary;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;serializeComplex&nbsp;:&nbsp;IO.Stream&nbsp;-&gt;&nbsp;Numerics.Complex&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>The <CODE>decimal</CODE> type (that represents numbers in base 10 in 
      order to avoid round-off errors and is commonly used in the finance 
      sector) may be serialized by first converting a number to a binary 
      representation as four integers:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;serializeDecimal&nbsp;stream&nbsp;m&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.Decimal.GetBits&nbsp;m<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Array.iter&nbsp;(writeInt&nbsp;stream);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;serializeDecimal&nbsp;:&nbsp;IO.Stream&nbsp;-&gt;&nbsp;decimal&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>Values of the .NET <CODE>DateTime</CODE> type may be converted to and 
      from 64-bit integers for serialization as follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;serializeDateTime&nbsp;stream&nbsp;(dt:&nbsp;DateTime)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dt.ToBinary()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;writeInt64&nbsp;stream;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;serializeDateTime&nbsp;:&nbsp;IO.Stream&nbsp;-&gt;&nbsp;DateTime&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>Strings may be encoded as follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;serializeString&nbsp;stream&nbsp;(str:&nbsp;string)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;e&nbsp;=&nbsp;System.Text.UTF8Encoding()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;bytes&nbsp;=&nbsp;e.GetBytes&nbsp;str<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeInt&nbsp;stream&nbsp;bytes.Length<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write&nbsp;stream&nbsp;bytes;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;serializeString&nbsp;:&nbsp;IO.Stream&nbsp;-&gt;&nbsp;string&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>Now for the interesting part. We need some way to generate and fetch 
      the serializer for a given type efficiently and, therefore, we would like 
      to memoize previously-generated serializers. This is most easily 
      accomplished by storing a global dictionary that maps each type to its 
      serializer. The dictionary grows as new serializers are generated for 
      newly-seen types:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;serializers&nbsp;=&nbsp;Dictionary&lt;System.Type,&nbsp;(System.IO.Stream&nbsp;-&gt;&nbsp;obj&nbsp;-&gt;&nbsp;unit)&nbsp;ref&gt;();;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;serializers&nbsp;:&nbsp;Dictionary&lt;Type,(IO.Stream&nbsp;-&gt;&nbsp;obj&nbsp;-&gt;&nbsp;unit)&nbsp;ref&gt;&nbsp;=&nbsp;dict&nbsp;[]</CODE></P>
      <P>Now we can define the following <CODE>addSerializer</CODE> function 
      that accepts a strongly typed serializer like <CODE>writeInt</CODE> and 
      converts it (using the <CODE>unbox</CODE> function) into a weakly typed 
      function that handles a boxed value of the type <CODE>obj</CODE>:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;addSerializer&lt;'a&gt;&nbsp;:&nbsp;(IO.Stream&nbsp;-&gt;&nbsp;'a&nbsp;-&gt;&nbsp;unit)&nbsp;-&gt;&nbsp;unit&nbsp;=&nbsp;fun&nbsp;f&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serializers.[typeof&lt;'a&gt;]&nbsp;&lt;-&nbsp;ref(fun&nbsp;stream&nbsp;x&nbsp;-&gt;&nbsp;f&nbsp;stream&nbsp;(unbox&nbsp;x));;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;addSerializer&nbsp;:&nbsp;(IO.Stream&nbsp;-&gt;&nbsp;'a&nbsp;-&gt;&nbsp;unit)&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>This <CODE>addSerializer</CODE> function may then be used to initialize 
      the dictionary with the first-order serializers we have already 
      defined:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addSerializer&nbsp;writeInt<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addSerializer&nbsp;writeInt64<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addSerializer&nbsp;serializeFloat<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addSerializer&nbsp;serializeComplex<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addSerializer&nbsp;serializeDecimal<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addSerializer&nbsp;serializeDateTime<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addSerializer&nbsp;serializeString;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;unit&nbsp;=&nbsp;()</CODE></P>
      <P>Note how the use of <CODE>unbox</CODE> allows 
      <CODE>addSerializer</CODE> to act upon serialization functions of 
      different types and how their actual underlying type is used to determine 
      the key when they are inserted into the dictionary.</P>
      <P>Now we can write some higher-order serializers. The following 
      <CODE>serializeArray</CODE> function serializes the dimensionalities of an 
      arbitrary-dimensionality array followed by the array elements 
      themselves:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;serializeArray&nbsp;serializeElt&nbsp;stream&nbsp;(x:&nbsp;obj)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x&nbsp;=&nbsp;x&nbsp;:?&gt;&nbsp;System.Array<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i=0&nbsp;to&nbsp;x.Rank-1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeInt&nbsp;stream&nbsp;(x.GetLength&nbsp;i)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;x&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!serializeElt&nbsp;stream&nbsp;x;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;serializeArray&nbsp;:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('a&nbsp;-&gt;&nbsp;obj&nbsp;-&gt;&nbsp;unit)&nbsp;ref&nbsp;-&gt;&nbsp;'a&nbsp;-&gt;&nbsp;obj&nbsp;-&gt;&nbsp;unit&nbsp;when&nbsp;'a&nbsp;:&gt;&nbsp;IO.Stream</CODE></P>
      <P>Note that <CODE>serializeElt</CODE> is a reference to a function. This 
      allows us to partially apply it in order to build up a graph of 
      serializers and then mutate the reference to initialize the graph topology 
      appropriately. As we shall see, this is essential for dynamically creating 
      cyclic graphs for serializers of types that refer to themselves (either 
      directly or indirectly).</P>
      <P>Records and tuples both have statically-known numbers of elements so it 
      is not necessary to serialize their sizes. The following 
      <CODE>serializeMany</CODE> function serializes such a sequence of 
      values:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;serializeMany&nbsp;(serializer&nbsp;:&nbsp;_&nbsp;[])&nbsp;getFields&nbsp;stream&nbsp;(x:&nbsp;obj)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;fields&nbsp;:&nbsp;_&nbsp;[]&nbsp;=&nbsp;getFields&nbsp;x<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i=0&nbsp;to&nbsp;fields.Length&nbsp;-&nbsp;1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!serializer.[i]&nbsp;stream&nbsp;fields.[i];;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;serializeMany&nbsp;:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('a&nbsp;-&gt;&nbsp;'b&nbsp;-&gt;&nbsp;unit)&nbsp;ref&nbsp;[]&nbsp;-&gt;&nbsp;(obj&nbsp;-&gt;&nbsp;'b&nbsp;[])&nbsp;-&gt;&nbsp;'a&nbsp;-&gt;&nbsp;obj&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>A union case can be serialized as its tag followed by its arguments as 
      follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;serializeUnionCase&nbsp;getTag&nbsp;(data:&nbsp;_&nbsp;[])&nbsp;stream&nbsp;x&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;tag&nbsp;=&nbsp;getTag&nbsp;x<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;getFields,&nbsp;serializer&nbsp;=&nbsp;data.[tag]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writeInt&nbsp;stream&nbsp;tag<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serializeMany&nbsp;serializer&nbsp;getFields&nbsp;stream&nbsp;x;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;serializeUnionCase&nbsp;:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('a&nbsp;-&gt;&nbsp;int)&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((obj&nbsp;-&gt;&nbsp;'b&nbsp;[])&nbsp;*&nbsp;('c&nbsp;-&gt;&nbsp;'b&nbsp;-&gt;&nbsp;unit)&nbsp;ref&nbsp;[])&nbsp;[]&nbsp;-&gt;&nbsp;'c&nbsp;-&gt;&nbsp;'a&nbsp;-&gt;&nbsp;unit<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when&nbsp;'c&nbsp;:&gt;&nbsp;IO.Stream</CODE></P>
      <P>Note how the inferred type is almost as long as the function 
itself!</P>
      <P>The following <CODE>getSerializer</CODE> function tries to find the 
      serializer for the given type in the global dictionary, generating and 
      inserting one if necessary:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;getSerializer&nbsp;ty&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;serialize&nbsp;=&nbsp;Unchecked.defaultof&lt;_&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;&lt;|&nbsp;serializers.TryGetValue(ty,&nbsp;&amp;serialize)&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;serialize&nbsp;=&nbsp;ref&nbsp;Unchecked.defaultof&lt;_&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serializers.[ty]&nbsp;&lt;-&nbsp;serialize<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serialize&nbsp;:=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ty.IsArray&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ty.GetElementType()&nbsp;|&gt;&nbsp;getSerializer&nbsp;|&gt;&nbsp;serializeArray<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;Reflection.FSharpType.IsRecord&nbsp;ty&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;serializer&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|for&nbsp;field&nbsp;in&nbsp;Reflection.FSharpType.GetRecordFields&nbsp;ty&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getSerializer&nbsp;field.PropertyType|]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;getFields&nbsp;=&nbsp;Reflection.FSharpValue.PreComputeRecordReader&nbsp;ty<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serializeMany&nbsp;serializer&nbsp;getFields<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;Reflection.FSharpType.IsTuple&nbsp;ty&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;serializer&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reflection.FSharpType.GetTupleElements&nbsp;ty<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Array.map&nbsp;getSerializer<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;getFields&nbsp;=&nbsp;Reflection.FSharpValue.PreComputeTupleReader&nbsp;ty<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serializeMany&nbsp;serializer&nbsp;getFields<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;Reflection.FSharpType.IsUnion&nbsp;ty&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;data&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|for&nbsp;info&nbsp;in&nbsp;Reflection.FSharpType.GetUnionCases&nbsp;ty&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reflection.FSharpValue.PreComputeUnionReader&nbsp;info,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|for&nbsp;info&nbsp;in&nbsp;info.GetFields()&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getSerializer&nbsp;info.PropertyType|]|]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;getTag&nbsp;=&nbsp;Reflection.FSharpValue.PreComputeUnionTagReader&nbsp;ty<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serializeUnionCase&nbsp;getTag&nbsp;data<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;failwithf&nbsp;"Cannot&nbsp;serialize&nbsp;values&nbsp;of&nbsp;type&nbsp;%s"&nbsp;ty.Name<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serializers.[ty];;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;getSerializer&nbsp;:&nbsp;Type&nbsp;-&gt;&nbsp;(IO.Stream&nbsp;-&gt;&nbsp;obj&nbsp;-&gt;&nbsp;unit)&nbsp;ref</CODE></P>
      <P>Note how the dictionary entry is initialized with a reference to a 
      dummy (null) function before it is set to the real serializer. This allows 
      the recursive call to <CODE>getSerializer</CODE> to return the same 
      reference safe in the knowledge that it will be set before it will be 
      invoked.</P>
      <P>The following <CODE>serialize</CODE> function uses the 
      <CODE>getSerializer</CODE> function to obtain a serializer for the type of 
      the given value:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;serialize&nbsp;x&nbsp;(stream:&nbsp;System.IO.Stream)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!(getSerializer&nbsp;(x.GetType()))&nbsp;stream&nbsp;(box&nbsp;x);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;serialize&nbsp;:&nbsp;'a&nbsp;-&gt;&nbsp;IO.Stream&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>The following <CODE>save</CODE> function uses a 
      <CODE>MemoryStream</CODE> to convert a value into byte array:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;save&nbsp;x&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;stream&nbsp;=&nbsp;new&nbsp;System.IO.MemoryStream()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serialize&nbsp;x&nbsp;stream<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream.ToArray();;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;save&nbsp;:&nbsp;'a&nbsp;-&gt;&nbsp;byte&nbsp;[]</CODE></P>
      <P>With our new structural serializer we find that our value of the type 
      <CODE>Person</CODE> is encoded in a more respectable 11 bytes compared to 
      the 147 bytes required by the default .NET binary serializer and the 37 
      bytes required by JSON:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;(save&nbsp;{&nbsp;Name="Jon";&nbsp;Age=34&nbsp;}).Length;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;int&nbsp;=&nbsp;11</CODE></P>
      <H3>Deserialization</H3>
      <P>The reverse process of deserializing the sequence of bytes from a 
      stream back into a structured value may be performed using code written in 
      a similar style.</P>
      <P>The following <CODE>read</CODE> function reads a given number of bytes 
      into an array:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;read&nbsp;(stream:&nbsp;System.IO.Stream)&nbsp;n&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;xs&nbsp;=&nbsp;Array.create&nbsp;n&nbsp;0uy<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;loop&nbsp;i&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;length&nbsp;=&nbsp;stream.Read(xs,&nbsp;i,&nbsp;n-i)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;i&nbsp;=&nbsp;i&nbsp;+&nbsp;length<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;i=n&nbsp;then&nbsp;()&nbsp;else&nbsp;loop&nbsp;i<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xs;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;read&nbsp;:&nbsp;IO.Stream&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;byte&nbsp;[]</CODE></P>
      <P>Note the complexity here arises because the <CODE>Read</CODE> member 
      does not necessarily read the requested number of bytes.</P>
      <P>The following functions deserialize first-order values:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;readInt&nbsp;stream&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.BitConverter.ToInt32(read&nbsp;stream&nbsp;4,&nbsp;0);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;readInt&nbsp;:&nbsp;IO.Stream&nbsp;-&gt;&nbsp;int<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;readInt64&nbsp;stream&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.BitConverter.ToInt64(read&nbsp;stream&nbsp;8,&nbsp;0);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;readInt64&nbsp;:&nbsp;IO.Stream&nbsp;-&gt;&nbsp;int64<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;readFloat&nbsp;stream&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.BitConverter.ToDouble(read&nbsp;stream&nbsp;8,&nbsp;0);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;readFloat&nbsp;:&nbsp;IO.Stream&nbsp;-&gt;&nbsp;float<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;readComplex&nbsp;stream&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.Numerics.Complex(readFloat&nbsp;stream,&nbsp;readFloat&nbsp;stream);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;readComplex&nbsp;:&nbsp;IO.Stream&nbsp;-&gt;&nbsp;Numerics.Complex<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;readDecimal&nbsp;stream&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;ns&nbsp;=&nbsp;Array.init&nbsp;4&nbsp;(fun&nbsp;_&nbsp;-&gt;&nbsp;readInt&nbsp;stream)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.Decimal&nbsp;ns;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;readDecimal&nbsp;:&nbsp;IO.Stream&nbsp;-&gt;&nbsp;Decimal<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;readDateTime&nbsp;stream&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readInt64&nbsp;stream<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;System.DateTime.FromBinary;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;readDateTime&nbsp;:&nbsp;IO.Stream&nbsp;-&gt;&nbsp;DateTime<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;readString&nbsp;stream&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;e&nbsp;=&nbsp;System.Text.UTF8Encoding()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read&nbsp;stream&nbsp;(readInt&nbsp;stream)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;e.GetString;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;readString&nbsp;:&nbsp;IO.Stream&nbsp;-&gt;&nbsp;string</CODE></P>
      <P>We create a dictionary mapping types to deserialization functions as 
      before:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;deserializers&nbsp;=&nbsp;Dictionary&lt;System.Type,&nbsp;(System.IO.Stream&nbsp;-&gt;&nbsp;obj)&nbsp;ref&gt;();;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;deserializers&nbsp;:&nbsp;Dictionary&lt;Type,(IO.Stream&nbsp;-&gt;&nbsp;obj)&nbsp;ref&gt;&nbsp;=&nbsp;dict&nbsp;[]</CODE></P>
      <P>The following <CODE>addDeserializer</CODE> function registers the given 
      function as a deserializer using its return type as the key:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;addDeserializer&nbsp;:&nbsp;(IO.Stream&nbsp;-&gt;&nbsp;'a)&nbsp;-&gt;&nbsp;unit&nbsp;=&nbsp;fun&nbsp;f&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deserializers.[typeof&lt;'a&gt;]&nbsp;&lt;-&nbsp;ref(f&nbsp;&gt;&gt;&nbsp;box);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;addDeserializer&nbsp;:&nbsp;(IO.Stream&nbsp;-&gt;&nbsp;'a)&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>The first-order deserializers may then be registered as follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addDeserializer&nbsp;readInt<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addDeserializer&nbsp;readFloat<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addDeserializer&nbsp;readComplex<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addDeserializer&nbsp;readDecimal<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addDeserializer&nbsp;readDateTime<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addDeserializer&nbsp;readString;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;unit&nbsp;=&nbsp;()</CODE></P>
      <P>Now for the higher-order deserializers. The following 
      <CODE>deserializeArray</CODE> function deserializes an array of 
      arbitrary-dimensionality:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;deserializeArray&nbsp;eltTy&nbsp;deserialize&nbsp;rank&nbsp;stream&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;length&nbsp;=&nbsp;Array.init&nbsp;rank&nbsp;(fun&nbsp;_&nbsp;-&gt;&nbsp;readInt&nbsp;stream)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;xs&nbsp;=&nbsp;System.Array.CreateInstance(eltTy,&nbsp;Array.map&nbsp;int64&nbsp;length)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;index&nbsp;=&nbsp;Array.zeroCreate&nbsp;rank<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i=0&nbsp;to&nbsp;Seq.fold&nbsp;(*)&nbsp;1&nbsp;length&nbsp;-&nbsp;1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;j=rank-1&nbsp;downto&nbsp;1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;index.[j]&nbsp;=&nbsp;length.[j]&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index.[j]&nbsp;&lt;-&nbsp;0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index.[j-1]&nbsp;&lt;-&nbsp;index.[j-1]&nbsp;+&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xs.SetValue(!deserialize&nbsp;stream&nbsp;|&gt;&nbsp;unbox,&nbsp;index)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index.[rank-1]&nbsp;&lt;-&nbsp;index.[rank-1]&nbsp;+&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;box&nbsp;xs;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;deserializeArray&nbsp;:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;-&gt;&nbsp;('a&nbsp;-&gt;&nbsp;'b)&nbsp;ref&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;'a&nbsp;-&gt;&nbsp;obj&nbsp;when&nbsp;'a&nbsp;:&gt;&nbsp;IO.Stream</CODE></P>
      <P>Note how the <CODE>index</CODE> is updated from one element to the next 
      using a ripple adder.</P>
      <P>The following <CODE>deserializeMany</CODE> function deserializes a 
      sequence of values of different types and then composes the result using 
      the given <CODE>make</CODE> function:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;deserializeMany&nbsp;deserializers&nbsp;make&nbsp;stream&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array.map&nbsp;(fun&nbsp;f&nbsp;-&gt;&nbsp;!f&nbsp;stream)&nbsp;deserializers<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;make;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;deserializeMany&nbsp;:&nbsp;('a&nbsp;-&gt;&nbsp;'b)&nbsp;ref&nbsp;[]&nbsp;-&gt;&nbsp;('b&nbsp;[]&nbsp;-&gt;&nbsp;'c)&nbsp;-&gt;&nbsp;'a&nbsp;-&gt;&nbsp;'c</CODE></P>
      <P>This function will be used to deserialize the fields of a record, 
      elements of a tuple and arguments of a union case.</P>
      <P>The following <CODE>deserializeUnionCase</CODE> function reads the tag 
      integer and then uses the appropriate set of deserializers for the 
      corresponding arguments (if any) to compose a union case:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;deserializeUnionCase&nbsp;(data:&nbsp;_&nbsp;[])&nbsp;stream&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;tag&nbsp;=&nbsp;readInt&nbsp;stream<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;makeUnionCase,&nbsp;deserializers&nbsp;=&nbsp;data.[tag]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deserializeMany&nbsp;deserializers&nbsp;makeUnionCase&nbsp;stream;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;deserializeUnionCase&nbsp;:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(('a&nbsp;[]&nbsp;-&gt;&nbsp;'b)&nbsp;*&nbsp;('c&nbsp;-&gt;&nbsp;'a)&nbsp;ref&nbsp;[])&nbsp;[]&nbsp;-&gt;&nbsp;'c&nbsp;-&gt;&nbsp;'b&nbsp;when&nbsp;'c&nbsp;:&gt;&nbsp;IO.Stream</CODE></P>
      <P>The core of the deserialization code is the following 
      <CODE>getDeserializer</CODE> function:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;getDeserializer&nbsp;ty&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;deserialize&nbsp;=&nbsp;Unchecked.defaultof&lt;_&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;&lt;|&nbsp;deserializers.TryGetValue(ty,&nbsp;&amp;deserialize)&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;deserialize&nbsp;=&nbsp;ref&nbsp;Unchecked.defaultof&lt;_&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deserializers.[ty]&nbsp;&lt;-&nbsp;deserialize<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deserialize&nbsp;:=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ty.IsArray&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;eltTy&nbsp;=&nbsp;ty.GetElementType()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;deserialize&nbsp;=&nbsp;getDeserializer&nbsp;eltTy<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rank&nbsp;=&nbsp;ty.GetArrayRank()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deserializeArray&nbsp;eltTy&nbsp;deserialize&nbsp;rank<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;Reflection.FSharpType.IsRecord&nbsp;ty&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;deserializers&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reflection.FSharpType.GetRecordFields&nbsp;ty<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Array.map&nbsp;(fun&nbsp;info&nbsp;-&gt;&nbsp;getDeserializer&nbsp;info.PropertyType)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;makeRecord&nbsp;=&nbsp;Reflection.FSharpValue.PreComputeRecordConstructor&nbsp;ty<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deserializeMany&nbsp;deserializers&nbsp;makeRecord<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;Reflection.FSharpType.IsTuple&nbsp;ty&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;deserializers&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reflection.FSharpType.GetTupleElements&nbsp;ty<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Array.map&nbsp;getDeserializer<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;makeTuple&nbsp;=&nbsp;Reflection.FSharpValue.PreComputeTupleConstructor&nbsp;ty<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deserializeMany&nbsp;deserializers&nbsp;makeTuple<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;Reflection.FSharpType.IsUnion&nbsp;ty&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deserializeUnionCase<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|for&nbsp;case&nbsp;in&nbsp;Reflection.FSharpType.GetUnionCases&nbsp;ty&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reflection.FSharpValue.PreComputeUnionConstructor&nbsp;case,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|for&nbsp;field&nbsp;in&nbsp;case.GetFields()&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getDeserializer&nbsp;field.PropertyType|]|]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;failwithf&nbsp;"Cannot&nbsp;deserialize&nbsp;values&nbsp;of&nbsp;type&nbsp;%s"&nbsp;ty.Name<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deserializers.[ty];;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;getDeserializer&nbsp;:&nbsp;Type&nbsp;-&gt;&nbsp;(IO.Stream&nbsp;-&gt;&nbsp;obj)&nbsp;ref</CODE></P>
      <P>The following <CODE>deserialize</CODE> function uses the 
      <CODE>getDeserializer</CODE> function to obtain the appropriate 
      deserialization function and run-time type casts the resulting value to 
      the appropriate type:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;deserialize&nbsp;stream&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!(getDeserializer&nbsp;typeof&lt;'a&gt;)&nbsp;stream&nbsp;:?&gt;&nbsp;'a;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;deserialize&nbsp;:&nbsp;IO.Stream&nbsp;-&gt;&nbsp;'a</CODE></P>
      <P>Note how the type variable <CODE>'a</CODE> appears both in the argument 
      to the call to <CODE>getDeserializer</CODE> and in the cast. This causes 
      the <CODE>deserialize</CODE> function to get the deserializer appropriate 
      for its own return type.</P>
      <P>Again, a <CODE>MemoryStream</CODE> can be initialized to a given byte 
      array in order to load a value from a byte array rather than a stream:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;load&nbsp;(bytes:&nbsp;byte&nbsp;[])&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;stream&nbsp;=&nbsp;new&nbsp;System.IO.MemoryStream(bytes)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deserialize&nbsp;stream;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;load&nbsp;:&nbsp;byte&nbsp;[]&nbsp;-&gt;&nbsp;'a</CODE></P>
      <P>This program is capable of serializing and deserializing values 
      structurally as expected:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;load(save&nbsp;xs)&nbsp;=&nbsp;xs;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;bool&nbsp;=&nbsp;true</CODE></P>
      <H2>Summary</H2>
      <P>This article has looked at the shortcomings of some of the built-in 
      .NET serializers and has covered the design and implementation of a simple 
      F# library that structurally serializes values of many F# efficiently.</P>
      <P>Future F#.NET Journal articles will revisit the subjects of reflection 
      and serialization.</P></TD></TR></TBODY></TABLE>
<TABLE id=footer>
  <TBODY>
  <TR>
    <TD> Flying Frog Consultancy Ltd., 2011</TD>
    <TD>Contact the <A href="mailto:webmaster@ffconsultancy.com">webmaster</A> 
    </TD></TR></TBODY></TABLE>
<SCRIPT type=text/javascript 
src="F%23%20Journal%20fast%20structural%20serialization_files/urchin.js">
    <script type="text/javascript">_uacct = "UA-197840-1"; urchinTracker();</SCRIPT>
</BODY></HTML>
