<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0079)http://www.ffconsultancy.com/products/fsharp_journal/subscribers/quicksort.html -->
<!--?xml version="1.0" encoding="iso-8859-1"?--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><HTML><HEAD><META 
content="IE=10.000" http-equiv="X-UA-Compatible">
     <TITLE>F# Journal</TITLE>     
<META http-equiv="Content-Type" content="text/html; charset=windows-1252"><LINK 
href="F%23%20Journal%20quicksort_files/style.css" rel="stylesheet" type="text/css"> 
    <LINK href="F%23%20Journal%20quicksort_files/style(1).css" rel="stylesheet" 
type="text/css">     <LINK href="F%23%20Journal%20quicksort_files/individual.css" 
rel="stylesheet" type="text/css">   
<META name="GENERATOR" content="MSHTML 10.00.9200.16458"></HEAD>   
<BODY>
<TABLE id="logo">
  <TBODY>
  <TR>
    <TD width="100%"><IMG src="F%23%20Journal%20quicksort_files/title.gif">    
           </TD>
    <TD><IMG src="F%23%20Journal%20quicksort_files/left.gif">         
  </TD></TR></TBODY></TABLE>
<TABLE id="menu">
  <TBODY>
  <TR>
    <TD width="25%">
    <TD width="25%"><A 
      href="http://www.ffconsultancy.com/products/index.html">Home Page</A>      
         </TD>
    <TD width="25%"><A href="http://www.ffconsultancy.com/products/fsharp_journal/subscribers/index.html">The 
      F# Journal</A>         </TD>
    <TD width="25%"></TR></TBODY></TABLE>
<TABLE id="page">
  <TBODY>
  <TR>
    <TD>
      <H1>Quicksort</H1>
      <P>The quicksort algorithm was invented by Tony Hoare in 1960 and remains 
      one of the most celebrated algorithms and is still of great practical 
      value. Implementing some of the many variations of the quicksort algorithm 
      serves as an excellent introduction to mixed-paradigm programming in F# 
      and the implementation of a production-quality implementation benefits 
      enormously from the use of a substantial number of exotic features of the 
      F# language. Moreover, the quicksort algorithm is amenable to 
      parallelization, which is of increasing relevance in the multicore era, so 
      the performance characteristics of parallelizations of the implementations 
      are also of great interest.</P>
      <H2>Introduction</H2>
      <P>Quicksort is a simple and effective sorting algorithm that uses a 
      divide and conquer strategy to recursively subdivide a sequence of 
      elements in order to sort progressively smaller subsequences. The 
      algorithm consists of three simple steps:</P>
      <UL>
        <LI>Choose a "pivot" element.</LI>
        <LI>Partition the sequence into subsequences according to their order 
        relative to the pivot.</LI>
        <LI>Quicksort the subsequences.</LI></UL>
      <P>Ideally, the work will be divided into equal halves in which case the 
      pivot element must have been the median of the sequence. In practice, 
      finding the exact median is computationally expensive so faster 
      approximations are used. This algorithm is O(n log n) average case but can 
      degenerate to O(n^2) if one of the subsequences has a constant length 
      because the pivot was chosen badly. The algorithm also uses O(log n) stack 
      space on average but may degenerate to O(n) stack space which would be 
      likely to overflow the stack.</P>
      <P>In particular, the original paper described a procedure for 
      partitioning the elements of an array in-place by repeated swapping. This 
      allows the entire sort to be performed in place which was originally 
      beneficial because memory was a precious resource but has remaining 
      beneficial because locality is a valuable characteristic for performance 
      and memory bandwidth is a precious resource.</P>
      <H2>Out-of-place quicksort</H2>
      <P>The following function is often cited as an elegant example of 
      functional programming:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;sort&nbsp;:&nbsp;int&nbsp;list&nbsp;-&gt;&nbsp;_&nbsp;=&nbsp;function<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;[]&nbsp;-&gt;&nbsp;[]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x::xs&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;less,&nbsp;greater&nbsp;=&nbsp;List.partition&nbsp;((&gt;)&nbsp;x)&nbsp;xs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;less&nbsp;@&nbsp;x&nbsp;::&nbsp;sort&nbsp;greater;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;sort&nbsp;:&nbsp;int&nbsp;list&nbsp;-&gt;&nbsp;int&nbsp;list</CODE></P>
      <P>Note the use of <CODE>(&gt;)&nbsp;x</CODE> to obtain the greater-than 
      operator in curried form and partially apply it with <CODE>x</CODE>. This 
      is equivalent to 
      <CODE>fun&nbsp;y&nbsp;-&gt;&nbsp;x&nbsp;&gt;&nbsp;y</CODE>. We shall also 
      use type annotations to remove genericity and defer its discussion to the 
      end of this article.</P>
      <P>This <CODE>sort</CODE> function acts upon lists, using the first 
      element as the pivot at each step and using the built-in 
      <CODE>List.partition</CODE> function to partition the tail list 
      <CODE>xs</CODE> into elements less than or equal to the pivot and elements 
      greater than the pivot. These two sublists are recursively sorted and then 
      combined by appending <CODE>sort&nbsp;less</CODE> onto the element 
      <CODE>x</CODE> prepended onto <CODE>sort&nbsp;greater</CODE>.</P>
      <P>For example:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;sort&nbsp;[1;9;2;8;3;7;4;6;5];;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;int&nbsp;list&nbsp;=&nbsp;[1;&nbsp;2;&nbsp;3;&nbsp;4;&nbsp;5;&nbsp;6;&nbsp;7;&nbsp;8;&nbsp;9]</CODE></P>
      <P>There are two main problems with this <CODE>sort</CODE> function. 
      Firstly, choosing the first element as the pivot makes already-sorted 
      lists the pathological case that causes the algorithm to degenerate to 
      quadratic behaviour. For example, sorting a list of 10,000 random integers 
      takes only 0.174s but sorting the sorted list takes almost 19s:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rand&nbsp;=&nbsp;System.Random();;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;rand&nbsp;:&nbsp;System.Random<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;xs&nbsp;=&nbsp;[for&nbsp;_&nbsp;in&nbsp;1..10000&nbsp;-&gt;&nbsp;rand.Next()];;<BR>&nbsp;&nbsp;&nbsp;&nbsp;...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;ys&nbsp;=&nbsp;sort&nbsp;xs;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;Real:&nbsp;00:00:00.174,&nbsp;CPU:&nbsp;00:00:00.062,&nbsp;GC&nbsp;gen0:&nbsp;2,&nbsp;gen1:&nbsp;2,&nbsp;gen2:&nbsp;0<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;sort&nbsp;ys;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;Real:&nbsp;00:00:18.953,&nbsp;CPU:&nbsp;00:00:18.938,&nbsp;GC&nbsp;gen0:&nbsp;629,&nbsp;gen1:&nbsp;18,&nbsp;gen2:&nbsp;0</CODE></P>
      <P>Secondly, both the <CODE>List.partition</CODE> function and 
      <CODE>@</CODE> operator copy a lot of data. This unnecessary copying is 
      not only a direct impediment to performance but also destroys scalability 
      because it stresses the garbage collector and memory bandwidth. This is 
      most easily seen by measuring the performance improvement of the seemingly 
      parallel version. Sorting 10,000,000 random integers with the serial 
      implementation takes 60.6s:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;xs&nbsp;=&nbsp;[for&nbsp;_&nbsp;in&nbsp;1..10000000&nbsp;-&gt;&nbsp;rand.Next()];;<BR>&nbsp;&nbsp;&nbsp;&nbsp;...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;sort&nbsp;xs<BR>&nbsp;&nbsp;&nbsp;&nbsp;Real:&nbsp;00:01:00.635,&nbsp;CPU:&nbsp;00:01:02.774,&nbsp;GC&nbsp;gen0:&nbsp;1206,&nbsp;gen1:&nbsp;735,&nbsp;gen2:&nbsp;5</CODE></P>
      <P>A simple parallel version may be written by performing subsorts in 
      parallel when there is a sufficient amount of work to do:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;sort&nbsp;:&nbsp;int&nbsp;list&nbsp;-&gt;&nbsp;_&nbsp;=&nbsp;function<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;[]&nbsp;-&gt;&nbsp;[]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x::xs&nbsp;-&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;less,&nbsp;greater&nbsp;=&nbsp;List.partition&nbsp;((&gt;)&nbsp;x)&nbsp;xs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;thresh&nbsp;=&nbsp;1024<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;List.length&nbsp;less&nbsp;&lt;&nbsp;thresh&nbsp;||&nbsp;List.length&nbsp;greater&nbsp;&lt;&nbsp;thresh&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;less&nbsp;@&nbsp;x&nbsp;::&nbsp;sort&nbsp;greater<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;less&nbsp;=&nbsp;System.Threading.Tasks.Task.Factory.StartNew(fun&nbsp;()&nbsp;-&gt;&nbsp;sort&nbsp;less)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greater&nbsp;=&nbsp;sort&nbsp;greater<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;less.Result&nbsp;@&nbsp;x&nbsp;::&nbsp;greater<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;sort&nbsp;:&nbsp;int&nbsp;list&nbsp;-&gt;&nbsp;int&nbsp;list</CODE></P>
      <P>Although the parallel implementation appears superficially as though it 
      should be effective it actually severely degrades performance on this 8 
      core machine:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;xs&nbsp;=&nbsp;[for&nbsp;_&nbsp;in&nbsp;1..10000000&nbsp;-&gt;&nbsp;rand.Next()];;<BR>&nbsp;&nbsp;&nbsp;&nbsp;...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;sort&nbsp;xs<BR>&nbsp;&nbsp;&nbsp;&nbsp;Real:&nbsp;00:02:45.449,&nbsp;CPU:&nbsp;00:03:48.681,&nbsp;GC&nbsp;gen0:&nbsp;1305,&nbsp;gen1:&nbsp;909,&nbsp;gen2:&nbsp;20</CODE></P>
      <P>Functional programming is increasingly touted as a panacea for parallel 
      programming in the multicore era and characteristics of this 
      purely-functional quicksort clearly demonstrate otherwise, at least in the 
      context of .NET. In fact, we can beat the performance of this parallel 
      purely-functional implementation simply by switching to arrays, 
      specifically the extensible <CODE>ResizeArray</CODE> data structure, but 
      still sorting out-of-place:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;sort&nbsp;(xs:&nbsp;ResizeArray&lt;int&gt;)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;xs.Count&nbsp;&lt;&nbsp;2&nbsp;then&nbsp;xs&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x&nbsp;=&nbsp;xs.[0]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;less,&nbsp;greater&nbsp;=&nbsp;ResizeArray(),&nbsp;ResizeArray()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i=1&nbsp;to&nbsp;xs.Count-1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;y&nbsp;=&nbsp;xs.[i]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;x&nbsp;&gt;&nbsp;y&nbsp;then&nbsp;less.Add&nbsp;y&nbsp;else&nbsp;greater.Add&nbsp;y<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;less,&nbsp;greater&nbsp;=&nbsp;sort&nbsp;less,&nbsp;sort&nbsp;greater<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;ys&nbsp;=&nbsp;ResizeArray()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ys.Capacity&nbsp;&lt;-&nbsp;xs.Count<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i=0&nbsp;to&nbsp;less.Count-1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ys.Add&nbsp;less.[i]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ys.Add&nbsp;x<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i=0&nbsp;to&nbsp;greater.Count-1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ys.Add&nbsp;greater.[i]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ys;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;sort&nbsp;:&nbsp;ResizeArray&lt;int&gt;&nbsp;-&gt;&nbsp;ResizeArray&lt;int&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;xs&nbsp;=&nbsp;ResizeArray(Array.init&nbsp;10000000&nbsp;(fun&nbsp;_&nbsp;-&gt;&nbsp;rand.Next()));;<BR>&nbsp;&nbsp;&nbsp;&nbsp;...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;ys&nbsp;=&nbsp;sort&nbsp;xs;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;Real:&nbsp;00:00:11.831,&nbsp;CPU:&nbsp;00:00:11.996,&nbsp;GC&nbsp;gen0:&nbsp;746,&nbsp;gen1:&nbsp;236,&nbsp;gen2:&nbsp;5<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;ys&nbsp;:&nbsp;ResizeArray&lt;int&gt;</CODE></P>
      <P>The result can be checked against the result given by 
      <CODE>Array.sort</CODE> as follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;ys.ToArray()&nbsp;=&nbsp;Array.sort(xs.ToArray());;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;bool&nbsp;=&nbsp;true</CODE></P>
      <P>Note that we must be careful to convert the <CODE>ResizeArray</CODE> 
      (which is an alias for <CODE>System.Collections.Generic.List</CODE>) into 
      an ordinary array before comparing for equality, otherwise we get 
      reference equality which always returns <CODE>false</CODE> in this 
      case.</P>
      <P>This <CODE>ResizeArray</CODE>-based implementation is over 5× faster 
      than the purely-functional list-based implementation simply because it 
      copies less. Moreover, it can be parallelized more effectively because it 
      inhibits scalability a lot less:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;open&nbsp;System.Threading;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;sort&nbsp;(xs:&nbsp;ResizeArray&lt;int&gt;)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;xs.Count&nbsp;&lt;&nbsp;2&nbsp;then&nbsp;xs&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x&nbsp;=&nbsp;xs.[0]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;less,&nbsp;greater&nbsp;=&nbsp;ResizeArray(),&nbsp;ResizeArray()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i=1&nbsp;to&nbsp;xs.Count-1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;y&nbsp;=&nbsp;xs.[i]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;x&nbsp;&gt;&nbsp;y&nbsp;then&nbsp;less.Add&nbsp;y&nbsp;else&nbsp;greater.Add&nbsp;y<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;ys&nbsp;=&nbsp;ResizeArray()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;fill&nbsp;(less:&nbsp;ResizeArray&lt;int&gt;)&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ys.Capacity&nbsp;&lt;-&nbsp;xs.Count<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i=0&nbsp;to&nbsp;less.Count-1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ys.Add&nbsp;less.[i]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ys.Add&nbsp;x<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greater&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;less.Count&nbsp;&lt;&nbsp;1024&nbsp;||&nbsp;greater.Count&nbsp;&lt;&nbsp;1024&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;less,&nbsp;greater&nbsp;=&nbsp;sort&nbsp;less,&nbsp;sort&nbsp;greater<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill&nbsp;less<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;greater<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;greater&nbsp;=&nbsp;System.Threading.Tasks.Task&lt;_&gt;.Factory.StartNew(fun&nbsp;()&nbsp;-&gt;&nbsp;sort&nbsp;greater)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fill(sort&nbsp;less)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;greater.Result<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i=0&nbsp;to&nbsp;greater.Count-1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ys.Add&nbsp;greater.[i]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ys;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;sort&nbsp;:&nbsp;ResizeArray&lt;int&gt;&nbsp;-&gt;&nbsp;ResizeArray&lt;int&gt;</CODE></P>
      <P>Note that, in the parallelized branch, we are careful to spawn the 
      subsort for the <CODE>greater</CODE> sequence (rather than 
      <CODE>less</CODE>) first because its result is needed last. This increases 
      the probability that the spawned operation will have completed before the 
      <CODE>Result</CODE> property is used to obtain its return value.</P>
      <P>Unlike the list-based parallel sort, this array-based parallel sort 
      improves performance over its serial counterpart:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;ys&nbsp;=&nbsp;sort&nbsp;xs;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;Real:&nbsp;00:00:07.364,&nbsp;CPU:&nbsp;00:00:24.882,&nbsp;GC&nbsp;gen0:&nbsp;605,&nbsp;gen1:&nbsp;395,&nbsp;gen2:&nbsp;23<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;ys&nbsp;:&nbsp;ResizeArray&lt;int&gt;</CODE></P>
      <P>The CPU time is 2× longer than the serial implementation but this is 
      spread across several CPUs so the parallel implementation is 60% faster. 
      However, performance can be improved a lot further by performing the sort 
      in-place.</P>
      <H2>In-place quicksort</H2>
      <P>The performance and memory consumption of the out-of-place quicksorts 
      can be addressed by sorting an array in-place, using swaps to partition 
      the elements in-place. The following <CODE>swap</CODE> function swaps a 
      pair of elements in an array:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;swap&nbsp;(a:&nbsp;int&nbsp;[])&nbsp;i&nbsp;j&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;t&nbsp;=&nbsp;a.[i]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.[i]&nbsp;&lt;-&nbsp;a.[j]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.[j]&nbsp;&lt;-&nbsp;t<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;swap&nbsp;:&nbsp;int&nbsp;[]&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>Sedgewick gives the following C implementation of the in-place 
      quicksort:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;quicksort(double&nbsp;a[],&nbsp;int&nbsp;l,&nbsp;int&nbsp;r)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;l-1,&nbsp;j&nbsp;=&nbsp;r;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;v&nbsp;=&nbsp;a[r];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;=&nbsp;l)&nbsp;return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;;)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(a[++i]&nbsp;&lt;&nbsp;v)&nbsp;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(v&nbsp;&lt;&nbsp;a[--j])&nbsp;if&nbsp;(j&nbsp;==&nbsp;l)&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;&gt;=&nbsp;j)&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exch(a[i],&nbsp;a[j]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exch(a[i],&nbsp;a[r]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quicksort(a,&nbsp;l,&nbsp;i-1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quicksort(a,&nbsp;i+1,&nbsp;r);<BR>&nbsp;&nbsp;&nbsp;&nbsp;}</CODE></P>
      <P>However, this elegant C program makes use of the <CODE>break</CODE> 
      instruction that is not present in the F# programming language. This 
      raises the question of how this C program might be translated into 
      idiomatic F# code. This is, of course, a general problem encountered when 
      translated almost any imperative program into F#.</P>
      <P>Intuitively, the simplest translation is to replace the mutable local 
      variables with <CODE>ref</CODE> cells in F# and resort to nested recursive 
      functions when a loop cannot be used. This leads to the following 
      translation:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;sort&nbsp;(a:&nbsp;_&nbsp;[])&nbsp;l&nbsp;r&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;i&nbsp;=&nbsp;ref(l&nbsp;-&nbsp;1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;j&nbsp;=&nbsp;ref&nbsp;r<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;v&nbsp;=&nbsp;a.[r]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;r&nbsp;&gt;&nbsp;l&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;loop()&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;incr&nbsp;i<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;a.[!i]&nbsp;&lt;&nbsp;v&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;incr&nbsp;i<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decr&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;v&nbsp;&lt;&nbsp;a.[!j]&nbsp;&amp;&amp;&nbsp;!j&nbsp;&lt;&gt;&nbsp;l&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decr&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;!i&nbsp;&lt;&nbsp;!j&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;!i&nbsp;!j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;!i&nbsp;r<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;a&nbsp;l&nbsp;(!i&nbsp;-&nbsp;1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;a&nbsp;(!i&nbsp;+&nbsp;1)&nbsp;r<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop()<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;sort&nbsp;:&nbsp;int&nbsp;[]&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>However, trying to apply this function produces array of bounds 
      exceptions. This turns out to be because Sedgewick's original C code had a 
      bug where <CODE>a[r]</CODE> was read even if it was out of bounds. This 
      bug caught by the safety of .NET and easily fixed in F# by bringing the 
      definitions of <CODE>i</CODE>, <CODE>j</CODE> and <CODE>v</CODE> inside 
      the initial <CODE>if</CODE> expression:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;sort&nbsp;(a:&nbsp;_&nbsp;[])&nbsp;l&nbsp;r&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;r&nbsp;&gt;&nbsp;l&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;i&nbsp;=&nbsp;ref(l&nbsp;-&nbsp;1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;j&nbsp;=&nbsp;ref&nbsp;r<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;v&nbsp;=&nbsp;a.[r]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</CODE></P>
      <P>Sorting ten million integers takes 3.29s with this simple serial 
      in-place quicksort:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;ys&nbsp;=&nbsp;Array.copy&nbsp;xs;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;sort&nbsp;ys&nbsp;0&nbsp;(ys.Length&nbsp;-&nbsp;1);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;Real:&nbsp;00:00:03.292,&nbsp;CPU:&nbsp;00:00:03.260,&nbsp;GC&nbsp;gen0:&nbsp;50,&nbsp;gen1:&nbsp;1,&nbsp;gen2:&nbsp;0</CODE></P>
      <P>However, <CODE>ref</CODE> is expensive because it incurs boxing and, 
      therefore, heap allocation and indirections. In this case, every 
      <CODE>ref</CODE> can be removed by passing <CODE>i</CODE> and 
      <CODE>j</CODE> as accumulators through calls to <CODE>loop</CODE>:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;sort&nbsp;(a:&nbsp;int&nbsp;[])&nbsp;l&nbsp;r&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;r&nbsp;&gt;&nbsp;l&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;v&nbsp;=&nbsp;a.[r]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;loop&nbsp;i&nbsp;j&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;i&nbsp;=&nbsp;i<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;a.[i]&nbsp;&lt;&nbsp;v&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;&lt;-&nbsp;i&nbsp;+&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;j&nbsp;=&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;v&nbsp;&lt;&nbsp;a.[j]&nbsp;&amp;&amp;&nbsp;j&nbsp;&lt;&gt;&nbsp;l&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;&lt;-&nbsp;j&nbsp;-&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;i&nbsp;&lt;&nbsp;j&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;i&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;(i&nbsp;+&nbsp;1)&nbsp;(j&nbsp;-&nbsp;1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;i&nbsp;r<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;a&nbsp;l&nbsp;(i&nbsp;-&nbsp;1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;a&nbsp;(i&nbsp;+&nbsp;1)&nbsp;r<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;l&nbsp;(r&nbsp;-&nbsp;1);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;sort&nbsp;:&nbsp;int&nbsp;[]&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>This improves performance even further:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;ys&nbsp;=&nbsp;Array.copy&nbsp;xs;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;sort&nbsp;ys&nbsp;0&nbsp;(ys.Length&nbsp;-&nbsp;1);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;Real:&nbsp;00:00:02.415,&nbsp;CPU:&nbsp;00:00:02.386,&nbsp;GC&nbsp;gen0:&nbsp;0,&nbsp;gen1:&nbsp;0,&nbsp;gen2:&nbsp;0</CODE></P>
      <P>Local <CODE>mutable</CODE> values are allocated on the stack and 
      mutated in-place or even held entirely in registers so they do not incur 
      any boxing or allocation. Incidentally, this is why <CODE>ref</CODE> 
      values can escape their scope but <CODE>mutable</CODE> values cannot: 
      their stack frame might not exist elsewhere.</P>
      <P>Immutability can be taken even further in this case by replacing the 
      remaining inner <CODE>while</CODE> loops with nested recursive functions 
      <CODE>loop_i</CODE> and <CODE>loop_j</CODE>, respectively:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;sort&nbsp;(a:&nbsp;_&nbsp;[])&nbsp;l&nbsp;r&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;r&nbsp;&gt;&nbsp;l&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;v&nbsp;=&nbsp;a.[r]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;loop&nbsp;i&nbsp;j&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;loop_i&nbsp;i&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;a.[i]&nbsp;&lt;&nbsp;v&nbsp;then&nbsp;loop_i&nbsp;(i&nbsp;+&nbsp;1)&nbsp;else&nbsp;i<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;loop_j&nbsp;j&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;v&nbsp;&lt;&nbsp;a.[j]&nbsp;&amp;&amp;&nbsp;j&nbsp;&lt;&gt;&nbsp;l&nbsp;then&nbsp;loop_j&nbsp;(j&nbsp;-&nbsp;1)&nbsp;else&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;i,&nbsp;j&nbsp;=&nbsp;loop_i&nbsp;i,&nbsp;loop_j&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;i&nbsp;&lt;&nbsp;j&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;i&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;(i&nbsp;+&nbsp;1)&nbsp;(j&nbsp;-&nbsp;1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;i&nbsp;r<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;a&nbsp;l&nbsp;(i&nbsp;-&nbsp;1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;a&nbsp;(i&nbsp;+&nbsp;1)&nbsp;r<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;l&nbsp;(r&nbsp;-&nbsp;1);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;sort&nbsp;:&nbsp;int&nbsp;[]&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>However, this slightly degrades performance:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;ys&nbsp;=&nbsp;Array.copy&nbsp;xs;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;sort&nbsp;ys&nbsp;0&nbsp;(ys.Length&nbsp;-&nbsp;1);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;Real:&nbsp;00:00:02.844,&nbsp;CPU:&nbsp;00:00:02.839,&nbsp;GC&nbsp;gen0:&nbsp;0,&nbsp;gen1:&nbsp;0,&nbsp;gen2:&nbsp;0</CODE></P>
      <P>This is slower because the nested <CODE>loop_i</CODE> and 
      <CODE>loop_j</CODE> functions capture <CODE>a</CODE> and <CODE>v</CODE> 
      from their environment and pass them as auxiliary arguments through 
      recursive function calls. Even though the recursive calls are optimized 
      into <CODE>goto</CODE> instructions by the F# compiler, the overhead of 
      the initial function call remains high in these cases because these loops 
      typically perform only 1 or 2 iterations.</P>
      <H2>The Dutch National Flag Problem</H2>
      <P>Earlier in the article we identified the pathological case of 
      already-sorted sequences where performance is degraded to quadratic. 
      Another problem case is sequences with large numbers of identical 
      elements. Using the fastest of the previous sorts:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;xs&nbsp;=&nbsp;Array.create&nbsp;10000&nbsp;0&nbsp;in&nbsp;sort&nbsp;xs&nbsp;0&nbsp;(xs.Length&nbsp;-&nbsp;1);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;</CODE></P>
      <P>The Dutch National Flag problem refers to the challenge of 3-way 
      partitioning, in this case into elements less than, equal to and greater 
      than the pivot. Elements from the middle partition, that are equal to the 
      pivot, do not require sorting. Solving this challenge solves our 
      pathological case where there are many repeated elements.</P>
      <P>Sedgewick gives the following C code for quicksort with 3-way 
      partitioning:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;quicksort(Item&nbsp;a[],&nbsp;int&nbsp;l,&nbsp;int&nbsp;r)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;int&nbsp;i&nbsp;=&nbsp;l-1,&nbsp;j&nbsp;=&nbsp;r,&nbsp;p&nbsp;=&nbsp;l-1,&nbsp;q&nbsp;=&nbsp;r;&nbsp;Item&nbsp;v&nbsp;=&nbsp;a[r];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;=&nbsp;l)&nbsp;return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;;)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(a[++i]&nbsp;&lt;&nbsp;v)&nbsp;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(v&nbsp;&lt;&nbsp;a[--j])&nbsp;if&nbsp;(j&nbsp;==&nbsp;l)&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;&gt;=&nbsp;j)&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exch(a[i],&nbsp;a[j]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(a[i]&nbsp;==&nbsp;v)&nbsp;{&nbsp;p++;&nbsp;exch(a[p],&nbsp;a[i]);&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(v&nbsp;==&nbsp;a[j])&nbsp;{&nbsp;q--;&nbsp;exch(a[j],&nbsp;a[q]);&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exch(a[i],&nbsp;a[r]);&nbsp;j&nbsp;=&nbsp;i-1;&nbsp;i&nbsp;=&nbsp;i+1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(k&nbsp;=&nbsp;l;&nbsp;k&nbsp;&lt;&nbsp;p;&nbsp;k++,&nbsp;j--)&nbsp;exch(a[k],&nbsp;a[j]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(k&nbsp;=&nbsp;r-1;&nbsp;k&nbsp;&gt;&nbsp;q;&nbsp;k--,&nbsp;i++)&nbsp;exch(a[i],&nbsp;a[k]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quicksort(a,&nbsp;l,&nbsp;j);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quicksort(a,&nbsp;i,&nbsp;r);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</CODE></P>
      <P>Armed with our new knowledge about the efficient implementation of this 
      kind of code we can write a performant F# translation immediately:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;sort&nbsp;(a:&nbsp;int&nbsp;[])&nbsp;l&nbsp;r&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;r&nbsp;&gt;&nbsp;l&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;v&nbsp;=&nbsp;a.[r]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;loop&nbsp;i&nbsp;j&nbsp;p&nbsp;q&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;i&nbsp;=&nbsp;i<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;a.[i]&nbsp;&lt;&nbsp;v&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;&lt;-&nbsp;i&nbsp;+&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;j&nbsp;=&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;v&nbsp;&lt;&nbsp;a.[j]&nbsp;&amp;&amp;&nbsp;j&nbsp;&lt;&gt;&nbsp;l&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;&lt;-&nbsp;j&nbsp;-&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;i&nbsp;&lt;&nbsp;j&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;i&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;p&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;a.[i]&nbsp;&lt;&gt;&nbsp;v&nbsp;then&nbsp;p&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;(p&nbsp;+&nbsp;1)&nbsp;i<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;+&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;q&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;v&nbsp;&lt;&gt;&nbsp;a.[j]&nbsp;then&nbsp;q&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;j&nbsp;(q&nbsp;-&nbsp;1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;-&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;(i&nbsp;+&nbsp;1)&nbsp;(j&nbsp;-&nbsp;1)&nbsp;p&nbsp;q<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;i&nbsp;r<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;j&nbsp;=&nbsp;i&nbsp;-&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;i&nbsp;=&nbsp;i&nbsp;+&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;k&nbsp;=&nbsp;l&nbsp;to&nbsp;p&nbsp;-&nbsp;1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;k&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;&lt;-&nbsp;j&nbsp;-&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;k&nbsp;=&nbsp;r&nbsp;-&nbsp;1&nbsp;downto&nbsp;q&nbsp;+&nbsp;1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;i&nbsp;k<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;&lt;-&nbsp;i&nbsp;+&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;a&nbsp;l&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;a&nbsp;i&nbsp;r<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;l&nbsp;(r&nbsp;-&nbsp;1)&nbsp;(l&nbsp;-&nbsp;1)&nbsp;r;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;sort&nbsp;:&nbsp;int&nbsp;[]&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>This is only slightly slower than the fastest implementation so 
far:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;ys&nbsp;=&nbsp;Array.copy&nbsp;xs;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;sort&nbsp;ys&nbsp;0&nbsp;(ys.Length&nbsp;-&nbsp;1);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;Real:&nbsp;00:00:02.844,&nbsp;CPU:&nbsp;00:00:02.839,&nbsp;GC&nbsp;gen0:&nbsp;0,&nbsp;gen1:&nbsp;0,&nbsp;gen2:&nbsp;0</CODE></P>
      <P>but it handles repeated elements with optimal efficiency.</P>
      <H2>Parallelism</H2>
      <P>The 3-way partitioned in-place quicksort is easily parallelized because 
      the subsorts are completely independent. Thus, a simple parallelization is 
      as follows:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;rec&nbsp;sort&nbsp;(a:&nbsp;int&nbsp;[])&nbsp;l&nbsp;r&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;r&nbsp;&gt;&nbsp;l&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;v&nbsp;=&nbsp;a.[r]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;loop&nbsp;i&nbsp;j&nbsp;p&nbsp;q&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;i&nbsp;=&nbsp;i<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;a.[i]&nbsp;&lt;&nbsp;v&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;&lt;-&nbsp;i&nbsp;+&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;j&nbsp;=&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;v&nbsp;&lt;&nbsp;a.[j]&nbsp;&amp;&amp;&nbsp;j&nbsp;&lt;&gt;&nbsp;l&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;&lt;-&nbsp;j&nbsp;-&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;i&nbsp;&lt;&nbsp;j&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;i&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;p&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;a.[i]&nbsp;&lt;&gt;&nbsp;v&nbsp;then&nbsp;p&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;(p&nbsp;+&nbsp;1)&nbsp;i<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;+&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;q&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;v&nbsp;&lt;&gt;&nbsp;a.[j]&nbsp;then&nbsp;q&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;j&nbsp;(q&nbsp;-&nbsp;1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;-&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;(i&nbsp;+&nbsp;1)&nbsp;(j&nbsp;-&nbsp;1)&nbsp;p&nbsp;q<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;i&nbsp;r<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;j&nbsp;=&nbsp;i&nbsp;-&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;i&nbsp;=&nbsp;i&nbsp;+&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;k&nbsp;=&nbsp;l&nbsp;to&nbsp;p&nbsp;-&nbsp;1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;k&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;&lt;-&nbsp;j&nbsp;-&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;k&nbsp;=&nbsp;r&nbsp;-&nbsp;1&nbsp;downto&nbsp;q&nbsp;+&nbsp;1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;i&nbsp;k<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;&lt;-&nbsp;i&nbsp;+&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;thresh&nbsp;=&nbsp;1024<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;j&nbsp;-&nbsp;l&nbsp;&lt;&nbsp;thresh&nbsp;||&nbsp;r&nbsp;-&nbsp;i&nbsp;&lt;&nbsp;thresh&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;a&nbsp;l&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;a&nbsp;i&nbsp;r<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;j&nbsp;=&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;future&nbsp;=&nbsp;System.Threading.Tasks.Task.Factory.StartNew(fun&nbsp;()&nbsp;-&gt;&nbsp;sort&nbsp;a&nbsp;l&nbsp;j)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;a&nbsp;i&nbsp;r<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;future.Wait()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;l&nbsp;(r&nbsp;-&nbsp;1)&nbsp;(l&nbsp;-&nbsp;1)&nbsp;r;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;sort&nbsp;:&nbsp;int&nbsp;[]&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>Note that we are careful to avoid parallelism when either subtask is 
      below a threshold in terms of its complexity.</P>
      <P>This parallel in-place quicksort with 3-way partitioning takes only 
      0.617s to sort our example array:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;ys&nbsp;=&nbsp;Array.copy&nbsp;xs;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;sort&nbsp;ys&nbsp;0&nbsp;(ys.Length&nbsp;-&nbsp;1);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;Real:&nbsp;00:00:00.617,&nbsp;CPU:&nbsp;00:00:03.042,&nbsp;GC&nbsp;gen0:&nbsp;0,&nbsp;gen1:&nbsp;0,&nbsp;gen2:&nbsp;0</CODE></P>
      <P>Divide-and-conquer with spawning of one independent subtask in parallel 
      is the optimal way to leverage the work-stealing architecture that 
      underpins the Task Parallel Library in .NET 4. This is essential because 
      it produces tasks that reproduce and, consequently,  are "worth stealing" 
      but the details of this architecture and its characteristics is beyond the 
      scope of this article.</P>
      <H2>Genericity</H2>
      <P>Finally, we note that an efficient generic sort would be far more 
      useful that the <CODE>int</CODE>-specific sorts covered so far. We can 
      mark the <CODE>sort</CODE> and its callee <CODE>swap</CODE> functions 
      <CODE>inline</CODE> and removing the <CODE>int</CODE> type annotation to 
      create a generic sort that is inlined:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;inline&nbsp;swap&nbsp;(a:&nbsp;_&nbsp;[])&nbsp;i&nbsp;j&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;...<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;inline&nbsp;swap&nbsp;:&nbsp;'a&nbsp;[]&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;unit<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;inline&nbsp;sort&nbsp;(a:&nbsp;_&nbsp;[])&nbsp;l&nbsp;r&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;sort&nbsp;(a:&nbsp;_&nbsp;[])&nbsp;l&nbsp;r&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;a&nbsp;l&nbsp;r;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;inline&nbsp;sort&nbsp;:&nbsp;'a&nbsp;[]&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;unit&nbsp;when&nbsp;'a&nbsp;:&nbsp;comparison</CODE></P>
      <P>Note how the recursive <CODE>sort</CODE> function is turned into a 
      nested function wrapped inside an outer non-recursive <CODE>sort</CODE> 
      function because recursive functions cannot be marked 
      <CODE>inline</CODE>.</P>
      <P>However, this results in abysmal performance:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;ys&nbsp;=&nbsp;Array.copy&nbsp;xs;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;sort&nbsp;ys&nbsp;0&nbsp;(ys.Length&nbsp;-&nbsp;1);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;Real:&nbsp;00:00:23.455,&nbsp;CPU:&nbsp;00:01:41.041,&nbsp;GC&nbsp;gen0:&nbsp;3039,&nbsp;gen1:&nbsp;2,&nbsp;gen2:&nbsp;0</CODE></P>
      <P>The problem is that the <CODE>sort</CODE> function is not being 
      specialized because the type variable it is generic over only appears in 
      the argument of another type and not directly. This can be solved by 
      explicitly passing a <CODE>compare</CODE> function that provides a total 
      order:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;inline&nbsp;sort&nbsp;cmp&nbsp;(a:&nbsp;_&nbsp;[])&nbsp;l&nbsp;r&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;sort&nbsp;(a:&nbsp;_&nbsp;[])&nbsp;l&nbsp;r&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;r&nbsp;&gt;&nbsp;l&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;v&nbsp;=&nbsp;a.[r]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;loop&nbsp;i&nbsp;j&nbsp;p&nbsp;q&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;i&nbsp;=&nbsp;i<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;cmp&nbsp;a.[i]&nbsp;v&nbsp;&lt;&nbsp;0&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;&lt;-&nbsp;i&nbsp;+&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;j&nbsp;=&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;cmp&nbsp;v&nbsp;a.[j]&nbsp;&lt;&nbsp;0&nbsp;&amp;&amp;&nbsp;j&nbsp;&lt;&gt;&nbsp;l&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;&lt;-&nbsp;j&nbsp;-&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;i&nbsp;&lt;&nbsp;j&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;i&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;p&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cmp&nbsp;a.[i]&nbsp;v&nbsp;&lt;&gt;&nbsp;0&nbsp;then&nbsp;p&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;(p&nbsp;+&nbsp;1)&nbsp;i<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;+&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;q&nbsp;=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cmp&nbsp;v&nbsp;a.[j]&nbsp;&lt;&gt;&nbsp;0&nbsp;then&nbsp;q&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;j&nbsp;(q&nbsp;-&nbsp;1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q&nbsp;-&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;(i&nbsp;+&nbsp;1)&nbsp;(j&nbsp;-&nbsp;1)&nbsp;p&nbsp;q<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;i&nbsp;r<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;j&nbsp;=&nbsp;i&nbsp;-&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;i&nbsp;=&nbsp;i&nbsp;+&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;k&nbsp;=&nbsp;l&nbsp;to&nbsp;p&nbsp;-&nbsp;1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;k&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;&lt;-&nbsp;j&nbsp;-&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;k&nbsp;=&nbsp;r&nbsp;-&nbsp;1&nbsp;downto&nbsp;q&nbsp;+&nbsp;1&nbsp;do<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;a&nbsp;i&nbsp;k<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;&lt;-&nbsp;i&nbsp;+&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;thresh&nbsp;=&nbsp;1024<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;j&nbsp;-&nbsp;l&nbsp;&lt;&nbsp;thresh&nbsp;||&nbsp;r&nbsp;-&nbsp;i&nbsp;&lt;&nbsp;thresh&nbsp;then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;a&nbsp;l&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;a&nbsp;i&nbsp;r<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;j&nbsp;=&nbsp;j<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;future&nbsp;=&nbsp;System.Threading.Tasks.Task.Factory.StartNew(fun&nbsp;()&nbsp;-&gt;&nbsp;sort&nbsp;a&nbsp;l&nbsp;j)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;a&nbsp;i&nbsp;r<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;future.Wait()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;l&nbsp;(r&nbsp;-&nbsp;1)&nbsp;(l&nbsp;-&nbsp;1)&nbsp;r<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;a&nbsp;l&nbsp;r;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;inline&nbsp;sort&nbsp;:&nbsp;('a&nbsp;-&gt;&nbsp;'a&nbsp;-&gt;&nbsp;int)&nbsp;-&gt;&nbsp;'a&nbsp;[]&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;int&nbsp;-&gt;&nbsp;unit</CODE></P>
      <P>Now the type variable <CODE>'a</CODE> appears directly in the type and 
      the application of a type-specific <CODE>compare</CODE> function causes 
      the <CODE>sort</CODE> function to be type specialized, resulting in 
      optimal performance:</P>
      <P><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;ys&nbsp;=&nbsp;Array.copy&nbsp;xs;;<BR>&nbsp;&nbsp;&nbsp;&nbsp;...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;sort&nbsp;ys&nbsp;0&nbsp;(ys.Length&nbsp;-&nbsp;1);;<BR>&nbsp;&nbsp;&nbsp;&nbsp;Real:&nbsp;00:00:00.597,&nbsp;CPU:&nbsp;00:00:03.728,&nbsp;GC&nbsp;gen0:&nbsp;0,&nbsp;gen1:&nbsp;0,&nbsp;gen2:&nbsp;0</CODE></P>
      <P>This is another reusable design pattern for high performance 
      programming in F# that has a wide variety of practical applications.</P>
      <H2>Summary</H2>
      <P>This article has evolved a generic parallel quicksort implementation 
      that is 3× faster than the built-in <CODE>Array.sort</CODE> function on 
      our example array and 100× faster than the original purely-functional 
      list-based quicksort. In the process, we studied how typical imperative 
      code that makes use of features like <CODE>break</CODE> that are not 
      available in F# can be translated into F# whilst preserving efficiency and 
      we covered how functions over generic collections can use 
      <CODE>inline</CODE> and extra argument passing to avoid the run-time 
      overhead of genericity.</P>
      <P>Future F#.NET Journal articles will revisit the subjects of sorting, 
      selection, partitioning and parallelism.</P></TD></TR></TBODY></TABLE>
<TABLE id="footer">
  <TBODY>
  <TR>
    <TD>© Flying Frog Consultancy Ltd., 2010</TD>
    <TD>Contact the            <A 
      href="mailto:webmaster@ffconsultancy.com">webmaster</A>         
  </TD></TR></TBODY></TABLE>
<SCRIPT src="F%23%20Journal%20quicksort_files/urchin.js" type="text/javascript">
    <script type="text/javascript">_uacct = "UA-197840-1"; urchinTracker();</SCRIPT>
   </BODY></HTML>
