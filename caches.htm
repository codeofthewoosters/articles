<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
  <head>
    <title>F# Journal</title>
    <link rel="stylesheet" type="text/css" href="../../../style.css"/>
    <link rel="stylesheet" type="text/css" href="../../style.css"/>
    <link rel="stylesheet" type="text/css" href="../../../individual.css"/>
  </head>
  <body>
    <table id="logo">
      <tr>
        <td width="100%">
          <img src="../../../images/title.gif"/>
        </td>
        <td>
          <img src="../../../images/left.gif"/>
        </td>
      </tr>
    </table>
    <table id="menu">
      <tr>
        <td width="25%"/>
        <td width="25%">
          <a href="../../index.html">Home Page</a>
        </td>
        <td width="25%">
          <a href="index.html">The F# Journal</a>
        </td>
        <td width="25%"/>
      </tr>
    </table>
    <table id="page">
      <tr>
        <td><h1>Caching</h1><p>Caches are ubiquitous in CPUs themselves but this article takes a look at the kinds of caches that are used in higher-level applications such as distributed web services. Caches with random eviction, round robin and least-recently used (LRU) schemes are examined.</p><h2>Introduction</h2><p>Caches are most usefully provided as an imperative data structure that maintains a mutable dictionary mapping inputs to outputs that has bindings evicted when it becomes full and added when the value corresponding to an unknown key is fetched.</p><p>The following .NET interface exposes three abstract members to count the current number of bindings, fetch the value corresponding to the given key and flush (clear) the cache, respectively:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;type&nbsp;ICache&lt;'a,&nbsp;'b&gt;&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;member&nbsp;Count&nbsp;:&nbsp;int<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;member&nbsp;Fetch&nbsp;:&nbsp;'a&nbsp;-&gt;&nbsp;'b<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;member&nbsp;Flush&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;unit;;<br />&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;ICache&lt;'a,'b&gt;&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;member&nbsp;Fetch&nbsp;:&nbsp;'a&nbsp;-&gt;&nbsp;'b<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;member&nbsp;Flush&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;unit<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;member&nbsp;Count&nbsp;:&nbsp;int<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</code></p><p>The cache implementations given in this article will all implement this <code>ICache</code> interface.</p><h2>The bag collection</h2><p>Our cache with random eviction will make use of a handy little data structure called a &quot;bag&quot;. This collection provides two core operations. The first adds an element to the bag. The second removes a randomly-chosen element from the bag.</p><p>A generic <code>Bag</code> collection may be implemented as follows in F#:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;type&nbsp;Bag&lt;'a&gt;()&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;xs&nbsp;=&nbsp;ResizeArray&lt;'a&gt;()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rand&nbsp;=&nbsp;System.Random()<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;this.Count&nbsp;=&nbsp;xs.Count<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;bag.Add&nbsp;x&nbsp;=&nbsp;xs.Add&nbsp;x<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;bag.TryRemove()&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;xs.Count&nbsp;=&nbsp;0&nbsp;then&nbsp;None&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;index&nbsp;=&nbsp;xs.Count&nbsp;-&nbsp;1&nbsp;|&gt;&nbsp;rand.Next<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x&nbsp;=&nbsp;xs.[index]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xs.RemoveAt&nbsp;index<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some&nbsp;x<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;bag.Clear()&nbsp;=&nbsp;xs.Clear();;<br />&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;Bag&lt;'a&gt;&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;Bag&lt;'a&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;Add&nbsp;:&nbsp;x:'a&nbsp;-&gt;&nbsp;unit<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;Clear&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;unit<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;TryRemove&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;'a&nbsp;option<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;Count&nbsp;:&nbsp;int<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</code></p><p>For example, a <code>Bag</code> of ints may be constructed as follows:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;let&nbsp;bag&nbsp;=&nbsp;Bag&lt;int&gt;();;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;bag&nbsp;:&nbsp;Bag&lt;int&gt;</code></p><p>Note that the generic type argument <code>&lt;int&gt;</code> is generally unnecessary in F#. We use it here to avoid the value restriction, allowing this line of code to be evaluated in F# interactive.</p><p>The numbers 1 to 10 may be added to the bag:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;Seq.iter&nbsp;bag.Add&nbsp;[1..10];;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;unit&nbsp;=&nbsp;()</code></p><p>An array of 10 numbers may then be filled from the bag:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;[|for&nbsp;i&nbsp;in&nbsp;1..10&nbsp;-&gt;&nbsp;bag.TryRemove()|];;<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;it&nbsp;:&nbsp;int&nbsp;option&nbsp;[]&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|Some&nbsp;4;&nbsp;Some&nbsp;1;&nbsp;Some&nbsp;8;&nbsp;Some&nbsp;9;&nbsp;Some&nbsp;5;&nbsp;Some&nbsp;2;&nbsp;Some&nbsp;6;&nbsp;Some&nbsp;3;&nbsp;Some&nbsp;7;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some&nbsp;10|]</code></p><p>The numbers that were added to the bag are removed in a random order.</p><h2>Cache with random eviction</h2><p>We begin by opening the following namespace to make collections like <code>Dictionary</code> more accessible:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;open&nbsp;System.Collections.Generic;;</code></p><p>A cache that evicts entries at random may then be written:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;type&nbsp;RandomCache&lt;'a,&nbsp;'b&nbsp;when&nbsp;'a:&nbsp;equality&gt;(f:&nbsp;'a&nbsp;-&gt;&nbsp;'b,&nbsp;maxSize)&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;map&nbsp;=&nbsp;Dictionary(HashIdentity.Structural)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;keys&nbsp;=&nbsp;Bag()<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;maxSize&nbsp;&lt;&nbsp;1&nbsp;then&nbsp;invalidArg&nbsp;&quot;maxSize&quot;&nbsp;&quot;maxSize&nbsp;must&nbsp;be&nbsp;at&nbsp;least&nbsp;one&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;cache.Count&nbsp;=&nbsp;map.Count<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;cache.Fetch&nbsp;key&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;value&nbsp;=&nbsp;Unchecked.defaultof&lt;_&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;map.TryGetValue(key,&nbsp;&amp;value)&nbsp;then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;map.Count&nbsp;=&nbsp;maxSize&nbsp;then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keys.TryRemove()&nbsp;|&gt;&nbsp;Option.iter&nbsp;(map.Remove&nbsp;&gt;&gt;&nbsp;ignore)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;value&nbsp;=&nbsp;f&nbsp;key<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.[key]&nbsp;&lt;-&nbsp;value<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keys.Add&nbsp;key<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;cache.Flush()&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.Clear()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keys.Clear()<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface&nbsp;ICache&lt;'a,&nbsp;'b&gt;&nbsp;with<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;cache.Count&nbsp;=&nbsp;cache.Count<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;cache.Fetch&nbsp;x&nbsp;=&nbsp;cache.Fetch&nbsp;x<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;cache.Flush()&nbsp;=&nbsp;cache.Flush();;<br />&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;RandomCache&lt;'a,'b&nbsp;when&nbsp;'a&nbsp;:&nbsp;equality&gt;&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface&nbsp;ICache&lt;'a,'b&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;:&nbsp;f:('a&nbsp;-&gt;&nbsp;'b)&nbsp;*&nbsp;maxSize:int&nbsp;-&gt;&nbsp;RandomCache&lt;'a,'b&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;Fetch&nbsp;:&nbsp;x:'a&nbsp;-&gt;&nbsp;'b<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;Flush&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;unit<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;Count&nbsp;:&nbsp;int<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</code></p><p>This implementation uses a dictionary to record the key-value relationships currently in the cache and a bag of keys to choose a key at random when one must be evicted.</p><p>The <code>Fetch</code> member searches for the value that corresponds to the given key in the <code>map</code> dictionary. If the corresponding value is found (a cache hit) then it is returned immediately. Otherwise (a cache miss), if the cache is full then a key is chosen at random from the bag and removed from the cache before the corresponding value is obtained from the key using the <code>f</code> function that the cache was constructed with.</p><p>A cache with random eviction actually offers a simple and elegant solution that works fairly well in all circumstances.</p><h2>Round-robin cache</h2><p>Random eviction penalizes some access patterns that could fit entirely in-cache. For example, if recent keys are used more often then there is a small but potentially significant probability that they will be evicted. Other caching schemes offer different trade-offs in such circumstances and the round-robin scheme is one such algorithm.</p><p>The round robin scheme queues the keys that cause cache misses and, therefore, always evicts the oldest cache entry. A cache using this scheme may be written using the .NET <code>Queue</code> collection as follows:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;type&nbsp;RoundRobinCache&lt;'a,&nbsp;'b&nbsp;when&nbsp;'a:&nbsp;equality&gt;(f:&nbsp;'a&nbsp;-&gt;&nbsp;'b,&nbsp;maxSize)&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;map&nbsp;=&nbsp;Dictionary&lt;'a,&nbsp;'b&gt;(HashIdentity.Structural)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;queue&nbsp;=&nbsp;Queue()<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;maxSize&nbsp;&lt;&nbsp;1&nbsp;then&nbsp;invalidArg&nbsp;&quot;maxSize&quot;&nbsp;&quot;maxSize&nbsp;must&nbsp;be&nbsp;at&nbsp;least&nbsp;one&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;cache.Count&nbsp;=&nbsp;map.Count<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;cache.Fetch&nbsp;key&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;value&nbsp;=&nbsp;Unchecked.defaultof&lt;_&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;map.TryGetValue(key,&nbsp;&amp;value)&nbsp;then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;map.Count&nbsp;=&nbsp;maxSize&nbsp;then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.Dequeue()&nbsp;|&gt;&nbsp;map.Remove&nbsp;|&gt;&nbsp;ignore<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;value&nbsp;=&nbsp;f&nbsp;key<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.[key]&nbsp;&lt;-&nbsp;value<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.Enqueue&nbsp;key<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;cache.Flush()&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.Clear()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.Clear()<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface&nbsp;ICache&lt;'a,&nbsp;'b&gt;&nbsp;with<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;cache.Count&nbsp;=&nbsp;cache.Count<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;cache.Fetch&nbsp;x&nbsp;=&nbsp;cache.Fetch&nbsp;x<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;cache.Flush()&nbsp;=&nbsp;cache.Flush();;<br />&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;RoundRobinCache&lt;'a,'b&nbsp;when&nbsp;'a&nbsp;:&nbsp;equality&gt;&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface&nbsp;ICache&lt;'a,'b&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;:&nbsp;f:('a&nbsp;-&gt;&nbsp;'b)&nbsp;*&nbsp;maxSize:int&nbsp;-&gt;&nbsp;RoundRobinCache&lt;'a,'b&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;Fetch&nbsp;:&nbsp;x:'a&nbsp;-&gt;&nbsp;'b<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;Flush&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;unit<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;Count&nbsp;:&nbsp;int<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</code></p><p>The round robin cache scheme can be more effective than random eviction and retains the advantage that a cache hit is still very fast: a hash table lookup. More sophisticated caching schemes sacrifice the performance of a cache hit for the ability to retain cache entries retrieved by recent cache hits.</p><h2>Least-recently used cache</h2><p>A more sophisticated caching scheme that keeps track of how recently a cache line has been hit is called the least-recently used (LRU) scheme. This is trickier to implement, requiring a linked list of keys allowing cache hits to migrate the node containing the key to the front of the list and a dictionary to associate each key with its corresponding node in the linked list:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;type&nbsp;LeastRecentlyUsedCache&lt;'a,&nbsp;'b&nbsp;when&nbsp;'a:&nbsp;equality&gt;(f:&nbsp;'a&nbsp;-&gt;&nbsp;'b,&nbsp;maxSize)&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;map&nbsp;=&nbsp;Dictionary&lt;'a,&nbsp;'b&gt;(HashIdentity.Structural)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;links&nbsp;=&nbsp;Dictionary&lt;'a,&nbsp;LinkedListNode&lt;'a&gt;&gt;(HashIdentity.Structural)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;list&nbsp;=&nbsp;LinkedList&lt;'a&gt;()<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;maxSize&nbsp;&lt;&nbsp;1&nbsp;then&nbsp;invalidArg&nbsp;&quot;maxSize&quot;&nbsp;&quot;maxSize&nbsp;must&nbsp;be&nbsp;at&nbsp;least&nbsp;one&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;cache.Count&nbsp;=&nbsp;map.Count<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;cache.Fetch&nbsp;key&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mutable&nbsp;value&nbsp;=&nbsp;Unchecked.defaultof&lt;_&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;map.TryGetValue(key,&nbsp;&amp;value)&nbsp;then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.Remove&nbsp;links.[key]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;links.[key]&nbsp;&lt;-&nbsp;list.AddFirst&nbsp;key<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;map.Count&nbsp;=&nbsp;maxSize&nbsp;then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;key&nbsp;=&nbsp;list.Last.Value<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.RemoveLast()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.Remove&nbsp;key&nbsp;|&gt;&nbsp;ignore<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;links.Remove&nbsp;key&nbsp;|&gt;&nbsp;ignore<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;&lt;-&nbsp;f&nbsp;key<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.[key]&nbsp;&lt;-&nbsp;value<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;links.[key]&nbsp;&lt;-&nbsp;list.AddFirst&nbsp;key<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;cache.Flush()&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.Clear()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;links.Clear()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.Clear()<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface&nbsp;ICache&lt;'a,&nbsp;'b&gt;&nbsp;with<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;cache.Count&nbsp;=&nbsp;cache.Count<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;cache.Fetch&nbsp;x&nbsp;=&nbsp;cache.Fetch&nbsp;x<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;cache.Flush()&nbsp;=&nbsp;cache.Flush();;<br />&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;LeastRecentlyUsedCache&lt;'a,'b&nbsp;when&nbsp;'a&nbsp;:&nbsp;equality&gt;&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface&nbsp;ICache&lt;'a,'b&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;:&nbsp;f:('a&nbsp;-&gt;&nbsp;'b)&nbsp;*&nbsp;maxSize:int&nbsp;-&gt;&nbsp;LeastRecentlyUsedCache&lt;'a,'b&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;Fetch&nbsp;:&nbsp;x:'a&nbsp;-&gt;&nbsp;'b<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;Flush&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;unit<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;Count&nbsp;:&nbsp;int<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</code></p><p>In the event of a cache hit, the <code>Fetch</code> member moves the node in the linked list containing the key to the front of the list. In the event of a cache miss when the cache is full, the key at the back of the linked list (which is the least recently used key) is evicted and the new key is added to the front of the list.</p><p>For example, with a cache that can hold at most 3 entries, searching for the sequence 1, 2, 3, 1, 4, 5 causes 2 to be evicted when 4 is searched for a 3 to be evicted when 5 is searched for. This can be seen as follows if the <code>Fetch</code> function is augmented with a line to print entries as they are evicted:</p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;do<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;cache&nbsp;=&nbsp;LeastRecentlyUsedCache(id,&nbsp;3)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;[1;2;3;1;4;5]&nbsp;do<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cache.Fetch&nbsp;j&nbsp;|&gt;&nbsp;printfn&nbsp;&quot;%A&nbsp;-&gt;&nbsp;%A&quot;&nbsp;j;;<br />&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;-&gt;&nbsp;1<br />&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;-&gt;&nbsp;2<br />&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;-&gt;&nbsp;3<br />&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;-&gt;&nbsp;1<br />&nbsp;&nbsp;&nbsp;&nbsp;Evicting&nbsp;2<br />&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;-&gt;&nbsp;4<br />&nbsp;&nbsp;&nbsp;&nbsp;Evicting&nbsp;3<br />&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;-&gt;&nbsp;5</code></p><h2>Summary</h2><p>This article has described three different kinds of cache, each with its own strengths and weaknesses. A cache with random eviction handles performance degradation gracefully as larger data sets are accessed. The round robin scheme handles the case where commonly-accessed data fits in-cache efficiently at the expense of worst-case performance otherwise. The least-recently used (LRU) caching scheme sacrifices performance on cache hits for more intelligent eviction that pays off when temporal locality is good and cache misses are expensive.</p><p>Future articles will revisit the subject of caching in the context of accelerating distributed systems using caches, where cache misses can be very expensive.</p>        </td>
      </tr>
    </table>
    <table id="footer">
      <tr>
        <td>&copy; Flying Frog Consultancy Ltd., 2010</td>
        <td>
Contact the 
          <a href="mailto:webmaster@ffconsultancy.com">webmaster</a>
        </td>
      </tr>
    </table>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"/>
    <script type="text/javascript">_uacct = "UA-197840-1"; urchinTracker();</script>
  </body>
</html>
